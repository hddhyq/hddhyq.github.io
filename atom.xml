<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hddhyq&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hddhyq.github.io/"/>
  <updated>2019-01-31T15:44:16.116Z</updated>
  <id>https://hddhyq.github.io/</id>
  
  <author>
    <name>hddhyq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CircleCI实践gh-pages部署</title>
    <link href="https://hddhyq.github.io/2019/01/31/CircleCI%E5%AE%9E%E8%B7%B5gh-pages%E9%83%A8%E7%BD%B2/"/>
    <id>https://hddhyq.github.io/2019/01/31/CircleCI实践gh-pages部署/</id>
    <published>2019-01-31T14:22:35.000Z</published>
    <updated>2019-01-31T15:44:16.116Z</updated>
    
    <content type="html"><![CDATA[<p>这里展示一下CircleCI集成与github之间联系。<br><a id="more"></a></p><p>当你在Circle中添加一个项目时。相关的 GitHub 设置中将会使用您在注册时为CircleCI提供的权限。</p><ul><li><code>deloy key</code> 用来从 GitHub 中查看项目源代码。</li><li><code>service hook</code> 用来通知 CircleCI ，当你向 GitHub 中提交代码。</li></ul><p>常见 push hooks：</p><p>另外 两个钩子：</p><ul><li>提供PR hooks，用来储存 PR 请求。</li><li>如果PR钩子在forked的项目中，CircleCI将会在PRs在分支仓库创建时提交。</li></ul><p>详见 <a href="https://circleci.com/docs/2.0/workflows/#using-contexts-and-filtering-in-your-workflows" target="_blank" rel="noopener">workflows filters</a></p><p>CircleCI在每次测试都会清理容器。你的 github 的仪表盘中也会有显示。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/circleci/status_check.png" alt=""></p><h1 id="使你CircleCI的项目能够检出私有仓库"><a href="#使你CircleCI的项目能够检出私有仓库" class="headerlink" title="使你CircleCI的项目能够检出私有仓库"></a>使你CircleCI的项目能够检出私有仓库</h1><p>如果你的测试过程涉及多个存储库，除了部署密钥之外，CircleCI还需要GitHub用户密钥，因为每个部署密钥仅对一个储存库有效，而GitHub用户莫要可以访问所有GitHub储存库。查看<a href="https://circleci.com/docs/2.0/add-ssh-key" target="_blank" rel="noopener">adding ssh keys</a>章节来查看更多。</p><p>在 <strong>Project Settings &gt; Checkout SSH keys</strong> 页面提供给 CircleCI GitHub用户私钥。CircleCI创建和关联新的SSH密钥来访问你的所有的仓库。</p><h2 id="用户密钥安全"><a href="#用户密钥安全" class="headerlink" title="用户密钥安全"></a>用户密钥安全</h2><p>CircleCI 绝对不会公开你的SSH密钥。</p><p>请记住，SSH密钥只能分享给信任的用户，所有的 GitHub 合作者拥有了SSH密钥都可以访问你的仓库。所以要确保你的SSH密钥的安全。</p><h2 id="用户密钥访问相关错误信息"><a href="#用户密钥访问相关错误信息" class="headerlink" title="用户密钥访问相关错误信息"></a>用户密钥访问相关错误信息</h2><p>下面的错误表明你需要添加用户密钥</p><p><strong>Python</strong>: 在 <code>pip install</code>步骤期间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR: Repository not found.</div></pre></td></tr></table></figure><p><strong>Ruby</strong>: 在<code>bundle install</code>步骤期间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Permission denied (publickey).</div></pre></td></tr></table></figure><h1 id="创建机器用户"><a href="#创建机器用户" class="headerlink" title="创建机器用户"></a>创建机器用户</h1><p>要对多个存储库进行细粒度访问，请考虑为CircleCI项目创建机器用户。一个机器用户是你为运行自动化任务而创建的GitHub用户。通过使用机器用户的SSH密钥，你可以允许任何人对仓库进行，构造，测试和部署项目。创建机器用户还可以降低丢失与单个用户关联的凭据的风险。</p><p>要为机器用户使用SSH密钥，请遵循下列步骤：</p><p><strong>注意</strong>: 要执行下列步骤，机器用户必须拥有管理员权限。完成项目添加后，可以将机器用户权限设为只读。</p><ol><li>根据<a href="https://developer.github.com/v3/guides/managing-deploy-keys/#machine-users" target="_blank" rel="noopener">instructions on GitHub</a>，创建机器用户权限。</li><li>作为机器用户登陆Github。</li><li><a href="https://circleci.com/login" target="_blank" rel="noopener">登陆CircleCI</a>。当GitHub提醒你需要授权给CircleCI的时候，点击 <strong>Authorize application</strong> 按钮。</li><li>在<a href="https://circleci.com/add-projects" target="_blank" rel="noopener">添加项目</a>, follow你希望使用机器用户访问的项目。</li><li>在 <strong>Project Settings &gt; Checkout SSH keys</strong>页面，点击 <strong>Authorize With GitHub</strong> 按钮。这将给CircleCI权限作为机器用户去创造和上传SSH密钥。</li><li>点击 <strong>Create and add XXXX user Key</strong> 按钮。</li></ol><p>现在Circle将使用机器用户的SSH密钥来使用Git命令行运行你的构建。</p><h1 id="权限概述"><a href="#权限概述" class="headerlink" title="权限概述"></a>权限概述</h1><p>CircleCI要求你的版本控制系统（VCS）提供以下权限，<a href="http://developer.github.com/v3/oauth/#scopes" target="_blank" rel="noopener">GitHub permissions model</a></p><h2 id="读权限"><a href="#读权限" class="headerlink" title="读权限"></a>读权限</h2><ul><li>获取用户的邮件地址</li></ul><h2 id="写权限"><a href="#写权限" class="headerlink" title="写权限"></a>写权限</h2><ul><li>给仓库添加部署密钥</li><li>给仓库添加服务器钩子</li><li>获取用户所有仓库的列表</li><li>给用户账户添加SSH密钥</li></ul><p><strong>注意</strong>: CircleCI只有在必须的时候才会请求权限。但是，CircleCI受到VCS提供的权限约束。举例，从GitHub获取所有用户仓库，需要写权限，因为GitHub没有提供只读权限。</p><p>如果你强烈的希望减少CircleCI的使用，考虑向你的VCS供应商联系。</p><h2 id="团队账户权限"><a href="#团队账户权限" class="headerlink" title="团队账户权限"></a>团队账户权限</h2><p>本节概述了可用于满足各种业务需求的团队和个人帐户选择：</p><ol><li><p>如果单个用户拥有个人GitHub账户，他会使用它登录CircleCI然后在CircleCI里follow任务。GitHub中该存储库上的每个“协作者”也能够跟踪项目并在推送提交时构建在CircleCI上。由于GitHub储存协作者的方式，CircleCI不会显示完整的列表。有关合作者的完整列表需要参阅GitHub。</p></li><li><p>如果一个个人用户升级到团队用户，他们将被允许添加用户，甚至给那些运行构建任务的合作者管理者权限。团队用户的拥有者必须到CircleCI的<a href="https://circleci.com/add-projects" target="_blank" rel="noopener">Add Project</a>，点击链接到GitHub应用权限界面，选择授权CircleCI来使组织的成员通过他们的账户follow项目。拥有两名成员的团队帐户每月25美元，而不是个人帐户每月7美元。</p></li><li><p>对于最多五人的团队，个人Bitbucket账户可免费用于私人回购。个人可以创建Bitbucket团队，添加成员并根据需要为需要构建的人员提供管理员权限。该项目将出现在CircleCI中，供会员遵循，无需额外费用。</p></li></ol><h2 id="如何为GitHub组织重新启用CircleCI"><a href="#如何为GitHub组织重新启用CircleCI" class="headerlink" title="如何为GitHub组织重新启用CircleCI"></a>如何为GitHub组织重新启用CircleCI</h2><p>这一章节描述了如何在GitHub组织启用了第三方应用程序限制后重新启用CircleCi。参见[GitHub Seeting]。</p><ul><li>“申请进入”，如果你不是组织的管理者会有这种问题。管理者应该批准访问。</li><li>“授予访问权限”如果你是管理者应该给予。</li></ul><p>获取访问权限后，CircleCi的行为将会正常。</p><p>GitHub最近添加了在每个组织级别<a href="third party application access on a per-organization level">准第三方程序访问权限</a>。再此之前，组织的成员都能授权给应用（生成 OAhth token 关联他们的GitHub用户账户），而且应用可以使用 OAuth token 来代表用户行事，可以使用OAuth flow中的任何权限。</p><p>现在的当第三方组织限制打开的时候，OAuth token默认情况下没有办法访问第三方数据。不管是OAuth进程之前或者之后，你必须准备为组织申请权限，然后组织管理者需要批准权限。</p><p>你也可以在GitHub的组织设置界面打开第三方访问权限。并单击“第三方应用程序访问策略”部分中的“设置应用程序访问限制”按钮。</p><p>如果您对已运行CircleCI的组织启用这些限制，那么我们将停止从GitHub接收推送事件挂钩（因此不会构建新的推送）。而且API调用将被拒绝（例如，导致重新构建旧版本以使源检出失败。）要使CircleCI再次运行，您必须授予对CircleCI应用程序的访问权限。</p><h1 id="部署密钥和用户密钥"><a href="#部署密钥和用户密钥" class="headerlink" title="部署密钥和用户密钥"></a>部署密钥和用户密钥</h1><h2 id="什么是部署密钥？"><a href="#什么是部署密钥？" class="headerlink" title="什么是部署密钥？"></a>什么是部署密钥？</h2><p>当你创建新项目的时候，CircleCi将会为你的项目在基于网络的分布式系统上（例如GitHub和Bitbucket）创建密钥。部署密钥是仓库专属的密钥。如果你使用GitHub作为你的分布式系统，而且GitHub有用公钥，CircleCi将会储存私有秘钥。部署密钥给CircleCi访问单个仓库的权限。为了保护CircleCi不能推送内容到你的仓库，部署密钥是只读的。</p><p>如果你想要在构建中push内容到你的仓库，你需要一个拥有读写取新鲜的部署密钥，即用户密钥。下面几步展示了为你的VCS创建用户密钥。</p><h2 id="什么是用户密钥？"><a href="#什么是用户密钥？" class="headerlink" title="什么是用户密钥？"></a>什么是用户密钥？</h2><p>一个用户密钥是用户专属的SSH密钥。你的VCS拥有公钥，CircleCi存储私钥。拥有私钥能够给予你模仿用户的能力，像使用<code>git</code>访问项目。</p><h2 id="创建GitHub用户密钥"><a href="#创建GitHub用户密钥" class="headerlink" title="创建GitHub用户密钥"></a>创建GitHub用户密钥</h2><p>在下面的例子中，GitHub仓库是<code>https://github.com/you/test-repo</code>，你的CircleCi项目是<a href="https://circleci.com/gh/you/test-repo" target="_blank" rel="noopener">https://circleci.com/gh/you/test-repo</a>。</p><ol><li>根据<a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/" target="_blank" rel="noopener">GitHub instructions</a>创建SSH密钥。当提示输入密码的时候，一定不要输入密码。</li></ol><p><strong>警告</strong>：默认情况下，ssh-keygen中的最新更新不会以PEM格式生成密钥。如果你的密钥不是以<code>-----BEGIN RSA PRIVATE KEY-----</code>开始，通过使用<code>ssh-keygen -m PEM -t rsa -C &quot;your_email@example.com&quot;</code>来强制生成密钥。</p><ol><li><p>到<code>https://github.com/you/test-repo/settings/keys</code>，点击”Add deploy key”。在 Title 输入框写下标题，复制粘贴你在第一步创建的密钥，点击”Allow write access”，然后点击”Add key”。</p></li><li><p>到 <a href="https://circleci.com/gh/you/test-repo/edit#ssh" target="_blank" rel="noopener">https://circleci.com/gh/you/test-repo/edit#ssh</a>，添加在上面创建的密钥到”Hostname”输入框，输入”github.com”，添加提交按钮</p></li><li><p>在你的 config.yml ，添加指纹到<code>add_ssh_keys</code>。</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">version:</span> <span class="number">2</span></div><div class="line"><span class="attr">jobs:</span></div><div class="line"><span class="attr">  deploy-job:</span></div><div class="line"><span class="attr">    steps:</span></div><div class="line"><span class="attr">      - add_ssh_keys:</span></div><div class="line"><span class="attr">          fingerprints:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">"SO:ME:FIN:G:ER:PR:IN:T"</span></div></pre></td></tr></table></figure><h2 id="这些键是怎么用的？"><a href="#这些键是怎么用的？" class="headerlink" title="这些键是怎么用的？"></a>这些键是怎么用的？</h2><p>当CircleCi构建你的项目的时候，私有秘钥会被创建到<code>.ssh</code>目录，随后将SSH配置为与您的版本控制提供程序进行通信。此后，私有秘钥会给用户提供下列权限：</p><ul><li>检查主要项目。</li><li>检查任何 GitHub 托管的子项目。</li><li>检查任何 GitHub 托管的私有依赖项。</li><li>自动化 git 的合并和打标签等操作。</li></ul><p>由于上述的原因，部署建对于需要添加私有依赖项的项目功能不够强大。</p><h2 id="关于安全因素？"><a href="#关于安全因素？" class="headerlink" title="关于安全因素？"></a>关于安全因素？</h2><p>私钥对于CircleCi生成的密钥绝对不会离开CircleCi系统，只有公钥会被传输给GitHub。私钥会被安全加密的存储。然而，当你将私钥用于你构建的容器，你的CircleCi的任何代码都可以读到他们。</p><h2 id="部署密钥和用户密钥的区别？"><a href="#部署密钥和用户密钥的区别？" class="headerlink" title="部署密钥和用户密钥的区别？"></a>部署密钥和用户密钥的区别？</h2><p>部署密钥和用户密钥是GitHub唯一支持的密钥类型。部署密钥是全局唯一的，举例来说，没有机制能使部署密钥访问多个仓库。而用户密钥没有分割区域，用户可以访问所有与之相关的仓库。</p><p>为了实现访问多个不同的仓库，应该考录常见一个GitHub的机器用户。给这个用户你构建项目所需要的权限，然后再CircleCi上关联用户密钥到你的项目。</p><h1 id="关于GitHub机器用户"><a href="#关于GitHub机器用户" class="headerlink" title="关于GitHub机器用户"></a>关于GitHub机器用户</h1><p>如果你的服务需要访问多个仓库，你可以创建一个新的GitHub账户，然后连接的SSH密钥，仅仅用以项目的自动化。这样的Github账户不会被用户使用，这样的Github账户被称作机器账户。你可以添加一个机器用户作为个人账户的合作者（授予读写权限），或者作为公共仓库的外有合作者（授予读写或者管理者权限），或者作为需要自动化的团队仓库。</p><blockquote><p>GitHub服务条框是:<br>  不允许机器或者自动化注册账户.<br>  这表示你不能自动创建账户.但是如果你只是创建一个私有用户来为你的项目或者组织运行自动化脚本,这么做是推荐的.</p></blockquote><h2 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h2><ul><li>任何有权访问仓库或者服务的人都有能力部署项目.</li><li>真实用户,或者说是人类用户,不需要改变他们的本地SSH密钥.</li><li>多个密钥是不需要的,一个服务就够了.</li></ul><h2 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h2><ul><li>只有组织能够限制机器用户值有读写权限.个人仓库总是授予合作者读写权限.</li><li>机器用户密钥和部署密钥一样,不受密码保护.</li></ul><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ol><li><a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#generating-a-new-ssh-key" target="_blank" rel="noopener">运行ssh-keygen过程</a>在你的服务器上,然后通过机器用户连接公钥.</li><li>给及其用户你想自动化的仓库.你可以通过添加账户作为合作者,作为一个外界合作者,或者组织的一个团队.</li></ol><h1 id="gh-pages实践步骤"><a href="#gh-pages实践步骤" class="headerlink" title="gh-pages实践步骤"></a>gh-pages实践步骤</h1><h2 id="1-创建机器用户"><a href="#1-创建机器用户" class="headerlink" title="1. 创建机器用户"></a>1. 创建机器用户</h2><p>经过上面的介绍，基本上应该知道。<code>push</code> dist 目录到相应的分支，这里需要用到<code>push</code>的权限。我们必不可少的就是需要一个用户密钥。使用用户密钥的方法就是利用新创建一个git用户，下面我创建了一个<code>hddMachine</code>的用户。然后原仓库的管理者将机器用户添加到合作者中，然后在CircleCI中生成对应的<code>fingerprints</code>，并添加到下面的yml文件。这样当我们每次<code>push</code>的时候就会调用机器用户权限来使用 git 命令。</p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="attr">version:</span> <span class="number">2</span></div><div class="line"><span class="attr">jobs:</span></div><div class="line"><span class="attr">  build:</span></div><div class="line"><span class="attr">    working_directory:</span> <span class="string">~/repo</span> <span class="comment"># directory where steps will run</span></div><div class="line"><span class="attr">    docker:</span> <span class="comment"># use the docker executor type; machine and macos executors are also supported</span></div><div class="line"><span class="attr">      - image:</span> <span class="string">circleci/node:8.10</span> <span class="comment"># the primary container, where your job's commands are run</span></div><div class="line"><span class="attr">    filters:</span></div><div class="line"><span class="attr">      branches:</span></div><div class="line"><span class="attr">        only:</span> <span class="string">master</span></div><div class="line"><span class="attr">    steps:</span></div><div class="line"><span class="attr">      - add_ssh_keys:</span></div><div class="line"><span class="attr">          fingerprints:</span> <span class="string">'41:f1:b3:2d:89:ff:f0:16:a4:eb:49:92:39:27:95:04'</span></div><div class="line"><span class="bullet">      -</span> <span class="string">checkout</span> <span class="comment"># check out the code in the project directory</span></div><div class="line"><span class="attr">      - run:</span></div><div class="line"><span class="attr">          name:</span> <span class="string">update-npm</span></div><div class="line"><span class="attr">          command:</span> <span class="string">'sudo npm install -g npm@latest'</span></div><div class="line"><span class="attr">      - restore_cache:</span> <span class="comment"># special step to restore the dependency cache</span></div><div class="line">          <span class="comment"># Read about caching dependencies: https://circleci.com/docs/2.0/caching/</span></div><div class="line"><span class="attr">          key:</span> <span class="string">dependency-cache-&#123;&#123;</span> <span class="string">checksum</span> <span class="string">"package.json"</span> <span class="string">&#125;&#125;</span></div><div class="line"><span class="attr">      - run:</span></div><div class="line"><span class="attr">          name:</span> <span class="string">install-npm</span></div><div class="line"><span class="attr">          command:</span> <span class="string">npm</span> <span class="string">install</span></div><div class="line"><span class="attr">      - save_cache:</span> <span class="comment"># special step to save the dependency cache</span></div><div class="line"><span class="attr">          key:</span> <span class="string">dependency-cache-&#123;&#123;</span> <span class="string">checksum</span> <span class="string">"package.json"</span> <span class="string">&#125;&#125;</span></div><div class="line"><span class="attr">          paths:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">./node_modules</span></div><div class="line"><span class="attr">      - run:</span> <span class="comment"># run build</span></div><div class="line"><span class="attr">          name:</span> <span class="string">build</span></div><div class="line"><span class="attr">          command:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></div><div class="line"><span class="attr">      - run:</span> <span class="comment"># git push</span></div><div class="line"><span class="attr">          name:</span> <span class="string">push-github</span></div><div class="line"><span class="attr">          command:</span> <span class="string">|</span></div><div class="line"><span class="string">            git config --global user.email "975018306@qq.com"</span></div><div class="line"><span class="string">            git config --global user.name "hddMachine"</span></div><div class="line"><span class="string">            git add -f dist</span></div><div class="line"><span class="string">            git commit -m 'create dist'</span></div><div class="line"><span class="string">            git push origin `git subtree split --prefix dist master`:gh-pages --force</span></div></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://circleci.com/docs/2.0/configuration-reference/#add_ssh_keys" target="_blank" rel="noopener">https://circleci.com/docs/2.0/configuration-reference/#add_ssh_keys</a></li><li><a href="https://circleci.com/docs/2.0/language-javascript/" target="_blank" rel="noopener">https://circleci.com/docs/2.0/language-javascript/</a></li><li><a href="https://github.com/CircleCI-Public/circleci-demo-javascript-express/blob/master/.circleci/config.yml" target="_blank" rel="noopener">https://github.com/CircleCI-Public/circleci-demo-javascript-express/blob/master/.circleci/config.yml</a></li><li><a href="https://stackoverflow.com/questions/13756055/git-subtree-subtree-up-to-date-but-cant-push" target="_blank" rel="noopener">git-subtree-cant-push</a></li><li><a href="https://circleci.com/docs/2.0/gh-bb-integration/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">GitHub和Bitbucket使用CircleCI</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里展示一下CircleCI集成与github之间联系。&lt;br&gt;
    
    </summary>
    
      <category term="CircleCI" scheme="https://hddhyq.github.io/categories/CircleCI/"/>
    
    
      <category term="自动化" scheme="https://hddhyq.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="git" scheme="https://hddhyq.github.io/tags/git/"/>
    
      <category term="GitHub" scheme="https://hddhyq.github.io/tags/GitHub/"/>
    
      <category term="CircleCI" scheme="https://hddhyq.github.io/tags/CircleCI/"/>
    
  </entry>
  
  <entry>
    <title>CircleCI简单概念</title>
    <link href="https://hddhyq.github.io/2019/01/25/CircleCI%E7%AE%80%E5%8D%95%E6%A6%82%E5%BF%B5/"/>
    <id>https://hddhyq.github.io/2019/01/25/CircleCI简单概念/</id>
    <published>2019-01-25T13:05:10.000Z</published>
    <updated>2019-01-31T15:03:13.111Z</updated>
    
    <content type="html"><![CDATA[<p>又是关于前两个星期零零星星看的文章的总结，主要关于 CircleCI 。首先是CircleCI的介绍，然后下一篇文字介绍下部署一个vue项目到gh-pages的步骤。<br><a id="more"></a></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><a href="https://circleci.com/docs/2.0/hello-world/" target="_blank" rel="noopener">导航</a>,<a href="https://circleci.com/docs/2.0/concepts/" target="_blank" rel="noopener">概念</a></p><h2 id="步骤（Steps）"><a href="#步骤（Steps）" class="headerlink" title="步骤（Steps）"></a>步骤（Steps）</h2><p>步骤一般是可执行的命令组成的。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#...</span></div><div class="line"><span class="attr">    steps:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">checkout</span> <span class="comment"># Special step to checkout your source code</span></div><div class="line"><span class="attr">      - run:</span> <span class="comment"># Run step to execute commands, see</span></div><div class="line">      <span class="comment"># circleci.com/docs/2.0/configuration-reference/#run</span></div><div class="line"><span class="attr">          name:</span> <span class="string">Running</span> <span class="string">tests</span></div><div class="line"><span class="attr">          command:</span> <span class="string">make</span> <span class="string">test</span> <span class="comment"># executable command run in</span></div><div class="line">          <span class="comment"># non-login shell with /bin/bash -eo pipefail option</span></div><div class="line">          <span class="comment"># by default.</span></div><div class="line"><span class="comment">#...</span></div></pre></td></tr></table></figure><h2 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h2><p>指定确定的docker容器。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="string">version</span> <span class="number">2</span></div><div class="line"><span class="attr">jobs:</span></div><div class="line"><span class="attr">  build1:</span> <span class="comment"># job name</span></div><div class="line"><span class="attr">    docker:</span> <span class="comment"># Specifies the primary container image,</span></div><div class="line">    <span class="comment"># see circleci.com/docs/2.0/circleci-images/ for</span></div><div class="line">    <span class="comment"># the list of pre-built CircleCI images on dockerhub.</span></div><div class="line"><span class="attr">      - image:</span> <span class="attr">buildpack-deps:trusty</span></div><div class="line"></div><div class="line"><span class="attr">      - image:</span> <span class="attr">postgres:9.4.1</span> <span class="comment"># Specifies the database image</span></div><div class="line">      <span class="comment"># for the secondary or service container run in a common</span></div><div class="line">      <span class="comment"># network where ports exposed on the primary container are</span></div><div class="line">      <span class="comment"># available on localhost.</span></div><div class="line"><span class="attr">        environment:</span> <span class="comment"># Specifies the POSTGRES_USER authentication</span></div><div class="line">        <span class="comment"># environment variable, see circleci.com/docs/2.0/env-vars/</span></div><div class="line">        <span class="comment"># for instructions about using environment variables.</span></div><div class="line"><span class="attr">          POSTGRES_USER:</span> <span class="string">root</span></div><div class="line"><span class="string">...</span></div><div class="line"><span class="attr">  build2:</span></div><div class="line"><span class="attr">    machine:</span> <span class="comment"># Specifies a machine image that uses</span></div><div class="line">    <span class="comment"># an Ubuntu version 14.04 image with Docker 17.06.1-ce</span></div><div class="line">    <span class="comment"># and docker-compose 1.14.0, follow CircleCI Discuss Announcements</span></div><div class="line">    <span class="comment"># for new image releases.</span></div><div class="line"><span class="attr">      image:</span> <span class="string">circleci/classic:201708-01</span></div><div class="line"><span class="string">...</span>       </div><div class="line"><span class="attr">  build3:</span></div><div class="line"><span class="attr">    macos:</span> <span class="comment"># Specifies a macOS virtual machine with Xcode version 9.0</span></div><div class="line"><span class="attr">      xcode:</span> <span class="string">"9.0"</span>       </div><div class="line"><span class="string">...</span></div></pre></td></tr></table></figure><h2 id="任务（Jobs）"><a href="#任务（Jobs）" class="headerlink" title="任务（Jobs）"></a>任务（Jobs）</h2><p>任务是步骤的集合，单个任务必须指定<code>docker</code>，<code>machine</code>和<code>macos</code>。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>可以缓存诸如项目中源代码的依赖的文件或者目录。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="attr">version:</span> <span class="number">2</span></div><div class="line"><span class="attr">jobs:</span></div><div class="line"><span class="attr">  build1:</span></div><div class="line"><span class="attr">    docker:</span> <span class="comment"># Each job requires specifying an executor</span></div><div class="line">    <span class="comment"># (either docker, macos, or machine), see</span></div><div class="line">    <span class="comment"># circleci.com/docs/2.0/executor-types/ for a comparison</span></div><div class="line">    <span class="comment"># and more examples.</span></div><div class="line"><span class="attr">      - image:</span> <span class="string">circleci/ruby:2.4-node</span></div><div class="line"><span class="attr">      - image:</span> <span class="string">circleci/postgres:9.4.12-alpine</span></div><div class="line"><span class="attr">    steps:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">checkout</span></div><div class="line"><span class="attr">      - save_cache:</span> <span class="comment"># Caches dependencies with a cache key</span></div><div class="line">      <span class="comment"># template for an environment variable,</span></div><div class="line">      <span class="comment"># see circleci.com/docs/2.0/caching/</span></div><div class="line"><span class="attr">          key:</span> <span class="string">v1-repo-&#123;&#123;</span> <span class="string">.Environment.CIRCLE_SHA1</span> <span class="string">&#125;&#125;</span></div><div class="line"><span class="attr">          paths:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">~/circleci-demo-workflows</span></div><div class="line"></div><div class="line"><span class="attr">  build2:</span></div><div class="line"><span class="attr">    docker:</span></div><div class="line"><span class="attr">      - image:</span> <span class="string">circleci/ruby:2.4-node</span></div><div class="line"><span class="attr">      - image:</span> <span class="string">circleci/postgres:9.4.12-alpine</span></div><div class="line"><span class="attr">    steps:</span></div><div class="line"><span class="attr">      - restore_cache:</span> <span class="comment"># Restores the cached dependency.</span></div><div class="line"><span class="attr">          key:</span> <span class="string">v1-repo-&#123;&#123;</span> <span class="string">.Environment.CIRCLE_SHA1</span> <span class="string">&#125;&#125;</span></div></pre></td></tr></table></figure><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>工作流定义了一系列的任务和他们的运行顺序。它可以使任务并行，穿行和按计划或者手动控制运行。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="attr">version:</span> <span class="number">2</span></div><div class="line"><span class="attr">jobs:</span></div><div class="line"><span class="attr">  build1:</span></div><div class="line"><span class="attr">    docker:</span></div><div class="line"><span class="attr">      - image:</span> <span class="string">circleci/ruby:2.4-node</span></div><div class="line"><span class="attr">      - image:</span> <span class="string">circleci/postgres:9.4.12-alpine</span></div><div class="line"><span class="attr">    steps:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">checkout</span></div><div class="line"><span class="attr">      - save_cache:</span> <span class="comment"># Caches dependencies with a cache key</span></div><div class="line"><span class="attr">          key:</span> <span class="string">v1-repo-&#123;&#123;</span> <span class="string">.Environment.CIRCLE_SHA1</span> <span class="string">&#125;&#125;</span></div><div class="line"><span class="attr">          paths:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">~/circleci-demo-workflows</span></div><div class="line">      </div><div class="line"><span class="attr">  build2:</span></div><div class="line"><span class="attr">    docker:</span></div><div class="line"><span class="attr">      - image:</span> <span class="string">circleci/ruby:2.4-node</span></div><div class="line"><span class="attr">      - image:</span> <span class="string">circleci/postgres:9.4.12-alpine</span></div><div class="line"><span class="attr">    steps:</span></div><div class="line"><span class="attr">      - restore_cache:</span> <span class="comment"># Restores the cached dependency.</span></div><div class="line"><span class="attr">          key:</span> <span class="string">v1-repo-&#123;&#123;</span> <span class="string">.Environment.CIRCLE_SHA1</span> <span class="string">&#125;&#125;</span></div><div class="line"><span class="attr">      - run:</span></div><div class="line"><span class="attr">          name:</span> <span class="string">Running</span> <span class="string">tests</span></div><div class="line"><span class="attr">          command:</span> <span class="string">make</span> <span class="string">test</span></div><div class="line"><span class="attr">  build3:</span></div><div class="line"><span class="attr">    docker:</span></div><div class="line"><span class="attr">      - image:</span> <span class="string">circleci/ruby:2.4-node</span></div><div class="line"><span class="attr">      - image:</span> <span class="string">circleci/postgres:9.4.12-alpine</span></div><div class="line"><span class="attr">    steps:</span></div><div class="line"><span class="attr">      - restore_cache:</span> <span class="comment"># Restores the cached dependency.</span></div><div class="line"><span class="attr">          key:</span> <span class="string">v1-repo-&#123;&#123;</span> <span class="string">.Environment.CIRCLE_SHA1</span> <span class="string">&#125;&#125;</span></div><div class="line"><span class="attr">      - run:</span></div><div class="line"><span class="attr">          name:</span> <span class="string">Precompile</span> <span class="string">assets</span></div><div class="line"><span class="attr">          command:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rake</span> <span class="attr">assets:precompile</span></div><div class="line"><span class="string">...</span>                          </div><div class="line"><span class="attr">workflows:</span></div><div class="line"><span class="attr">  version:</span> <span class="number">2</span></div><div class="line"><span class="attr">  build_and_test:</span> <span class="comment"># name of your workflow</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">build1</span></div><div class="line"><span class="attr">      - build2:</span></div><div class="line"><span class="attr">        requires:</span></div><div class="line"><span class="bullet">          -</span> <span class="string">build1</span> <span class="comment"># wait for build1 job to complete successfully before starting</span></div><div class="line">          <span class="comment"># see circleci.com/docs/2.0/workflows/ for more examples.</span></div><div class="line"><span class="attr">      - build3:</span></div><div class="line"><span class="attr">        requires:</span></div><div class="line"><span class="bullet">          -</span> <span class="string">build1</span> <span class="comment"># wait for build1 job to complete successfully before starting</span></div><div class="line">          <span class="comment"># run build2 and build3 in parallel to save time.</span></div></pre></td></tr></table></figure><h3 id="工作区域和文件"><a href="#工作区域和文件" class="headerlink" title="工作区域和文件"></a>工作区域和文件</h3><p>Artifacts， Workspaces，Caches的讨论看 <a href="https://circleci.com/blog/persisting-data-in-workflows-when-to-use-caching-artifacts-and-workspaces/" target="_blank" rel="noopener">Persisting Data in Workflows: When to Use Caching, Artifacts, and Workspaces</a></p><p>也可以看看 <a href="https://circleci.com/docs/2.0/jobs-steps/" target="_blank" rel="noopener">Jobs and Steps</a>来查看更多。</p><h1 id="工作流-1"><a href="#工作流-1" class="headerlink" title="工作流"></a><a href="https://circleci.com/docs/2.0/workflows" target="_blank" rel="noopener">工作流</a></h1><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/circleci/wf-header.png" alt=""></p><p>要通过更快的反馈，更短的重运行时间和更有效的资源使用来提高软件开发的速度，请配置工作流程。这个文档描述了工作流程的特性而且提供以下章节的用例：</p><ul><li>概述</li><li>工作流配置案例</li><li>手动控制持久工作流</li><li>有序化一个工作流程</li><li>使用上下文来过滤你的工作流程</li><li>使用工作区来在任务重分享数据</li><li>重运行失败的任务</li><li>故障排除</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>你能做的有：</p><ul><li>通过实时状态反馈来运行和解决任务中的问题</li><li>将需要定期执行的工作流按计划执行</li><li>通过多个并行任务来进行有效的版本测试</li><li>快速部署到多个不同的平台</li></ul><h3 id="平行任务"><a href="#平行任务" class="headerlink" title="平行任务"></a>平行任务</h3><p>在底部添加<code>workflows</code>，通过build_and_test 可看<a href="https://github.com/CircleCI-Public/circleci-demo-workflows/blob/parallel-jobs/.circleci/config.yml" target="_blank" rel="noopener"> Sample Parallel Workflow config</a></p><h3 id="顺序任务"><a href="#顺序任务" class="headerlink" title="顺序任务"></a>顺序任务</h3><p>需要添加<code>require</code>关键字。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">workflows:</span></div><div class="line"><span class="attr">  version:</span> <span class="number">2</span></div><div class="line"><span class="attr">  build-test-and-deploy:</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">build</span></div><div class="line"><span class="attr">      - test1:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">build</span></div><div class="line"><span class="attr">      - test2:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">test1</span></div><div class="line"><span class="attr">      - deploy:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">test2</span></div></pre></td></tr></table></figure></p><h3 id="扇出-扇入工作流示例"><a href="#扇出-扇入工作流示例" class="headerlink" title="扇出/扇入工作流示例"></a>扇出/扇入工作流示例</h3><p>下面视图扇出一组工作流，然后扇入来运行公共的部署任务：<br><a href="https://github.com/CircleCI-Public/circleci-demo-workflows/tree/fan-in-fan-out" target="_blank" rel="noopener">Sample Fan-in/Fan-out Workflow config</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="attr">workflows:</span></div><div class="line"><span class="attr">  version:</span> <span class="number">2</span></div><div class="line"><span class="attr">  build_accept_deploy:</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">build</span></div><div class="line"><span class="attr">      - acceptance_test_1:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">build</span></div><div class="line"><span class="attr">      - acceptance_test_2:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">build</span></div><div class="line"><span class="attr">      - acceptance_test_3:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">build</span></div><div class="line"><span class="attr">      - acceptance_test_4:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">build</span></div><div class="line"><span class="attr">      - deploy:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">acceptance_test_1</span></div><div class="line"><span class="bullet">            -</span> <span class="string">acceptance_test_2</span></div><div class="line"><span class="bullet">            -</span> <span class="string">acceptance_test_3</span></div><div class="line"><span class="bullet">            -</span> <span class="string">acceptance_test_4</span></div></pre></td></tr></table></figure><h3 id="通过手动批准来控制工作流"><a href="#通过手动批准来控制工作流" class="headerlink" title="通过手动批准来控制工作流"></a>通过手动批准来控制工作流</h3><p>工作流可以设置为需要手动批准再进行下一个任务。任何有权利访问代码库的人都可以继续工作流。为了做到这一点，在任务列表中添加<code>type: approval</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="attr">workflows:</span></div><div class="line"><span class="attr">  version:</span> <span class="number">2</span></div><div class="line"><span class="attr">  build-test-and-approval-deploy:</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">build</span>  <span class="comment"># your custom job from your config, that builds your code</span></div><div class="line"><span class="attr">      - test1:</span> <span class="comment"># your custom job; runs test suite 1</span></div><div class="line"><span class="attr">          requires:</span> <span class="comment"># test1 will not run until the `build` job is completed.</span></div><div class="line"><span class="bullet">            -</span> <span class="string">build</span></div><div class="line"><span class="attr">      - test2:</span> <span class="comment"># another custom job; runs test suite 2,</span></div><div class="line"><span class="attr">          requires:</span> <span class="comment"># test2 is dependent on the succes of job `test1`</span></div><div class="line"><span class="bullet">            -</span> <span class="string">test1</span></div><div class="line"><span class="attr">      - hold:</span> <span class="comment"># &lt;&lt;&lt; A job that will require manual approval in the CircleCI web application.</span></div><div class="line"><span class="attr">          type:</span> <span class="string">approval</span> <span class="comment"># &lt;&lt;&lt; This key-value pair will set your workflow to a status of "On Hold"</span></div><div class="line"><span class="attr">          requires:</span> <span class="comment"># We only run the "hold" job when test2 has succeeded</span></div><div class="line"><span class="bullet">            -</span> <span class="string">test2</span></div><div class="line">      <span class="comment"># On approval of the `hold` job, any successive job that requires the `hold` job will run. </span></div><div class="line">      <span class="comment"># In this case, a user is manually triggering the deploy job.</span></div><div class="line"><span class="attr">      - deploy:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">hold</span></div></pre></td></tr></table></figure><p>上例中举例，就是在最后需要手动批准hold才能进行部署任务。</p><p>下面也有一些我们在工作流中需要注意的地方：</p><ul><li><code>approval</code>是仅在<code>workflow</code>下job的一个特殊类型。</li><li><code>hold</code>任务必须确保不再其他任务中重名。<ul><li>这代表着，你的个人定制任务，像<code>build</code>或者<code>test1</code>在上例中不能给<code>type: approval</code>键</li></ul></li><li>任务的名字随意。</li><li>在手动任务之后的任务都需要添加<code>require:</code>来依赖这个手动任务。</li><li>任务按顺序执行，直到碰到了<code>type: approval</code>。</li></ul><p>下面展示一下截图<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/circleci/approval_job.png" alt=""></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/circleci/approval_job_dialog.png" alt=""></p><h2 id="安排工作流程"><a href="#安排工作流程" class="headerlink" title="安排工作流程"></a>安排工作流程</h2><p>手动书写每个分支的任务和流程十分的低效和耗时，所以我们能够在确定不同分支的运行时间。</p><h3 id="在夜晚执行的任务"><a href="#在夜晚执行的任务" class="headerlink" title="在夜晚执行的任务"></a>在夜晚执行的任务</h3><p>默认工作流的触发依赖于每次<code>git push</code>，为了按照计划执行工作流，我们可以添加<code>triggers</code>键来特殊化工作调度。</p><p>下面的例子中，我们将运行一个旨在夜晚12点后运行的工作流。使用POSIX <code>crontab</code>语法指定<code>cron</code>键。<a href="https://www.unix.com/man-page/POSIX/1posix/crontab/" target="_blank" rel="noopener">crontab man page</a>来查看基本语法。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="attr">workflows:</span></div><div class="line"><span class="attr">  version:</span> <span class="number">2</span></div><div class="line"><span class="attr">  commit:</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">test</span></div><div class="line"><span class="bullet">      -</span> <span class="string">deploy</span></div><div class="line"><span class="attr">  nightly:</span></div><div class="line"><span class="attr">    triggers:</span></div><div class="line"><span class="attr">      - schedule:</span></div><div class="line"><span class="attr">          cron:</span> <span class="string">"0 0 * * *"</span></div><div class="line"><span class="attr">          filters:</span></div><div class="line"><span class="attr">            branches:</span></div><div class="line"><span class="attr">              only:</span></div><div class="line"><span class="bullet">                -</span> <span class="string">master</span></div><div class="line"><span class="bullet">                -</span> <span class="string">beta</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">coverage</span></div></pre></td></tr></table></figure><h3 id="制定有效的计划"><a href="#制定有效的计划" class="headerlink" title="制定有效的计划"></a>制定有效的计划</h3><p>一个有效的计划，需要<code>cron</code>键和<code>filter</code>键。<code>cron</code>的键值必须是一个有效的<code>vaild crontab entry</code>键。</p><h3 id="使用任务上下文来分享环境变量"><a href="#使用任务上下文来分享环境变量" class="headerlink" title="使用任务上下文来分享环境变量"></a>使用任务上下文来分享环境变量</h3><p>下面的例子展示了如何使用上下文来在一个工作流的四个平行任务中分享环境变量。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="attr">workflows:</span></div><div class="line"><span class="attr">  version:</span> <span class="number">2</span></div><div class="line"><span class="attr">  build-test-and-deploy:</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">build</span></div><div class="line"><span class="attr">      - test1:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">build</span></div><div class="line"><span class="attr">          context:</span> <span class="string">org-global</span>  </div><div class="line"><span class="attr">      - test2:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">test1</span></div><div class="line"><span class="attr">          context:</span> <span class="string">org-global</span>  </div><div class="line"><span class="attr">      - deploy:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">test2</span></div></pre></td></tr></table></figure><h2 id="分支级别的任务执行"><a href="#分支级别的任务执行" class="headerlink" title="分支级别的任务执行"></a>分支级别的任务执行</h2><p>下面的例子会展示，如何在三个分支配置任务流。工作流会在忽略在任务底下的分支键，如果想在工作流中添加任务级别的分支，需要移除任务级别的分支，转而描述它。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/circleci/branch_level.png" alt=""></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="attr">workflows:</span></div><div class="line"><span class="attr">  version:</span> <span class="number">2</span></div><div class="line"><span class="attr">  dev_stage_pre-prod:</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="attr">      - test_dev:</span></div><div class="line"><span class="attr">          filters:</span>  <span class="comment"># using regex filters requires the entire branch to match</span></div><div class="line"><span class="attr">            branches:</span></div><div class="line"><span class="attr">              only:</span>  <span class="comment"># only branches matching the below regex filters will run</span></div><div class="line"><span class="bullet">                -</span> <span class="string">dev</span></div><div class="line"><span class="bullet">                -</span> <span class="string">/user-.*/</span></div><div class="line"><span class="attr">      - test_stage:</span></div><div class="line"><span class="attr">          filters:</span></div><div class="line"><span class="attr">            branches:</span></div><div class="line"><span class="attr">              only:</span> <span class="string">stage</span></div><div class="line"><span class="attr">      - test_pre-prod:</span></div><div class="line"><span class="attr">          filters:</span></div><div class="line"><span class="attr">            branches:</span></div><div class="line"><span class="attr">              only:</span> <span class="string">/pre-prod(?:-.+)?$/</span></div></pre></td></tr></table></figure><h2 id="执行Git-Tag的工作流"><a href="#执行Git-Tag的工作流" class="headerlink" title="执行Git Tag的工作流"></a>执行Git Tag的工作流</h2><p>circleci并不会主动执行 git tags 分支，除非你定义特定的tags过滤器。如果一个任务直接间接的需要另外一个任务，你必须指定正则表达式来制定任务的tag filter。轻量级和注释的tag都被支持。</p><p>下面的例子展示了两种tag分支方式：</p><ol><li><code>untagged-build</code>为所有分支运行<code>build</code>任务。</li><li><code>tagged-build</code>为所有分支和带<code>v</code>的标签运行<code>build</code>。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">workflows:</span></div><div class="line"><span class="attr">  version:</span> <span class="number">2</span></div><div class="line"><span class="attr">  untagged-build:</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">build</span></div><div class="line"><span class="attr">  tagged-build:</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="attr">      - build:</span></div><div class="line"><span class="attr">          filters:</span></div><div class="line"><span class="attr">            tags:</span></div><div class="line"><span class="attr">              only:</span> <span class="string">/^v.*/</span></div></pre></td></tr></table></figure><p>下面展示的三个例子就是workflow的步骤</p><ul><li>build跑所有分支和有<code>config-test</code>名称的tags。</li><li>test跑所有分支和有<code>config-test</code>名称的tags。</li><li>deploy不跑分支只跑有<code>config-test</code>的任务。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="attr">workflows:</span></div><div class="line"><span class="attr">  version:</span> <span class="number">2</span></div><div class="line"><span class="attr">  build-test-deploy:</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="attr">      - build:</span></div><div class="line"><span class="attr">          filters:</span>  <span class="comment"># required since `test` has tag filters AND requires `build`</span></div><div class="line"><span class="attr">            tags:</span></div><div class="line"><span class="attr">              only:</span> <span class="string">/^config-test.*/</span></div><div class="line"><span class="attr">      - test:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">build</span></div><div class="line"><span class="attr">          filters:</span>  <span class="comment"># required since `deploy` has tag filters AND requires `test`</span></div><div class="line"><span class="attr">            tags:</span></div><div class="line"><span class="attr">              only:</span> <span class="string">/^config-test.*/</span></div><div class="line"><span class="attr">      - deploy:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">test</span></div><div class="line"><span class="attr">          filters:</span></div><div class="line"><span class="attr">            tags:</span></div><div class="line"><span class="attr">              only:</span> <span class="string">/^config-test.*/</span></div><div class="line"><span class="attr">            branches:</span></div><div class="line"><span class="attr">              ignore:</span> <span class="string">/.*/</span></div></pre></td></tr></table></figure><p>需要注意的是，GitHub的分支单词只能承受5MB和少于三个标签。意味着，如果你一次添加多个标签，那么CircleCi也许不会接受他们全部。</p><h2 id="使用工作区来在任务中分享数据"><a href="#使用工作区来在任务中分享数据" class="headerlink" title="使用工作区来在任务中分享数据"></a>使用工作区来在任务中分享数据</h2><p>每个工作流都有一个相关的工作区，能够将文件转换为下游任务的工作流流程。工作区仅用来添加数据的储存。任务可以在工作区中持久化数据。此配置归档数据并在容器外存储中创建新层。下游文件可以通过文件系统的容器访问工作区。附加工作区会根据工作流程中上游作业的顺序下载并解压缩每个层。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/circleci/Diagram-v3-Workspaces.png" alt=""></p><p>使用工作区来传递当前层及下层需要的特殊数据。工作流程的任务运行于多个分支，也许需要将数据分享到工作区中。工作区也可以用于在测试容器中比较数据。</p><p>举个例子，Scala项目一般需要打来的CPU计算来完成build任务。相比之下，Scala测试任务不是CPU密集型的而且可以很好的跨容器并行化。使用一个大的容器来build任务，然后保存编译好的数据到工作区，能够让测试容器中使用到编译好的数据。</p><p>第二个例子就是，一个能编译的项目，使用build好的包，然后保存到工作区。build任务扇出到的分支能够并行的使用打包好的文件。</p><p>为了将一个任务中的数据持久化，并使它能够在其他的任务中使用。我们需要使用<code>persist_to_workspace</code>键。文件和目录中的带有<code>paths</code>的属性使用<code>persist_to_workspace</code>会被上传到工作区中的临时目录中，相对于<code>root</code>键定义的目录。文件和目录在这时上传之后，就可以在相应的子任务中使用。</p><p>配置任务接收存储的数据，需要用到<code>attach_workspace</code>键。下面的例子中的<code>config.yml</code>文件中，定义了下游文件使用了流任务中的两个任务。这里的工作流是顺序的。所以<code>downstream</code>需要等到流文件结束才能开始。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Note that the following stanza uses CircleCI 2.1 to make use of a Reusable Executor</span></div><div class="line"><span class="comment"># This allows defining a docker image to reuse across jobs.</span></div><div class="line"><span class="comment"># visit https://circleci.com/docs/2.0/reusing-config/#authoring-reusable-executors to learn more.</span></div><div class="line"></div><div class="line"><span class="attr">version:</span> <span class="number">2.1</span></div><div class="line"></div><div class="line"><span class="attr">executors:</span></div><div class="line"><span class="attr">  my-executor:</span></div><div class="line"><span class="attr">    docker:</span></div><div class="line"><span class="attr">      - image:</span> <span class="attr">buildpack-deps:jessie</span></div><div class="line"><span class="attr">    working_directory:</span> <span class="string">/tmp</span></div><div class="line"></div><div class="line"><span class="attr">jobs:</span></div><div class="line"><span class="attr">  flow:</span></div><div class="line"><span class="attr">    executor:</span> <span class="string">my-executor</span></div><div class="line"><span class="attr">    steps:</span></div><div class="line"><span class="attr">      - run:</span> <span class="string">mkdir</span> <span class="bullet">-p</span> <span class="string">workspace</span></div><div class="line"><span class="attr">      - run:</span> <span class="string">echo</span> <span class="string">"Hello, world!"</span> <span class="string">&gt; workspace/echo-output</span></div><div class="line"><span class="string">      </span></div><div class="line"><span class="string">      # Persist the specified paths (workspace/echo-output) into the workspace for use in downstream job. </span></div><div class="line"><span class="string"></span><span class="attr">      - persist_to_workspace:</span></div><div class="line">          <span class="comment"># Must be an absolute path, or relative path from working_directory. This is a directory on the container which is </span></div><div class="line">          <span class="comment"># taken to be the root directory of the workspace.</span></div><div class="line"><span class="attr">          root:</span> <span class="string">workspace</span></div><div class="line">          <span class="comment"># Must be relative path from root</span></div><div class="line"><span class="attr">          paths:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">echo-output</span></div><div class="line"></div><div class="line"><span class="attr">  downstream:</span></div><div class="line"><span class="attr">    executor:</span> <span class="string">my-executor</span></div><div class="line"><span class="attr">    steps:</span></div><div class="line"><span class="attr">      - attach_workspace:</span></div><div class="line">          <span class="comment"># Must be absolute path or relative path from working_directory</span></div><div class="line"><span class="attr">          at:</span> <span class="string">/tmp/workspace</span></div><div class="line"></div><div class="line"><span class="attr">      - run:</span> <span class="string">|</span></div><div class="line"><span class="string">          if [[ `cat /tmp/workspace/echo-output` == "Hello, world!" ]]; then</span></div><div class="line"><span class="string">            echo "It worked!";</span></div><div class="line"><span class="string">          else</span></div><div class="line"><span class="string">            echo "Nope!"; exit 1</span></div><div class="line"><span class="string">          fi</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span><span class="attr">workflows:</span></div><div class="line"><span class="attr">  version:</span> <span class="number">2.1</span></div><div class="line"></div><div class="line"><span class="attr">  btd:</span></div><div class="line"><span class="attr">    jobs:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">flow</span></div><div class="line"><span class="attr">      - downstream:</span></div><div class="line"><span class="attr">          requires:</span></div><div class="line"><span class="bullet">            -</span> <span class="string">flow</span></div></pre></td></tr></table></figure><p>可通过<a href="https://circleci.com/blog/persisting-data-in-workflows-when-to-use-caching-artifacts-and-workspaces/" target="_blank" rel="noopener">Persisting Data in Workflows: When to Use Caching, Artifacts, and Workspaces</a>查看更多的关于使用workspaces, caching, and artifacts。</p><h2 id="重运行失败的任务"><a href="#重运行失败的任务" class="headerlink" title="重运行失败的任务"></a>重运行失败的任务</h2><p>当你使用工作流的时候，你能增加你快速响应失败任务的能力。为了重运行工作流中失败的任务。你可以在<strong>Workflows</strong>中选择相应的工作流，选择<strong>Rerun</strong>按钮。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/circleci/rerun-from-failed.png" alt="return"></p><h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><p>这个章节讨论一些工作流中常见的问题。</p><h3 id="工作流没有开始"><a href="#工作流没有开始" class="headerlink" title="工作流没有开始"></a>工作流没有开始</h3><p>如果你创建和修改了工作流的配置，如果你没看见新的任务，很有可能是你的配置文件<code>config.yml</code>出现了问题。</p><p>通常情况下，如果你没看见你的工作流正常触发，配置错误阻止了工作流的启动。作为结论，工作流没有启动任何一个任务。</p><p>在设置工作流程时，您当前必须检查CircleCI应用程序的工作流程页面（而不是作业页面）以查看配置错误。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/circleci/workflow-config-error.png" alt=""></p><h3 id="工作流等待GitHub的状态。"><a href="#工作流等待GitHub的状态。" class="headerlink" title="工作流等待GitHub的状态。"></a>工作流等待GitHub的状态。</h3><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/circleci/github_branches_status.png" alt=""></p><h1 id="配置circleci"><a href="#配置circleci" class="headerlink" title="配置circleci"></a><a href="https://circleci.com/docs/2.0/configuration-reference/" target="_blank" rel="noopener">配置circleci</a></h1><h1 id="CircleCI-镜像"><a href="#CircleCI-镜像" class="headerlink" title="CircleCI 镜像"></a><a href="https://circleci.com/docs/2.0/circleci-images/" target="_blank" rel="noopener">CircleCI 镜像</a></h1><ul><li><a href="https://hub.docker.com/r/circleci/" target="_blank" rel="noopener">https://hub.docker.com/r/circleci/</a></li><li><a href="https://github.com/circleci/circleci-images" target="_blank" rel="noopener">https://github.com/circleci/circleci-images</a></li><li><a href="https://github.com/circleci-public/circleci-dockerfiles" target="_blank" rel="noopener">https://github.com/circleci-public/circleci-dockerfiles</a></li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>最好确定好版本号，不适用last版本。Debian系统需要在尾部添加上<code>-jessie</code>和<code>-stretch</code>。</p><h3 id="使用镜像的便签来标注语言和操作系统"><a href="#使用镜像的便签来标注语言和操作系统" class="headerlink" title="使用镜像的便签来标注语言和操作系统"></a>使用镜像的便签来标注语言和操作系统</h3><p><code>circleci/golang:1.8.6-jessie</code></p><p><strong>注意:</strong> 如果没有固定标签，Docker将会使用<code>latest</code>标签。<code>latest</code>引用的是最有一个稳定版本的镜像。这样的镜像时十分不稳定的，所以最佳时间推荐使用稳定的镜像。</p><h3 id="使用Docker镜像ID将图像固定到固定版本"><a href="#使用Docker镜像ID将图像固定到固定版本" class="headerlink" title="使用Docker镜像ID将图像固定到固定版本"></a>使用Docker镜像ID将图像固定到固定版本</h3><p>每一个Docker都有唯一的ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sha256:df1808e61a9c32d0ec110960fed213ab2339451ca88941e9be01a03adc98396e</div></pre></td></tr></table></figure><p>如何找到最近的镜像的ID</p><ol><li>在CircleCI应用程序中，转到最后使用该镜像的构建中。</li><li>在<strong>Test Summary</strong>栏中，点击<strong>Spin up environment</strong>。</li><li>在日志输出中，找到镜像的摘要。</li><li>将图像ID添加到图像名称，如下所示</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">circleci/ruby@sha256:df1808e61a9c32d0ec110960fed213ab2339451ca88941e9be01a03adc98396e</div></pre></td></tr></table></figure><h2 id="镜像类型"><a href="#镜像类型" class="headerlink" title="镜像类型"></a>镜像类型</h2><p>CircleCi为了便利，提供了两种镜像。语言镜像和服务器镜像。所有的镜像都需要添加<code>circleci</code>用户来作为系统用户。</p><h3 id="镜像语言"><a href="#镜像语言" class="headerlink" title="镜像语言"></a>镜像语言</h3><ul><li>Android</li><li>Clojure</li><li>Elixir</li><li>Go (Golang)</li><li>JRuby</li><li>Node.js</li><li>OpenJDK (Java)</li><li>PHP</li><li>Python</li><li>Ruby</li><li>Rust</li></ul><h3 id="语言镜像变体"><a href="#语言镜像变体" class="headerlink" title="语言镜像变体"></a>语言镜像变体</h3><p>Circleci维持了一些语言变量的变体镜像。要使用这些变种将以下后缀之一添加到图像标记的末尾。</p><ul><li><code>-node</code> 包括用于多语言应用程序的Node.js.</li><li><code>-browsers</code> 包括Chrome，Firefox，Java 8和Geckodriver.</li><li><code>-browsers-legacy</code> 包括Chrome，Firefox，Java 8和PhantomJS.</li><li><code>-node-browsers</code> 结合了<code>-node</code>和<code>-browsers</code>变体.</li><li><code>-node-browsers-legacy</code> 结合了<code>-node</code>和<code>-browsers-legacy</code>变体.</li></ul><h3 id="服务器镜像"><a href="#服务器镜像" class="headerlink" title="服务器镜像"></a>服务器镜像</h3><p>服务镜像是数据库等服务的便利镜像。这些景象应该在语言镜像之后列出，使之成为二级镜像。</p><ul><li><code>buildpack-deps</code></li><li><code>DynamoDB</code></li><li><code>MariaDB</code></li><li><code>MongoDB</code></li><li><code>MySQL</code></li><li><code>PostgreSQL</code></li><li><code>Redis</code></li></ul><h3 id="服务镜像变体"><a href="#服务镜像变体" class="headerlink" title="服务镜像变体"></a>服务镜像变体</h3><p>使用RAM加速需要添加<code>-ram</code>后缀。举例，<code>circleci/postgres:9.5-postgis</code> =&gt; <code>circleci/postgres:9.5-postgis-ram</code>。</p><h2 id="预安装工具"><a href="#预安装工具" class="headerlink" title="预安装工具"></a>预安装工具</h2><p>除了安卓镜像，其他都包括下列预安装工具，通过<code>apt-get</code>安装。</p><ul><li><code>bzip2</code></li><li><code>ca-certificates</code></li><li><code>curl</code></li><li><code>git</code></li><li><code>gnupg</code></li><li><code>gzip</code></li><li><code>locales</code></li><li><code>mercurial</code></li><li><code>net-tools</code></li><li><code>netcat</code></li><li><code>openssh-client</code></li><li><code>parallel</code></li><li><code>sudo</code></li><li><code>tar</code></li><li><code>unzip</code></li><li><code>wget</code></li><li><code>xvfb</code></li><li><code>zip</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是关于前两个星期零零星星看的文章的总结，主要关于 CircleCI 。首先是CircleCI的介绍，然后下一篇文字介绍下部署一个vue项目到gh-pages的步骤。&lt;br&gt;
    
    </summary>
    
      <category term="CircleCI" scheme="https://hddhyq.github.io/categories/CircleCI/"/>
    
    
      <category term="自动化" scheme="https://hddhyq.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="CircleCI" scheme="https://hddhyq.github.io/tags/CircleCI/"/>
    
  </entry>
  
  <entry>
    <title>简单聊下响应式布局</title>
    <link href="https://hddhyq.github.io/2019/01/15/%E7%AE%80%E5%8D%95%E8%81%8A%E4%B8%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>https://hddhyq.github.io/2019/01/15/简单聊下响应式布局/</id>
    <published>2019-01-15T15:39:38.000Z</published>
    <updated>2019-01-18T03:39:17.735Z</updated>
    
    <content type="html"><![CDATA[<p>简单的从响应式布局的viewport介绍到读hexo博客的next主题的源码，来介绍下响应式布局。<br><a id="more"></a></p><h1 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h1><p>谈到响应式，就离不开viewport。</p><p>移动端浏览器在一个通常比屏幕更宽的虚拟“窗口”（视口）中渲染页面，用户从而无须将所有页面都压缩进一个小屏幕里（那样会把很多没有针对移动端进行优化的站点打乱）。用户可以通过平移和缩放来浏览页面的不同区域。</p><h2 id="两种viewport"><a href="#两种viewport" class="headerlink" title="两种viewport"></a>两种viewport</h2><ul><li>布局视口(layout viewport)</li><li>视觉视口(visual viewport)</li></ul><p>想象一下布局视口是一个足够大的而且不会改变尺寸和形状的图片，现在想象你有一个很小的框，你通过这个框来看上面那个足够大的图片。小框周围布满了不透明的材料，通过小框看到的大图就是视觉视口。你可以将小框向后移来观看所有的大图，也可以将小框靠近大图来观看大图的一部分。你也可以改变小框的方向，不过你要知道大图（布局视口）的形状和大小是从来没有改变的。</p><p>视觉视口（visual viewport）是在当前页面中显示屏幕的一部分。用户可能会滚动来改变他所看到的页面的一部分，或者通过缩放来改变视觉视口的尺寸。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/css/mobile_visualviewport.jpg" alt=""></p><p>然而，CSS布局，尤其是百分比宽度，是相对于<strong>布局视口</strong>计算的。布局视口比视觉视口宽的多。</p><p>因此<code>&lt;html&gt;</code>元素最初获取布局视口的宽度，而且你的CSS被解释为宽度比手机宽的多，就相当于上面比喻中小框远离视觉视口的大图。这样可以确保你的页面布局的行为和桌面是一样的。</p><h3 id="不同的浏览器用的默认layoutview的大小是多少呢"><a href="#不同的浏览器用的默认layoutview的大小是多少呢" class="headerlink" title="不同的浏览器用的默认layoutview的大小是多少呢?"></a>不同的浏览器用的默认layoutview的大小是多少呢?</h3><ul><li>Safari iPhone 使用980px</li><li>Opera 使用850px</li><li>Android WebKit 使用800px</li><li>IE 使用974px</li></ul><h3 id="在桌面端viewport"><a href="#在桌面端viewport" class="headerlink" title="在桌面端viewport"></a>在桌面端viewport</h3><p>桌面端有一个有趣的现象，如果我们定义body中的子元素<code>width:100%</code>，那么这100%相对于谁呢？对，相对于html，html的宽度又取决于<code>viewport</code>，<code>viewport</code>的宽度又相当于浏览器窗口的宽度。</p><p>上面的情况在100%zoom的时候显示正常，当我们缩放窗口的时候，<code>viewport</code>小于页面的总宽度。页面本身没有关系，内容现在溢出超过<code>&lt;html&gt;</code>，但是元素属性设置了<code>overflow: visible</code>，这边是超出的内容也会展示出来。</p><p>下例中，蓝色的顶部栏由于设置了<code>width: 100%</code>，所以浏览器会遵循<code>viewport</code>所设置的宽度。这样蓝色的顶部栏并不管现在它太狭窄了。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/css/desktop_htmlbehaviour.jpg" alt=""></p><h2 id="缩放zooming"><a href="#缩放zooming" class="headerlink" title="缩放zooming"></a>缩放zooming</h2><p>两种视口都是用来测量CSS像素，但是显然视觉视口的尺寸是根据缩放改变的（如果你放大，屏幕上的像素就会变少）。如果布局视口没有一直保持不变，那么百分比计算的宽度将会回流和重新计算。</p><h3 id="了解布局视口"><a href="#了解布局视口" class="headerlink" title="了解布局视口"></a>了解布局视口</h3><p>为了了解布局视口，我们需要关注一下页面完全缩小的情况。很多移动浏览器都是在完全缩放的情况下展示页面。这种情况下视觉视口等于布局视口。</p><p>因此布局视口的宽度和高度等于我们在完全缩放模式看到的。即使当用户放大窗口，布局视口也保持不变。</p><p>而且当你旋转手机到水平的时候，布局视口的内容也没有变，依旧是缩放到手机上面。这种情况有会导致一个问题，高度比横向少得多，不过网页开发者一般不关心页面的高度，只关心宽度。</p><p>下面罗列几个布局视口的宽度</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><strong>document. documentElement. clientWidth / Height</strong></td><td>布局视口尺寸</td></tr><tr><td><strong>window.innerWidth/Height</strong></td><td>视觉视口尺寸</td></tr><tr><td><strong>screen.width and screen.height</strong></td><td>屏幕尺寸</td></tr><tr><td><strong>window.pageX/YOffset</strong></td><td>滚动偏移，和视觉视口相对于布局视口的值相同</td></tr><tr><td><strong>document. documentElement. offsetWidth / Height</strong></td><td><code>&lt;html&gt;</code>标签的尺寸</td></tr><tr><td><strong>Media queries</strong></td><td>测量<code>&lt;html&gt;</code>的宽度（width）或者设备的宽度(device-width)。</td></tr></tbody></table><h2 id="viewport-Meta属性"><a href="#viewport-Meta属性" class="headerlink" title="viewport Meta属性"></a>viewport Meta属性</h2><p>这里让我们看一下<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=320&quot;&gt;</code>的意义，这表示调整布局视口的尺寸。为了了解为什么这个属性这么重要，我们需要退后一步讨论。</p><p>假设你正在写一个简单的页面而且你没有设定你的元素的宽度。那么他们就会伸缩到布局视口宽度的100%。大多数浏览器都会将整个页面缩放来显示整个布局视口。像下图所示和缩放效果。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/css/mq_none.jpg" alt=""><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/css/mq_none_zoomed.jpg" alt=""></p><p>现在设置<code>html {width: 320px}</code>的时候，<code>&lt;html&gt;</code>将会收缩，所有的元素都会取320px的100%，但是这种情况只有用户放大页的时候才能得到，并不是初始化的状态。当用户缩小页面的时候，将会有大片的空白区域。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/css/mq_html300.jpg" alt=""><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/blog/css/mq_yes.jpg" alt=""></p><p>当你设置为<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=320&quot;&gt;</code>的时候，初始化也显示正常了。你也可以设置任何你想要的宽度，包括<code>device-width</code>。将会取得屏幕的宽度<code>screen.width</code>（在设备像素中），于是布局视口将会使用这个值。</p><p>不过这里有一个问题，有时真正的<code>screen.width</code>并没有起多大的作用，因为像素树太高了。例如， Nexus One 的屏幕像素是480px，不过谷歌工程师觉得给480px的宽度作为<code>device-width</code>来说太大了。所以他们决定使用缩放到 2/3 ，所以<code>device-width</code>所表达的宽度就是320px。</p><p>最后这里介绍下典型的针对移动端优化的viewport</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 添加用户缩放禁止 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1,maximum-scale=1, minimum-scale=1, user-scalable=no"</span>&gt;</span></div></pre></td></tr></table></figure><p><code>width</code>控制视口的宽度。可以设置width=600这样的固定值，或者device-width这类的特殊值来指导比例为100%时屏幕宽度的CSS像素数值。</p><h2 id="像素并非像素"><a href="#像素并非像素" class="headerlink" title="像素并非像素"></a>像素并非像素</h2><p>许多手机都有物理像素都比页面的布局大得多，所以移动端将会以多个物理像素现已单个CSS像素。意味着<code>initial-scale=1</code>在安卓或者ios手机上，都能显示较为接近的物理尺寸。</p><p>在240dpi及以上的屏幕上，<code>initial-scale=1</code>的页面实际上会被Android WebKit浏览器放大至150%。其中的文字会保持平滑锐利，但是位图图像在全屏模式下就会不尽人意。为了使图片在这些屏幕上变得清晰，web开发者会将图片甚至整个布局设计成最终尺寸的150%（或者200%从而支持像配备retina屏的iPhone那样的像素密度高达320 dpi及以上的设备），然后通过CSS或视口属性缩小。</p><p>默认比例依赖于显示密度。在密度低于200dpi的显示设备上，比例为1.0。在密度介于200及300dpi之间的显示设备上，比例为1.5。对于具有300dpi以上密度的现实设备，比例为/150dpi向下取整。注意再有在视口比例为1时才会应用默认比例。否则，CSS像素与设备像素之间的关系依赖于当前的缩放等级。</p><h1 id="next源码中响应式应用"><a href="#next源码中响应式应用" class="headerlink" title="next源码中响应式应用"></a>next源码中响应式应用</h1><p>hexo中的<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next主题</a>是一个非常热门的blog主题，其中的相关源码是使用stylus书写的。</p><p>首先在文件夹外面定义了尺寸，这部分尺寸定义在需要修改样式的地方会进行修改。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">mobile-smallest</span><span class="params">()</span></span> &#123;</div><div class="line">  @media (<span class="attribute">max-width</span>: <span class="number">413px</span>) &#123;</div><div class="line">    &#123;block&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">mobile-small</span><span class="params">()</span></span> &#123;</div><div class="line">  @media (<span class="attribute">max-width</span>: <span class="number">567px</span>) &#123;</div><div class="line">    &#123;block&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">mobile</span><span class="params">()</span></span> &#123;</div><div class="line">  @media (<span class="attribute">max-width</span>: <span class="number">767px</span>) &#123;</div><div class="line">    &#123;block&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">tablet</span><span class="params">()</span></span> &#123;</div><div class="line">  @media (<span class="attribute">min-width</span>: <span class="number">768px</span>) and (max-width: <span class="number">991px</span>) &#123;</div><div class="line">    &#123;block&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">desktop</span><span class="params">()</span></span> &#123;</div><div class="line">  @media (<span class="attribute">min-width</span>: <span class="number">992px</span>) &#123;</div><div class="line">    &#123;block&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">desktop-large</span><span class="params">()</span></span> &#123;</div><div class="line">  @media (<span class="attribute">min-width</span>: <span class="number">1600px</span>) &#123;</div><div class="line">    &#123;block&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>博客的左侧的页面导航在小于767的时候会隐藏，在大于767px的时候会在左上显示。这里展示部分代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.site-nav-toggle</span> &#123;</div><div class="line">  <span class="attribute">display</span>: none;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</div><div class="line">  +mobile() &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="selector-tag">button</span> &#123;</div><div class="line">    <span class="attribute">margin-top</span>: <span class="number">2px</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">9px</span> <span class="number">10px</span>;</div><div class="line">    <span class="attribute">background</span>: transparent;</div><div class="line">    <span class="attribute">border</span>: none;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.site-nav</span> &#123;</div><div class="line">  +mobile() &#123;</div><div class="line">    <span class="attribute">display</span>: none;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> -<span class="number">10px</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</div><div class="line">    <span class="attribute">clear</span>: both;</div><div class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="variable">$gray</span>-lighter;</div><div class="line">  &#125;</div><div class="line">  +tablet() &#123; <span class="attribute">display</span>: block !important; &#125;</div><div class="line">  +desktop() &#123; <span class="attribute">display</span>: block !important; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后放下layout的布局stylus：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.header</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$main</span>-desktop;</div><div class="line"></div><div class="line">  +tablet() &#123;</div><div class="line">    <span class="attribute">width</span>: auto;</div><div class="line">  &#125;</div><div class="line">  +mobile() &#123;</div><div class="line">    <span class="attribute">width</span>: auto;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.header-inner</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">240px</span>;</div><div class="line">  <span class="attribute">background</span>: white;</div><div class="line">  <span class="attribute">box-shadow</span>: <span class="variable">$box</span>-shadow-inner;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="variable">$border</span>-radius-inner;</div><div class="line"></div><div class="line">  +desktop-large() &#123;</div><div class="line">    <span class="selector-class">.container</span> &amp; &#123; <span class="attribute">width</span>: <span class="number">240px</span>; &#125;</div><div class="line">  &#125;</div><div class="line">  +tablet() &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">width</span>: auto;</div><div class="line">    <span class="attribute">border-radius</span>: initial;</div><div class="line">  &#125;</div><div class="line">  +mobile() &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">width</span>: auto;</div><div class="line">    <span class="attribute">border-radius</span>: initial;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.main</span> &#123;</div><div class="line">  clearfix();</div><div class="line">  +tablet() &#123;</div><div class="line">    <span class="attribute">padding-bottom</span>: <span class="number">100px</span>;</div><div class="line">  &#125;</div><div class="line">  +mobile() &#123;</div><div class="line">    <span class="attribute">padding-bottom</span>: <span class="number">100px</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.container</span> <span class="selector-class">.main-inner</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$main</span>-desktop;</div><div class="line"></div><div class="line">  +tablet() &#123;</div><div class="line">    <span class="attribute">width</span>: auto;</div><div class="line">  &#125;</div><div class="line">  +mobile() &#123;</div><div class="line">    <span class="attribute">width</span>: auto;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content-wrap</span> &#123;</div><div class="line">  <span class="attribute">float</span>: right;</div><div class="line">  <span class="attribute">box-sizing</span>: border-box;</div><div class="line">  <span class="attribute">padding</span>: <span class="variable">$content</span>-desktop-padding;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$content</span>-desktop;</div><div class="line">  <span class="attribute">background</span>: white;</div><div class="line">  <span class="attribute">min-height</span>: <span class="number">700px</span>;</div><div class="line">  <span class="attribute">box-shadow</span>: <span class="variable">$box</span>-shadow-inner;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="variable">$border</span>-radius-inner;</div><div class="line"></div><div class="line">  +tablet() &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">border-radius</span>: initial;</div><div class="line">  &#125;</div><div class="line">  +mobile() &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">min-height</span>: auto;</div><div class="line">    <span class="attribute">border-radius</span>: initial;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.sidebar</span> &#123;</div><div class="line">  <span class="attribute">position</span>: static;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">  <span class="attribute">margin-top</span>: <span class="number">300px</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$sidebar</span>-desktop;</div><div class="line">  <span class="attribute">background</span>: <span class="variable">$body</span>-bg-color;</div><div class="line">  <span class="attribute">box-shadow</span>: none;</div><div class="line"></div><div class="line">  +tablet() &#123;</div><div class="line">    <span class="attribute">display</span>: none;</div><div class="line">  &#125;</div><div class="line">  +mobile() &#123;</div><div class="line">    <span class="attribute">display</span>: none;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.sidebar-toggle</span> &#123; <span class="attribute">display</span>: none; &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="selector-class">.footer-inner</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$main</span>-desktop;</div><div class="line">  <span class="attribute">padding-left</span>: <span class="number">260px</span>;</div><div class="line"></div><div class="line">  +tablet() &#123;</div><div class="line">    <span class="attribute">width</span>: auto;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">0</span> !important;</div><div class="line">    <span class="attribute">padding-right</span>: <span class="number">0</span> !important;</div><div class="line">  &#125;</div><div class="line">  +mobile() &#123;</div><div class="line">    <span class="attribute">width</span>: auto;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">0</span> !important;</div><div class="line">    <span class="attribute">padding-right</span>: <span class="number">0</span> !important;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="selector-class">.sidebar-position-right</span> &#123;</div><div class="line">  <span class="selector-class">.header-inner</span> &#123; <span class="attribute">right</span>: <span class="number">0</span>; &#125;</div><div class="line">  <span class="selector-class">.content-wrap</span> &#123; <span class="attribute">float</span>: left; &#125;</div><div class="line">  <span class="selector-class">.sidebar</span> &#123; <span class="attribute">float</span>: right; &#125;</div><div class="line"></div><div class="line">  <span class="selector-class">.footer-inner</span> &#123;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding-right</span>: <span class="number">260px</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>因为blog的主要受众还是网页端，所以默认尺寸的填写时桌面端，再根据媒体查询开始往小尺寸开始。我看网上有说，页面优先从小尺寸开始写，这样比较适合响应式。不过我觉得应该根据页面的主要受众，来决定是优先移动端还是桌面端。太复杂的页面应该也不用写响应式，应该根据桌面端和移动端单独设计。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="https://www.quirksmode.org/mobile/viewports.html" target="_blank" rel="noopener">A Tale of Two Viewports</a></li><li><a href="https://www.quirksmode.org/mobile/viewports2.html" target="_blank" rel="noopener">A Tale of Two Viewports</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag" target="_blank" rel="noopener">在移动浏览器中使用viewport元标签控制布局</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media" target="_blank" rel="noopener">@media</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的从响应式布局的viewport介绍到读hexo博客的next主题的源码，来介绍下响应式布局。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="https://hddhyq.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://hddhyq.github.io/tags/css/"/>
    
      <category term="mediaQuery" scheme="https://hddhyq.github.io/tags/mediaQuery/"/>
    
      <category term="viewport" scheme="https://hddhyq.github.io/tags/viewport/"/>
    
  </entry>
  
  <entry>
    <title>了解MV*模式</title>
    <link href="https://hddhyq.github.io/2018/12/23/%E4%BA%86%E8%A7%A3MV-%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hddhyq.github.io/2018/12/23/了解MV-模式/</id>
    <published>2018-12-23T10:58:03.000Z</published>
    <updated>2018-12-23T16:01:16.680Z</updated>
    
    <content type="html"><![CDATA[<p>找了和看了许多关于MVC、MVP、MVVM的资料，趁着周末同样是做一下总结。<br><a id="more"></a></p><h1 id="MV-需要解决的问题"><a href="#MV-需要解决的问题" class="headerlink" title="MV*需要解决的问题"></a>MV*需要解决的问题</h1><p>在传统的GUI程序中，图形界面展示数据和信息，用户的输入行为会触发一些应用逻辑（application logic）可能会触发一些业务逻辑（business logic），业务逻辑会对数据进行相关的变更操作。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/basic_knowledge/gui.png" alt=""></p><p>所以这里需要解决的问题有：View如何同步Model的变更，View和Model之间如何粘合在一起。</p><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>MVC把应用程序分为了view、model层以及controller层， <strong>controller</strong> 的主要职责是 <strong>进行Model和View</strong> 之间的协作（路由、输入预处理等）应用逻辑； <strong>model</strong> 进行处理业务逻辑。它们的如下：</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/basic_knowledge/mvc.png" alt=""></p><h2 id="MVC的调用关系"><a href="#MVC的调用关系" class="headerlink" title="MVC的调用关系"></a>MVC的调用关系</h2><p>一般来说网页上用户的的调用关系如下图所示：</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/basic_knowledge/mvc1.png" alt=""></p><p>用户对View操作后，View捕获到这个操作，会把处理权给Controller；Controller会对来自View的数据进行预处理，决定调用哪一个Model的接口；然后由Model执行相关的业务逻辑；当Model变更之后，会通过 <strong>观察者模式（Observer Pattern）通知View</strong> ； <strong>View通过观察者模式</strong> 收到Model变更的消息后，会向Model请求最新的数据，然后重新更新界面。</p><p>需要注意的点：</p><ol><li><p>View把控制权交给Controller，Controller执行应用程序相关的应用逻辑（对来自View数据进行预处理、决定调用哪个Model的接口等等）。</p></li><li><p>Controller操作Model，Model执行业务逻辑对数据进行处理。Controller不会直接操作View，它并不用了解View。</p></li><li><p>View和Model的同步消息是通过观察者模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。</p></li></ol><h2 id="MVC的优缺点"><a href="#MVC的优缺点" class="headerlink" title="MVC的优缺点"></a>MVC的优缺点</h2><p>优点：</p><ol><li>把业务逻辑和展示逻辑分离，模块化程度高。且当应用逻辑需要变更的时候，不需要变更业务逻辑和展示逻辑，只需要Controller换成另外一个Controller就行了（Swappable Controller）。</li><li>观察者模式可以做到多视图同时更新。</li></ol><p>缺点：</p><ol><li>Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，应用逻辑正确性是无法验证的：Model更新的时候，无法对View的更新操作进行断言。</li><li>View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的。</li></ol><h3 id="MVC在服务端调用"><a href="#MVC在服务端调用" class="headerlink" title="MVC在服务端调用"></a>MVC在服务端调用</h3><p>服务端接收到来自客户端的请求，服务端通过路由规则把这个请求交由给特定的Controller进行处理，Controller执行相应的应用逻辑，对Model进行操作，Model执行业务逻辑以后；然后用数据去渲染特定的模版，返回给客户端。</p><p>相对于MVC中的输入就是Controller：</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/basic_knowledge/mvc2.png" alt=""></p><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>MVP模式将Controller改名为 Presenter，同时改变了通信方向：</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/basic_knowledge/mvp.png" alt=""></p><p>和MVC模式一样，用户对View的操作都会从View交移给Presenter。Presenter会执行相应的应用程序逻辑，并且对Model进行相应的操作；而这时候Model执行完业务逻辑以后，也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，<strong>通过View提供的接口更新界面</strong>。</p><p>关键点：</p><ol><li>View不再负责同步的逻辑，而是由Presenter负责。Presenter中既有应用程序逻辑也有同步逻辑。</li><li>View需要提供操作界面的接口给Presenter进行调用。（关键）</li></ol><p>对比在MVC中，Controller是不能操作View的，View也没有提供相应的接口；而在MVP当中，Presenter可以操作View，View需要提供一组对界面操作的接口给Presenter进行调用；Model仍然通过事件广播自己的变更，但由Presenter监听而不是View。</p><p>这里 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里</p><h2 id="MVP优缺点"><a href="#MVP优缺点" class="headerlink" title="MVP优缺点"></a>MVP优缺点</h2><p>优点：</p><ol><li>便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。</li><li>View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。</li></ol><p>缺点：</p><ol><li>Presenter中除了应用逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。</li></ol><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。ViewModel的含义就是 “Model of View”，视图的模型。它的含义包含了领域模型（Domain Model）和视图的状态（State）。 在图形界面应用程序当中，界面所提供的信息可能不仅仅包含应用程序的领域模型。还可能包含一些领域模型不包含的视图状态，例如电子表格程序上需要显示当前排序的状态是顺序的还是逆序的，而这是Domain Model所不包含的，但也是需要显示的信息。</p><p>可以简单把ViewModel理解为页面上所显示内容的数据抽象，和Domain Model不一样，ViewModel更适合用来描述View。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/basic_knowledge/mvvm.png" alt=""></p><h2 id="MVVM的调用关系"><a href="#MVVM的调用关系" class="headerlink" title="MVVM的调用关系"></a>MVVM的调用关系</h2><p>MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/basic_knowledge/mvvm1.png" alt=""></p><p>也就是说，MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交由框架所提供的Binder进行负责。只需要告诉Binder，View显示的数据对应的是Model哪一部分即可。</p><h2 id="MVVM的优缺点"><a href="#MVVM的优缺点" class="headerlink" title="MVVM的优缺点"></a>MVVM的优缺点</h2><p>优点：</p><ol><li>提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。</li><li>简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。</li></ol><p>缺点：</p><ol><li>对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。</li><li>数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="https://github.com/livoras/blog/issues/11" target="_blank" rel="noopener">https://github.com/livoras/blog/issues/11</a></li><li><a href="https://stackoverflow.com/questions/4415904/business-logic-in-mvc" target="_blank" rel="noopener">https://stackoverflow.com/questions/4415904/business-logic-in-mvc</a></li><li><a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#detailmvcmvp" target="_blank" rel="noopener">https://addyosmani.com/resources/essentialjsdesignpatterns/book/#detailmvcmvp</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;找了和看了许多关于MVC、MVP、MVVM的资料，趁着周末同样是做一下总结。&lt;br&gt;
    
    </summary>
    
      <category term="computer" scheme="https://hddhyq.github.io/categories/computer/"/>
    
    
      <category term="设计模式" scheme="https://hddhyq.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="MVC" scheme="https://hddhyq.github.io/tags/MVC/"/>
    
      <category term="MVP" scheme="https://hddhyq.github.io/tags/MVP/"/>
    
      <category term="MVVM" scheme="https://hddhyq.github.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>Levenshtein distance 编辑距离算法</title>
    <link href="https://hddhyq.github.io/2018/12/08/Levenshtein-distance-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/"/>
    <id>https://hddhyq.github.io/2018/12/08/Levenshtein-distance-编辑距离算法/</id>
    <published>2018-12-08T06:53:12.000Z</published>
    <updated>2018-12-10T15:43:39.447Z</updated>
    
    <content type="html"><![CDATA[<p>这几天再看virtrual-dom，关于两个列表的对比，讲到了Levenshtein distance距离，周末抽空做一下总结。<br><a id="more"></a></p><h1 id="Levenshtein-Distance-介绍"><a href="#Levenshtein-Distance-介绍" class="headerlink" title="Levenshtein Distance 介绍"></a>Levenshtein Distance 介绍</h1><p>在信息理论和计算机科学中，Levenshtein距离是用于测量两个序列之间的差异量（即编辑距离）的度量。两个字符串之间的Levenshtein距离定义为将一个字符串转换为另一个字符串所需的最小编辑数，允许的编辑操作是单个字符的插入，删除或替换。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>‘kitten’和’sitten’之间的 Levenshtein 距离是3，因为一下三个编辑将一个更改为另一个，并且没有办法用少于三个编辑来执行操作。</p><ol><li><code>k</code> itten <code>s</code>itten =&gt; 用’s’代替’k’</li><li>sitt <code>e</code> n sitt <code>i</code> =&gt; 用’i’代替’e’</li><li>sittin  sittin <code>g</code> 在结尾插入’g’</li></ol><h1 id="Levenshtein-Distance-编辑距离-算法详解"><a href="#Levenshtein-Distance-编辑距离-算法详解" class="headerlink" title="Levenshtein Distance (编辑距离) 算法详解"></a>Levenshtein Distance (编辑距离) 算法详解</h1><p>为了得到编辑距离，我们用 beauty 和 batyu 为例：</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/algorithm/ld.png" alt=""></p><p>图示如 <strong>①</strong> 单元位置是两个单词的第一个字符[b]比较得到的值，其的值有它的上方的值(1)、它左方的值(1)和它左上角的值(0)来决定。当单元格所在的行和列所对应的字符相等时，单元格的值为左上方的值。</p><p>否则，单元格左上角的值与其上方和左方的值进行比较，它们之间的最小值+1即是单元格的值。</p><p>图中 <strong>①</strong> 的值由于单元格行和列相等，所以取左上角值0。</p><p>图中 <strong>②</strong> 的值由于单元格行列不相等，(1, 2, 0)取最小为0， 结果+1， 所以 <strong>②</strong> 值为1。</p><p>图示 <strong>③</strong> 的值由于单元格行列不相等，(1, 0, 2)取最小0， 结果+1， 所以 <strong>③</strong> 值为1。</p><h2 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h2><p>这个算法计算的是将s[1…i]转换为t[1…j]（例如将beauty转换为batyu）所需最少的操作数（也就是所谓的编辑距离），这个操作数被保存在d[i,j]（d代表的就是上图所示的二维数组）中。</p><ul><li>在第一行与第一列肯定是正确的，这也很好理解，例如我们将beauty转换为空字符串，我们需要进行的操作数为beauty的长度（所进行的操作为将beauty所有的字符丢弃）。</li><li>我们对字符的可能操作有三种：</li><li>将s[1…n]转换为t[1…m]当然需要将所有的s转换为所有的t，所以，d[n,m]（表格的右下角）就是我们所需的结果。</li><li>如果我们可以使用k个操作数把s[1…i]转换为t[1…j-1]，我们只需要把t[j]加在最后面就能将s[1…i]转换为t[1…j]，操作数为k+1</li><li>如果我们可以使用k个操作数把s[1…i-1]转换为t[1…j]，我们只需要把s[i]从最后删除就可以完成转换，操作数为k+1</li><li>如果我们可以使用k个操作数把s[1…i-1]转换为t[1…j-1]，我们只需要在需要的情况下（s[i] != t[j]）把s[i]替换为t[j]，所需的操作数为k+cost（cost代表是否需要转换，如果s[i]==t[j]，则cost为0，否则为1）。</li></ul><h2 id="可能的改进"><a href="#可能的改进" class="headerlink" title="可能的改进"></a>可能的改进</h2><ul><li>现在的算法复杂度为O(m*n)，可以将其改进为O(m)。因为这个算法只需要上一行和当前行被存储下来就可以了。</li><li>如果需要重现转换步骤，我们可以把每一步的位置和所进行的操作保存下来，进行重现。</li><li>如果我们只需要比较转换步骤是否小于一个特定常数k，那么只计算高宽宽为2k+1的矩形就可以了，这样的话，算法复杂度可简化为O(kl)，l代表参加对比的最短string的长度。</li><li>我们可以对三种操作（添加，删除，替换）给予不同的权值（当前算法均假设为1，我们可以设添加为1，删除为0，替换为2之类的），来细化我们的对比。</li><li>如果我们将第一行的所有cell初始化为0，则此算法可以用作模糊字符查询。我们可以得到最匹配此字符串的字符串的最后一个字符的位置（index number），如果我们需要此字符串的起始位置，我们则需要存储各个操作的步骤，然后通过算法计算出字符串的起始位置。</li><li>这个算法不支持并行计算，在处理超大字符串的时候会无法利用到并行计算的好处。但我们也可以并行的计算cost values（两个相同位置的字符是否相等），然后通过此算法来进行整体计算。</li><li>如果只检查对角线而不是检查整行，并且使用延迟验证（lazy evaluation），此算法的时间复杂度可优化为O(m(1+d))（d代表结果）。这在两个字符串非常相似的情况下可以使对比速度速度大为增加。</li></ul><h2 id="字符串比较代码"><a href="#字符串比较代码" class="headerlink" title="字符串比较代码"></a>字符串比较代码</h2><p>这一部分的代码，参考了 <a href="https://rosettacode.org/wiki/Levenshtein_distance#ES5" target="_blank" rel="noopener">https://rosettacode.org/wiki/Levenshtein_distance#ES5</a> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ld = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> t = [], u, i, j, m = a.length, n = b.length;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!m) <span class="keyword">return</span> b;</div><div class="line">  <span class="keyword">if</span> (!n) <span class="keyword">return</span> a;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= m; j++) &#123;</div><div class="line">    t[j] = j;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(t);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (u = [i], j = <span class="number">1</span>; j &lt;= m; j++) &#123;</div><div class="line">      u[j] = a[j - <span class="number">1</span>] === b[i - <span class="number">1</span>] ? t[j - <span class="number">1</span>] : <span class="built_in">Math</span>.min(t[j - <span class="number">1</span>], t[j], u[j - <span class="number">1</span>]) + <span class="number">1</span>  <span class="comment">// Levenshtein Distance 算法核心比较部分。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t = u;</div><div class="line">    <span class="built_in">console</span>.log(t);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> u[m];</div><div class="line">&#125;</div><div class="line"></div><div class="line">[[<span class="string">'beauty'</span>, <span class="string">'batyu'</span>, <span class="number">3</span>],</div><div class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = v[<span class="number">0</span>], b = v[<span class="number">1</span>], t = v[<span class="number">2</span>], d = ld(a, b);</div><div class="line">  <span class="keyword">if</span> (d !== t) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'levenstein("'</span> + a + <span class="string">'","'</span> + b + <span class="string">'") was '</span> + d + <span class="string">' should be '</span> + t);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 打印出来</span></div><div class="line">[ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ]</div><div class="line">[ <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</div><div class="line">[ <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ]</div><div class="line">[ <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> ]</div><div class="line">[ <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span> ]</div><div class="line">[ <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span> ]</div></pre></td></tr></table></figure><h1 id="还原字符串"><a href="#还原字符串" class="headerlink" title="还原字符串"></a>还原字符串</h1><p>上面总结了传统的计算字符串之间的差距，那么当我们怎么能在计算的过程中，记录需要转换的步骤，并且进行还原呢。</p><p>这里我们需要对比较的每一位的步骤有一个了解。</p><p>为了得到编辑距离，我们用 beauty 和 batyu 为例：<br>从上面一节的图中可以看到，<code>&#39;beauty&#39;</code> 转换为 <code>&#39;&#39;</code> ，对一个的第一行的 <code>[1，2，3，4，5，6]</code>，每一个步骤都相对与上一个元素新建一个元素，同理 <code>&#39;&#39;</code> 转换为 <code>&#39;batyu&#39;</code>，每一个值都是相对一上一个元素的删除步骤。</p><p>那么对角线也显而易见就是先相对于替换操作。那么我们现在需要做的就是，记录下相对应的索引和元素以及需要进行的操作，并将其保存为一个对象，每次新增的对象用数组来保存就可以了。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/algorithm/translate.png" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> actionType = &#123;</div><div class="line">  TYPE_REPLACE: <span class="string">'TYPE_REPLACE'</span>,</div><div class="line">  TYPE_NEW: <span class="string">'TYPE_NEW'</span>,</div><div class="line">  TYPE_DELETE: <span class="string">'TYPE_DELETE'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成对象的方法</span></div><div class="line"><span class="keyword">const</span> patchObj = <span class="function">(<span class="params">index, type, item = <span class="string">''</span></span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    index,</div><div class="line">    type,</div><div class="line">    item</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面是compare方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * @param &#123; array &#125; r 替换操作 replace</span></div><div class="line"><span class="comment"> * @param &#123; array &#125; n 新建操作 new</span></div><div class="line"><span class="comment"> * @param &#123; array &#125; d 删除操作 delete</span></div><div class="line"><span class="comment"> * @param &#123; number &#125; i 需要转换元素的 index</span></div><div class="line"><span class="comment"> * @param &#123; number &#125; j 需要删除元素的 index</span></div><div class="line"><span class="comment"> * @param &#123; string &#125; b 比较字符串</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> compare = <span class="function">(<span class="params">r, n, d, i, j, b</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> min = <span class="built_in">Math</span>.min(r.length, n.length, d.length);</div><div class="line"></div><div class="line">  <span class="keyword">switch</span> (min) &#123;</div><div class="line">    <span class="keyword">case</span> r.length:</div><div class="line">      <span class="keyword">return</span> [...r, patchObj(i, actionType.TYPE_REPLACE, b[i])];</div><div class="line">    <span class="keyword">case</span> n.length:</div><div class="line">      <span class="keyword">return</span> [...n, patchObj(i, actionType.TYPE_NEW, b[i])];</div><div class="line">    <span class="keyword">case</span> d.length:</div><div class="line">      <span class="keyword">return</span> [...d, patchObj(j, actionType.TYPE_DELETE)];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面需要注意的是，我们一组保存了多个数组对象，不要对原数组进行操作，每一次操作我们都需要拷贝一个新的数组对象。</p><p>具体的的diff代码参考<a href="https://github.com/hddhyq/Levenshtein-distance/blob/master/diff.js" target="_blank" rel="noopener">diff代码</a></p><p>得到了，patches对象，剩下的我们就需要patch了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> patch = <span class="function">(<span class="params">a, diffs</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> aList = a.split(<span class="string">''</span>);</div><div class="line">  <span class="keyword">let</span> delCount = <span class="number">0</span>; <span class="comment">// 删除之后，后续的index计算需要加上之前删除的数量</span></div><div class="line">  diffs.forEach(<span class="function">(<span class="params">diff</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">switch</span> (diff.type) &#123;</div><div class="line">      <span class="keyword">case</span> actionType.TYPE_DELETE:</div><div class="line">        aList.splice(diff.index - delCount, <span class="number">1</span>);</div><div class="line">        delCount++</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> actionType.TYPE_NEW:</div><div class="line">        aList.splice(diff.index, <span class="number">0</span>, diff.item);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> actionType.TYPE_REPLACE:</div><div class="line">        aList.splice(diff.index, <span class="number">1</span>, diff.item);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// console.log(aList.join(''))</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> aList.join(<span class="string">''</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>具体代码参考<a href="https://github.com/hddhyq/Levenshtein-distance" target="_blank" rel="noopener">代码地址</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.cnblogs.com/zhoug2020/p/4224866.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhoug2020/p/4224866.html</a></li><li><a href="https://rosettacode.org/wiki/Levenshtein_distance#ES5" target="_blank" rel="noopener">https://rosettacode.org/wiki/Levenshtein_distance#ES5</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天再看virtrual-dom，关于两个列表的对比，讲到了Levenshtein distance距离，周末抽空做一下总结。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hddhyq.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://hddhyq.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="vitrual-dom" scheme="https://hddhyq.github.io/tags/vitrual-dom/"/>
    
  </entry>
  
  <entry>
    <title>css世界之层叠规则</title>
    <link href="https://hddhyq.github.io/2018/10/02/css%E4%B8%96%E7%95%8C%E4%B9%8B%E5%B1%82%E5%8F%A0%E8%A7%84%E5%88%99/"/>
    <id>https://hddhyq.github.io/2018/10/02/css世界之层叠规则/</id>
    <published>2018-10-02T09:06:46.000Z</published>
    <updated>2018-12-09T14:15:17.136Z</updated>
    
    <content type="html"><![CDATA[<p>这是关于css世界我总结的最后一篇。层叠规则<br><a id="more"></a></p><h1 id="z-index只是一小部分"><a href="#z-index只是一小部分" class="headerlink" title="z-index只是一小部分"></a>z-index只是一小部分</h1><p>CSS世界中，z-index属性只有和定位元素（position不为static的元素）在一起的时候才有作用，可以是正数也可以是负数。在CSS3中，flex盒子的子元素也可以设置z-index属性。</p><h2 id="理解层叠上下文和层叠水平"><a href="#理解层叠上下文和层叠水平" class="headerlink" title="理解层叠上下文和层叠水平"></a>理解层叠上下文和层叠水平</h2><p>层叠上下文，英文称作stacking context，是HTML中的一个三维概念。</p><ol><li><p>位于最下面的 background/border 特指层叠上下文元素的边框和背景色。每一个层叠顺序规则仅适用于当前层叠上下文元素的小世界。</p></li><li><p>inline 水平盒子指的是包括 inline/inline-block/inline-table 元素的“层叠顺序”，它们都是同等级别的。</p></li><li><p>单纯从层叠水平上看，实际上 <code>z-index:0</code> 和 <code>z-index:auto</code> 是可以看成是一样的。注意这里的措辞—“单纯从层叠水平上看”，实际上，两者在层叠上下文领域有着根本性的差异。</p></li></ol><h3 id="层叠准则"><a href="#层叠准则" class="headerlink" title="层叠准则"></a>层叠准则</h3><ol><li><p>谁大谁上：当具有明显的层叠水平标识的时候，如生效的 z-index 属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</p></li><li><p>后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。</p></li></ol><h3 id="层叠上下文特性"><a href="#层叠上下文特性" class="headerlink" title="层叠上下文特性"></a>层叠上下文特性</h3><ul><li>层叠上下文的层叠水平要比普通元素高。</li><li>层叠上下文可以阻断元素的混合模式。</li><li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。</li><li>每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。</li><li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ul><h3 id="层叠上下文的创建"><a href="#层叠上下文的创建" class="headerlink" title="层叠上下文的创建"></a>层叠上下文的创建</h3><ol><li><p>天生派: 页面根元素天生具有层叠上下文，称之为根层叠上下文。</p></li><li><p>正统派: z-index值为数值的定位元素的传统“层叠上下文”。</p><p> 对于 position 值为 relative/absolute 以及 Firefox/IE 浏览器（不包括 Chrome 浏览器）下含有 <code>position:fixed</code> 声明的定位元素，当其 z-index 值不是 auto 的时候，会创建层叠上下文。需要注意下，当两个相邻div的z-index为auto，将直接比较里面元素的z-index，当两个相邻div的层级都为相同数值的时候，父级的层级“后来居上”。Chrome 等 WebKit 内核浏览器下，<code>position:fixed</code> 元素天然层叠上下文元素，无须 z-index为数值。</p></li><li><p>扩招派: 其他CSS3属性。</p><ul><li>元素为 <code>flex</code> 布局元素（父元素 display:flex|inline-flex），同时 z-index值不是 auto。</li><li>元素的 <code>opacity</code> 值不是 1。</li><li>元素的 <code>transform</code> 值不是 none。</li><li>元素 <code>mix-blend-mode</code> 值不是 normal。</li><li>元素的 <code>filter</code> 值不是 none。</li><li>元素的 <code>isolation</code> 值是 isolate。</li><li>元素的 <code>will-change</code> 属性值为上面 2～6 的任意一个（如 <code>will-change:opacity</code>、<code>will-chang:transform</code> 等）。</li><li>元素的<code>-webkit-overflow-scrolling</code> 设为 <code>touch</code>。</li></ul></li></ol><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/z_index_stack.png" alt=""></p><h3 id="z-index“不犯2”准则"><a href="#z-index“不犯2”准则" class="headerlink" title="z-index“不犯2”准则"></a>z-index“不犯2”准则</h3><p>对于非浮层元素，避免设置z-index值，z-index值没有任何道理需要超过2。</p><ol><li><p>定位元素一旦设置z-index值，就从普通定位元素变成了层叠上下文元素，相互间的层叠顺序就发生了根本的变化，很容易出现设置了巨大的 z-index 值也无法覆盖其他元素的问题。</p></li><li><p>避免 z-index“一山比一山高”的样式混乱问题。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是关于css世界我总结的最后一篇。层叠规则&lt;br&gt;
    
    </summary>
    
      <category term="css世界" scheme="https://hddhyq.github.io/categories/css%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="css" scheme="https://hddhyq.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css世界之内联元素&amp;&amp;流的破坏</title>
    <link href="https://hddhyq.github.io/2018/10/01/css%E4%B8%96%E7%95%8C%E4%B9%8B%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0-%E6%B5%81%E7%9A%84%E7%A0%B4%E5%9D%8F/"/>
    <id>https://hddhyq.github.io/2018/10/01/css世界之内联元素-流的破坏/</id>
    <published>2018-10-01T05:16:11.000Z</published>
    <updated>2018-12-09T14:15:17.136Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分总结了两处，一处是内联元素，其实内联元素这里主要让我重新认识了下vertical-align和line-height。另一处就是关于流的破坏，主要就是介绍了下float和absolute这些属性一些知识点了。最后国庆节快乐哈哈。<br><a id="more"></a></p><h1 id="内联元素与流"><a href="#内联元素与流" class="headerlink" title="内联元素与流"></a>内联元素与流</h1><p>在内联盒子中，涉及到垂直方向的排版或者对齐，都离不开基线。而字母x的下边缘就是我们的基线（baseline）。</p><p><code>vertical-align: middle</code>对齐为字母x的中心，因为各种字体不同，所以不是绝对的垂直居中。内联元素垂直居中是对文字，而非外部的块级元素。</p><p>ex是CSS一个相对单位，指的是小写字母x的高度，就是指<strong>x-height</strong>。</p><h2 id="内联元素的高度-line-height"><a href="#内联元素的高度-line-height" class="headerlink" title="内联元素的高度 line-height"></a>内联元素的高度 line-height</h2><p>对于非替换元素的纯内联元素，其可视高度完全由line-height决定。</p><p>由于上下半间距的存在，与设计师的文字上下边距的计算一般不同，需要我们重新计算下，文字一般偏下，所以文字下边距向上取整，文字上边距向上取整。在有内联替换元素的时候，line-height不能影响替换元素的高度，内联替换元素和内联元素混排的的时候。line-height只能决定行高的最小高度。</p><h3 id="line-height让内联元素“垂直居中”"><a href="#line-height让内联元素“垂直居中”" class="headerlink" title="line-height让内联元素“垂直居中”"></a>line-height让内联元素“垂直居中”</h3><p>要让单行文字垂直居中，其实不用设置height，只需要设置好line-height的高度就好了。</p><p>多行文字居中的话也有办法，嵌套的div，使用inline-block来表示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">120px</span>;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#f0f3f9</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为什么上面的代码能垂直居中呢，全凭内联盒子前面那个宽度为0的“幽灵空白节点”。</p><h2 id="line-height的属性值"><a href="#line-height的属性值" class="headerlink" title="line-height的属性值"></a>line-height的属性值</h2><p><code>line-height: normal</code>是默认值。不同字体下的<code>line-height</code>的属性值normal计算量都是不一样的：</p><table><thead><tr><th>字体</th><th>Chrome</th><th>Firefox</th><th>IE</th></tr></thead><tbody><tr><td>微软雅黑</td><td>1.32</td><td>1.321</td><td>1.32</td></tr><tr><td>宋体</td><td>1.141</td><td>1.142</td><td>1.141</td></tr></tbody></table><p>line-height有三种计算方式：</p><ol><li><p>数值。如<code>line-height: 1.5</code>，与当前font-size相乘后的值。</p></li><li><p>百分比值。如<code>line-height: 150%</code>，与当前font-size相乘后的值。</p></li><li><p>长度值。如<code>line-height:21px</code>或者<code>者 line-height:1.5em</code>。</p></li></ol><p>使用数值的计算，和其他两种方式在继承方面有所不同。使用数值的话，那么所有的子元素继承的都是这个值；使用百分比值或者长度值作为属性值，所有<br>的子元素继承的是最终的计算值。</p><p>这里推荐的继承设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">input</span>, <span class="selector-tag">button</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: inherit;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="内联元素line-height的“大值特性”"><a href="#内联元素line-height的“大值特性”" class="headerlink" title="内联元素line-height的“大值特性”"></a>内联元素line-height的“大值特性”</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">96px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">span</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 另一个 */</span></div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">span</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">96px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一个子元素的行高是20px，一个是96px，假如一行文字，.box元素的高度是多少。答案是都是96px。</p><p>原因是，里层96px直接撑开，外层96px，“幽灵空白节点”继承96px，最终撑开。设置独立的<code>inline-block</code>避免“幽灵空白节点”影响。</p><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><p>首先要知道，line-height的高度并不是元素的最终高度。</p><p>vertical-align分为下面四大类：</p><ul><li><p>线类，如baseline、top、middle、bottom。</p></li><li><p>文本类，如text-top、text-bottom。</p></li><li><p>上标下标类，如sub、super。</p></li><li><p>数值百分比。如20px、2em、20%等。</p></li></ul><p>默认是baseline，如果设置10px这样，就会往baseline往上偏移10px。负值设置则是往下偏移。</p><h3 id="vertical-align作用的前提"><a href="#vertical-align作用的前提" class="headerlink" title="vertical-align作用的前提"></a>vertical-align作用的前提</h3><p>verticl-align作用的前提是，只能应用于内联元素以及display值为table-cell的元素。</p><p>这里举一个图片的vertical-align没有效果的例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 无效果 */</span></div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">128px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">96px</span>;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 设置line-height */</span></div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">128px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">128px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">96px</span>;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="vertical-align和line-height"><a href="#vertical-align和line-height" class="headerlink" title="vertical-align和line-height"></a>vertical-align和line-height</h3><p>阐述一下容器高度不等于行高的例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">32px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">span</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为“幽灵空白节点”的字体大小不等于span，所以字号不一样的参差位移导致的。如果在父元素设置好字体大小和子元素一样就不会有这样的情况啦。</p><p>图片底部存在间隙也是“幽灵空白节点”、line-height和vertical-align共同导致的。解决方法：</p><ol><li><p>图片块状化。</p></li><li><p>容器line-height足够小。</p></li><li><p>容器font-size足够小。</p></li><li><p>图片设置其他vertical-align属性值。</p></li></ol><p>关于图片的<code>margin-top: -200</code>无效这样的效果，原因是“幽灵空白节点”因为默认的<code>vertical-align: baseline</code>固定死在父级容器内。</p><h3 id="vertical-align线性类属性值"><a href="#vertical-align线性类属性值" class="headerlink" title="vertical-align线性类属性值"></a>vertical-align线性类属性值</h3><h4 id="inline-block与baseline"><a href="#inline-block与baseline" class="headerlink" title="inline-block与baseline"></a>inline-block与baseline</h4><p>vertical-align 属性的默认值 baseline 在文本之类的内联元素那里就是字符 x 的下边缘，对于替换元素则是替换元素的下边缘。但是，如果是 inline-block 元素，则规则要复杂了：一个 inline-block 元素，如果里面没有内联元素，或者 overflow 不是 visible，则该元素的基线就是其 margin 底边缘；否则其基线就是元素里面最后一行内联元素的基线。</p><p>inline-block和baseline的利用，删除icon，<code>&lt;i class=&quot;icon-delete&quot;&gt;删除&lt;/i&gt;</code>和<code>&lt;i class=&quot;icon-delete&quot;&gt;&lt;/i&gt;</code>这里面一个有文字，一个没文字,由于有文字的一般设置为<code>overflow：hidden</code>但是他们的元素基线都是margin底边缘。下面是小技巧，将inline-block和文字对齐。</p><ol><li><p>图标高度和行高一样。一般设定一个固定的宽高。</p></li><li><p>图标标签里面永远有字符。可以借助::before或者::after伪元素生成一个空格字符串。</p></li><li><p>图标CSS不使用<code>overflow: hidden</code>保证基线为里面字符的基线，但是要让里面潜在的字符不可见。</p></li></ol><h1 id="流的破坏与保护"><a href="#流的破坏与保护" class="headerlink" title="流的破坏与保护"></a>流的破坏与保护</h1><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>float的特性：</p><ul><li>包裹性。</li><li>块状化并格式化上下文。</li><li>破坏文档流。</li><li>没有任何margin合并。</li></ul><p>元素设置float，会让父元素坍塌。使用浮动元素的时候，最好采用采用一些手段干净地清除浮动带来的影响。</p><h3 id="float的克星clear"><a href="#float的克星clear" class="headerlink" title="float的克星clear"></a>float的克星clear</h3><p>语法如下：</p><p>clear: none | left | right | both</p><p>clear的官方解释是“元素盒子的边不能和前面的浮动元素相邻”。</p><ul><li>none: 默认值，左右浮动都有。</li><li>left: 左侧康浮动。</li><li>right: 右侧抗浮动。</li><li>both: 两侧抗浮动。</li></ul><p>一般使用，<code>clear: both</code>。<code>clear: both</code>的本质是让自己不和float元素在一行显示，并不是真正意义上的清除浮动。</p><ol><li><p>如果<code>clear: both</code>元素前面的元素就是float元素，则<code>margin-top</code>负值即使设置-9999px也没有效果。</p></li><li><p><code>clear: both</code> 后面的元素一九可能发生文字环绕的现象。</p></li></ol><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC全称<strong>block formatting context</strong>，中文是“块级格式化上下文”。与之对应的还有IFC，“内联格式化上下文”。</p><p>触发BFC的条件：</p><ul><li><code>&lt;html&gt;</code>根元素。</li><li>float的值不为none。</li><li>overflow的值auto、scroll或hidden。</li><li>display的值<code>table-cell</code>、<code>table-caption</code>和<code>inline-block</code>中任何一个。</li><li>position的值不为relative和static。</li></ul><p>BFC特点是及最重要用途是，实现更健壮、更智能的自适应布局。而不仅仅是去margin和清除float影响。</p><p>BFC的表现规则是，具有BFC特性的元素的子元素不会受外部元素影响，也不会影响外部元素。</p><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>最适合产生BFC的属性就是<code>overflow: hidden</code>。当子元素内容超出容器高度限制的时候，剪裁的边界是<code>border box</code>的内边缘，而非<code>padding box</code>的内边缘。</p><p>介绍下overflow属性经典的不兼容问题。在chrome浏览器下，如果浏览器能滚动（假设是垂直滚动），则<code>padding-bottom</code>也算在滚动尺寸内，IE和Firefox浏览器忽略<code>padding-bottom</code>。</p><h3 id="overflow-x和overflow-y"><a href="#overflow-x和overflow-y" class="headerlink" title="overflow-x和overflow-y"></a>overflow-x和overflow-y</h3><ul><li>visible：默认值。</li><li>hidden：剪裁。</li><li>scroll：滚动条区域一直在。</li><li>auto：不足以滚动时没有滚动条，可以滚动时滚动条出现。</li></ul><p>关于overflow-x和overflow-y的设置，如果一个值设置visible而另一个值设置为scroll、auto和hidden，则visible会当成auto来解析。但是scroll、auto和hidden可以共存。</p><p>PC端的默认滚动条来自<code>&lt;html&gt;</code>，而不是<code>&lt;body&gt;</code>标签，移动端就不是这样啦。</p><p>PC端滚动条会占用容器的可用宽度和高度。移动端滚动条一般是悬浮的就不会。</p><h3 id="overflow与锚点定位"><a href="#overflow与锚点定位" class="headerlink" title="overflow与锚点定位"></a>overflow与锚点定位</h3><p>下面两种情况可以触发锚点定位:</p><h3 id="锚点定位行为触发条件"><a href="#锚点定位行为触发条件" class="headerlink" title="锚点定位行为触发条件"></a>锚点定位行为触发条件</h3><ol><li><p>URL地址中的锚链与锚点元素对应并有交互行为。</p></li><li><p>可focus的锚点元素处于focus状态。</p></li></ol><h3 id="锚点定位作用的本质"><a href="#锚点定位作用的本质" class="headerlink" title="锚点定位作用的本质"></a>锚点定位作用的本质</h3><p>锚点定位作用的发生，本质上是通过改变容器滚动高度或者宽度来实现的。</p><p>锚点定位可以发生在普通元素，而且定位行为的发生是由内而外的。“由内而外”指的是，普通元素和窗体同时可滚动的时候，会由内而外触发所有可滚动窗体的锚点定位行为。</p><p>设置<code>overflow: hidden</code>的元素也是可以滚动的，只是没有滚动条，如内部的scrollTop依旧可以使用。</p><h2 id="position-absolute"><a href="#position-absolute" class="headerlink" title="position: absolute"></a>position: absolute</h2><p>当一个元素同时拥有absolute和float的时候，float属性没有任何效果。具有块状话，一旦设置了absolute或者fixed，其元素display就变成block。</p><p>关于元素的宽度的详细计算规则：</p><ol><li><p>根元素（很对场景下可以看成<code>&lt;html&gt;</code>）被称为“初始包含块”，其尺寸等于浏览器可视窗口的大小。</p></li><li><p>对于其它元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box边界形成。</p></li><li><p>如果元素position: fixed，则包含块是“初始包含块”。</p></li><li><p>如果元素的position: absolute，则“包含块”由最近的position不为static的祖先元素建立。</p><p> 如果该祖先元素是纯inline元素，则规则略复杂：</p><ul><li>假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包围盒就是内联元素的“包围块”。</li><li>如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范没有明确定义，浏览器自行发挥。</li></ul></li></ol><p>与常规元素相比，absolute绝对定位元素的“包含块”有以下3个差异</p><ol><li>内联元素也可以作为“包含块”所在的元素。</li><li>“包含块”所在的元素不是父级块元素，而是最近position不为static的祖先元素或者根元素。</li><li>边界是padding box而不是content box。</li></ol><p>内联元素一般不做“包含块”。</p><ol><li><p>一般使用absolute绝对定位都适合布局有关，而内联元素主要是图文展示。</p></li><li><p>理解和学习成本高。内联元素的“包含块”不能按照常规块级元素的“包含块”来理解。</p></li><li><p>兼容性问题。无论内联元素是单行还是跨行都存在兼容性问题。单行的兼容性问题存在于“包含块”是一个空的内联元素的时候。</p></li></ol><p>提示信息一行使用absolute定位的时候，利用<code>white-space: nowrap</code>让信息单行显示。</p><h3 id="具有相对特性的无依赖absolute绝对定位"><a href="#具有相对特性的无依赖absolute绝对定位" class="headerlink" title="具有相对特性的无依赖absolute绝对定位"></a>具有相对特性的无依赖absolute绝对定位</h3><p>absolute是非常独立的CSS属性，其样式和行为表现不依赖其他任何CSS属性就可以完成。</p><p>absolute定位效果完全不需要父元素设置position为relative或者其他属性就能实现。这种情况下，子元素也不要设置left/top/right/bottom的属性值。其实这种“无依赖绝对定位”本质上就是“相对定位”，仅仅是不占据CSS流的尺寸空间而已。</p><p>简单的例子</p><ol><li><p>图标的的定位</p></li><li><p>超越常规布局的排版</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/absoluteLayout.png" alt=""></p></li><li><p>下拉列表的定位</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/absoluteSelect.png" alt=""></p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.datalist</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.search-result</span> &#123;</div><div class="line">  <span class="attribute">display</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-class">.search-result</span> &#123;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虽然“无依赖绝对定位”好处多多，但建议只用在静态交互效果上，比方说，导航二级菜单的显示与定位。如果是动态呈现的列表，建议还是使用 JavaScript 来计算和定位。</p><h3 id="absolute与overflow"><a href="#absolute与overflow" class="headerlink" title="absolute与overflow"></a>absolute与overflow</h3><p>overflow与absolute元素的裁剪规则用一句话表述就是：绝对定位元素不总是被父级 overflow 属性剪裁，尤其当 overflow 在绝对定位元素及其包含块之间的时候。</p><p>转述就是：如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute元素经行剪裁。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不会剪裁 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"overflow: hidden;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span> <span class="attr">style</span>=<span class="string">"position: absolute;"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"overflow: hidden;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span> <span class="attr">style</span>=<span class="string">"position: absolute;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 会剪裁 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"overflow: hidden; position: relative;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span> <span class="attr">style</span>=<span class="string">"position: absolute;"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"overflow: hidden;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span> <span class="attr">style</span>=<span class="string">"position: absolute;"</span>&gt;</span> <span class="comment">&lt;!-- 剪裁 --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>当元素出现transform属性的时候，近似于添加了“定位元素”。所以需要检查，absolute元素是否会被剪裁，fixed定位失效。</p><h3 id="absolute与clip"><a href="#absolute与clip" class="headerlink" title="absolute与clip"></a>absolute与clip</h3><p>CSS 世界中有些属性或者特性必须和其他属性一起使用才有效，比如clip。</p><p><code>clip: rect(top, right, bottom, left)</code>表示据每个边缘的距离开始剪裁。作用有：</p><ol><li><p>fixed固定定位的剪裁。</p></li><li><p>最佳可访问性隐藏。例如隐藏一些文字之类的。</p></li></ol><p>clip 隐藏仅仅是决定了哪部分是可见的，非可见部分无法响应点击事件等；然后，虽然视觉上隐藏，但是元素的尺寸依然是原本的尺寸，在 IE 浏览器和 Firefox 浏览器下抹掉了不可见区域尺寸对布局的影响，Chrome 浏览器却保留了。</p><h3 id="absolute流体特性"><a href="#absolute流体特性" class="headerlink" title="absolute流体特性"></a>absolute流体特性</h3><p>绝对定位元素在“对立方向同时发生定位的时候”。</p><p>当绝对定位元素处于流体状态的时候，各个盒模型相关属性的解析和普通流体元素都是一模一样的，margin 负值可以让元素的尺寸更大，并且可以使用 margin:auto 让绝对定位元素保持居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.element</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">300px</span>; <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">margin</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="position-relative"><a href="#position-relative" class="headerlink" title="position: relative"></a>position: relative</h2><p>relative的定位有两点值得一提：</p><ul><li>相对定位元素的left/top/right/bottom的百分比计算值是相对包含块计算的，而不是本身。所以如果包含块的高度是auto，那么计算值是0，便宜无效。</li><li>相对元素同时应用对立方向定位值的时候，按照默认文档流，自上而下、从左往右，top<br>、left作用大。</li></ul><h3 id="relative最小化影响原则"><a href="#relative最小化影响原则" class="headerlink" title="relative最小化影响原则"></a>relative最小化影响原则</h3><ol><li>尽量不适用relative，想定位某些元素，首先看能否使用“无依赖的绝对定位”。</li><li>如果场景受限，一定要使用relative，则该relative务必最小化。</li></ol><p>原因有，一个普通元素变成相对定位元素，元素的层叠顺序提高了。“relative 的最小化影响原则”不仅规避了复杂场景可能出现样式问题的隐患，从日后的维护角度讲也更方便。</p><h2 id="position-fixed固定定位"><a href="#position-fixed固定定位" class="headerlink" title="position: fixed固定定位"></a>position: fixed固定定位</h2><p>position:fixed 固定定位元素的“包含块”是根元素，我们可以将其近似看成<code>&lt;html&gt;</code>元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一部分总结了两处，一处是内联元素，其实内联元素这里主要让我重新认识了下vertical-align和line-height。另一处就是关于流的破坏，主要就是介绍了下float和absolute这些属性一些知识点了。最后国庆节快乐哈哈。&lt;br&gt;
    
    </summary>
    
      <category term="css世界" scheme="https://hddhyq.github.io/categories/css%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="css" scheme="https://hddhyq.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css世界之盒子模型</title>
    <link href="https://hddhyq.github.io/2018/09/27/css%E4%B8%96%E7%95%8C%E4%B9%8B%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>https://hddhyq.github.io/2018/09/27/css世界之盒子模型/</id>
    <published>2018-09-27T15:59:15.000Z</published>
    <updated>2018-12-09T15:14:36.537Z</updated>
    
    <content type="html"><![CDATA[<p>这是这个总结系列的第二篇文章，关于content、padding、margin、border的。<br><a id="more"></a></p><h1 id="content"><a href="#content" class="headerlink" title="content"></a>content</h1><h2 id="什么是替换元素"><a href="#什么是替换元素" class="headerlink" title="什么是替换元素"></a>什么是替换元素</h2><p>简单的来说，通过修改某个属性值，呈现的内容就可以被替换的元素就称之为<strong>替换元素</strong>。</p><ol><li><p>内容的外观不受页面的css影响。也就是说样式表现在css作用域之外，如何修改替换元素本身的外观呢。需要利用浏览器提供行的一些样式接口，如：<code>::-ms-check{}</code>，直接修改样式是不起作用的。</p></li><li><p>有自己的尺寸。很多替换元素在没有明确尺寸的时候，其默认尺寸（不包括边框）为300像素×150像素。</p></li><li><p>很多css属性有自己的一套表现方式。比如<code>vertical-align</code>属性，对于非替换内联元素来说，其一般是字符x的下边缘，而对于替换元素来说，一般来说是元素的下边缘。</p></li></ol><h3 id="替换元素的display值"><a href="#替换元素的display值" class="headerlink" title="替换元素的display值"></a>替换元素的display值</h3><p>替换元素都是内联元素，但是它们的display值却是有所不同。</p><table><thead><tr><th>元素</th><th>Chrome</th><th>Firefox</th><th>IE</th></tr></thead><tbody><tr><td><code>&lt;img&gt;</code></td><td>inline</td><td>inline</td><td>inline</td></tr><tr><td><code>&lt;iframe&gt;</code></td><td>inline</td><td>inline</td><td>inline</td></tr><tr><td><code>&lt;video&gt;</code></td><td>inline</td><td>inline</td><td>inline</td></tr><tr><td><code>&lt;select&gt;</code></td><td>inline-block</td><td>inline-block</td><td>inline-block</td></tr><tr><td><code>&lt;input&gt;</code></td><td>inline-block</td><td>inline</td><td>inline-block</td></tr><tr><td><code>range(or)file &lt;input&gt;</code></td><td>inline-block</td><td>inline-block</td><td>inline-block</td></tr><tr><td><code>hidden &lt;input&gt;</code></td><td>none</td><td>none</td><td>none</td></tr><tr><td><code>&lt;button&gt;</code></td><td>inline-block</td><td>inline-block</td><td>inline-block</td></tr><tr><td><code>&lt;video&gt;</code></td><td>inline-block</td><td>inline</td><td>inline-block</td></tr></tbody></table><h3 id="替换元素的尺寸计算规则"><a href="#替换元素的尺寸计算规则" class="headerlink" title="替换元素的尺寸计算规则"></a>替换元素的尺寸计算规则</h3><ol><li><p>固有尺寸。这个固有尺寸指的是替换内容的原本尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。这个宽度和高度的大小就是“固有尺寸”。</p></li><li><p>HTML尺寸。“HTML尺寸”只能通过HTML原生属性改变，这些原生属性包括<code>&lt;img&gt;</code>的width和height属性、<code>&lt;input&gt;</code>的size属性、<code>&lt;textarea&gt;</code>的cols和rows属性等。</p></li><li><p>CSS尺寸特指可以通过CSS的width和height。</p></li></ol><p>css尺寸 &gt; HTML尺寸 &gt; 固有尺寸。即使替换元素设置<code>display: block</code>，尺寸规则仍然和内联状态一样，这也是为什么图片或者其他表单元素设置<code>display:block</code>却没有达到100%容器的原因。</p><p>如果一个图片没有src，那么其将不会有网络请求，这一点可以用在图片懒加载上面。而在Firefox中，这种没有src的img元素将会表现为一个普通的内联元素，所以宽高设置无效，所以需要将其设置为<code>display: inline-block</code>。</p><p>关于图片的width和height设置，影响图片的方式。图片的默认填充方式是fill，也就是说，你说设置的宽度和高度都会被默认填充满，所以尺寸的变化，改变的不是图片的固有尺寸，只是改变了图片填充的外部尺寸。CSS3中，替换元素的适配方式，可以通过<code>object-fit</code>来修改。</p><h3 id="替换元素和非替换元素的区别"><a href="#替换元素和非替换元素的区别" class="headerlink" title="替换元素和非替换元素的区别"></a>替换元素和非替换元素的区别</h3><h4 id="观点1：-替换元素和非替换元素之间只隔了一个src属性。"><a href="#观点1：-替换元素和非替换元素之间只隔了一个src属性。" class="headerlink" title="观点1： 替换元素和非替换元素之间只隔了一个src属性。"></a>观点1： 替换元素和非替换元素之间只隔了一个src属性。</h4><p>这里举了一个小例子，利用到了伪元素的图片生成技术。</p><ul><li><p>不能有src属性（证明观点所在）</p></li><li><p>不能使用content属性生成图片（针对Chrome）</p></li><li><p>需要有alt属性并有值（针对Chrome）</p></li><li><p>Firefox下::before伪元素的content值会被无视，::after不会发生这种问题。</p></li></ul><p>这里有一个展示的链接，<a href="http://demo.cssworld.cn/4/1-2.php" target="_blank" rel="noopener">http://demo.cssworld.cn/4/1-2.php</a> 。这里可以演示图片没加载成功的时候，hover提示图片信息的技术。</p><h4 id="观点2：替换元素和非替换元素之间只隔了一个CSS-content-属性"><a href="#观点2：替换元素和非替换元素之间只隔了一个CSS-content-属性" class="headerlink" title="观点2：替换元素和非替换元素之间只隔了一个CSS content 属性"></a>观点2：替换元素和非替换元素之间只隔了一个CSS content 属性</h4><p>替换元素之可替换的部分是content box，对应css属性是content。所以从理论来说content熟悉决定了是替换元素或者非替换元素。直接添加了content属性的元素我们可以称之为“匿名替换元素”。</p><p>在MDN中对于<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content" target="_blank" rel="noopener">content</a>的介绍中，也直接说明了使用content 属性插入的内容都是匿名的可替换元素。</p><p>关于content的利用，这里放一个<a href="http://demo.cssworld.cn/4/1-9.php" target="_blank" rel="noopener">三个点动态加载</a>以及<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Lists_and_Counters/Using_CSS_counters" target="_blank" rel="noopener">counter()</a>。计数器可以说也主要是生成文档的时候来用一下。最后最后，content能够混合的，也就是像这种形式<code>content: &quot;(&quot; attr(href) &quot;)&quot;</code>。</p><h1 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h1><h2 id="奇怪的首选最小宽度"><a href="#奇怪的首选最小宽度" class="headerlink" title="奇怪的首选最小宽度"></a>奇怪的首选最小宽度</h2><p>关于padding里面有几个点需要注意的，即使设置了<code>box-sizing: border-box</code>，当padding计算值大于width时，width也会无效，最终宽度呈现为padding计算值，内容则表现为“首选最小宽度”。而且加了文字也不会变，一般来说是0吧。</p><h2 id="内联元素的padding"><a href="#内联元素的padding" class="headerlink" title="内联元素的padding"></a>内联元素的padding</h2><p>内联元素的padding，会发生层叠，就是说，对上下元素的原本布局没有任何影响，却发生了层叠。</p><p>css中有很多不影响其他元素布局的层叠现象。如，relative元素的定位、盒阴影box-shadow以及outline等。</p><ol><li><p>纯视觉层叠。不影响外部尺寸，如box-shadow以及outline等。</p></li><li><p>会影响视觉的层叠。inline元素的padding就是这种。</p></li></ol><p>区分的方式也很简单，如果父容器设置为<code>overflow: auto</code>，层叠区域超出父元素的时候，没有滚动条出现，则是纯视觉的；如果有滚动条出现，则会影响尺寸，影响布局。</p><h2 id="内联padding的一点小应用"><a href="#内联padding的一点小应用" class="headerlink" title="内联padding的一点小应用"></a>内联padding的一点小应用</h2><h3 id="利用内联padding实现高度可控的“管道分隔符”"><a href="#利用内联padding实现高度可控的“管道分隔符”" class="headerlink" title="利用内联padding实现高度可控的“管道分隔符”"></a>利用内联padding实现高度可控的“管道分隔符”</h3><p><a href="http://demo.cssworld.cn/4/2-2.php" target="_blank" rel="noopener">查看链接</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> + <span class="selector-tag">a</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">3px</span> <span class="number">1px</span>;</div><div class="line">  <span class="attribute">margin-left</span>: <span class="number">6px</span>;</div><div class="line">  <span class="attribute">border-left</span>: <span class="number">1px</span> solid gray;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/pipe_border.png" alt=""></p><h2 id="padding的百分比值及应用"><a href="#padding的百分比值及应用" class="headerlink" title="padding的百分比值及应用"></a>padding的百分比值及应用</h2><p>块级元素的话，有一个纯css实现宽高5:1的头图， <a href="http://demo.cssworld.cn/4/2-3.php" target="_blank" rel="noopener">效果图</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10%</span> <span class="number">50%</span>;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里在讨论一下内联元素的padding百分比。</p><ul><li>同样的相对宽度计算。</li><li>默认的高度和宽度细节有差异。</li><li>padding会断行。</li></ul><p>内联元素的padding首先计算的是左边，那么左边的长度够了的话，元素就会换行，换行之后，新的padding会形成背景，如果是背景色不是transparent的话，就会根据先来后到的产生层叠现象，而且层叠等级比较高。会产生相应的奇怪的现象，一般的开发过程中，遇到这种情况的概率比较小。</p><p>空白的内联元素的表现也会有不同的表现，因为内联元素前面有一个宽度为0高度自适应的“幽灵空白节点元素”，所以，设置<code>padding: 50%</code>最终的变现为一个长方形，这种现象，在我们知道了“幽灵空白节点元素”的存在就不会显得那么难以理解了。</p><h2 id="padding与图形绘制"><a href="#padding与图形绘制" class="headerlink" title="padding与图形绘制"></a>padding与图形绘制</h2><p>padding属性和background-clip属性配合，可以在有限的标签下实现一些css图形绘制效果。</p><p>不使用伪元素，仅一层标签实现菜单图标。下面是十倍大小模拟。</p><p>双层圆心选中效果也可以直接模拟。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.icon-menu</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">width</span>: <span class="number">140px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">35px</span> <span class="number">0</span>;</div><div class="line">  <span class="attribute">border-top</span>: <span class="number">10px</span> solid;</div><div class="line">  <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid;</div><div class="line">  <span class="attribute">background-color</span>: currentColor;</div><div class="line">  <span class="attribute">background-clip</span>: content-box;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.icon-dot</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">background-color</span>: currentColor;</div><div class="line">  <span class="attribute">background-clip</span>: content-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="http://demo.cssworld.cn/4/2-4.php" target="_blank" rel="noopener">效果图</a></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/menu_dot.png" alt=""></p><h1 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h1><h2 id="元素尺寸的相关概念"><a href="#元素尺寸的相关概念" class="headerlink" title="元素尺寸的相关概念"></a>元素尺寸的相关概念</h2><ul><li><p>元素尺寸：对应jQuery的<code>$().outerWidth()</code>和<code>$().outerHeight()</code>方法，是元素的<strong>border box</strong>尺寸。在原生DOM API中写作offsetWidth和offsetHeight，所以有时也称作“元素偏移尺寸”。</p></li><li><p>元素内部尺寸：对应jQuery的<code>$().innerWidth()</code>和<code>$().innerHeight()</code>，就是元素的<strong>padding box</strong>的尺寸。在原生DOM API中写作clientWidth和clientHeight。</p></li><li><p>元素外部尺寸：对应jQuery的<code>$().outerWidth(true)</code>和<code>$(true).outerHeight(true)</code>，是元素的<strong>margin box</strong>的尺寸。原生DOM API中没有对应的。</p></li></ul><p>当元素的尺寸表现为充分利用可利用空间的时候，margin会影响元素的尺寸。对于普通流体元素，margin只能改变元素水平方向尺寸。对于具有可拉伸的绝对定位元素，则水平和垂直方向都可以。</p><h2 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a>margin合并</h2><p>margin合并的三种场景：</p><ol><li><p>相邻兄弟元素margin合并。</p></li><li><p>父级和第一个、最后一个子元素。</p></li><li><p>空块级元素的margin合并。块级元素为空，上下margin会合并。</p></li></ol><p>margin合并规则，“正正取最大”“正负相加”“负负取最负”。</p><p>margin合并的意义主要是为了文档的展示，即css2的主要内容。<br>v</p><h2 id="margin-auto"><a href="#margin-auto" class="headerlink" title="margin: auto"></a>margin: auto</h2><p>平分规则：</p><ol><li><p>如果一侧定值，一侧为auto，则auto为剩余空间大小。</p></li><li><p>如果两侧均是auto，则平分剩余空间。</p></li></ol><p>这里让某个元素右对齐就可以用，<code>margin-left：auto</code>这个属性啦。</p><p>这里介绍一下水平垂直同时居中的一个方法。容器尺寸固定且，<code>position: relative</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.son</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">margin</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这种格式化的流体布局中，margin的自动分配剩余空间就起作用啦，所以最后会垂直水平居中。</p><h2 id="margin无效情况"><a href="#margin无效情况" class="headerlink" title="margin无效情况"></a>margin无效情况</h2><ol><li><p>display计算值为inline的非替换元素的垂直margin是无效的。对于内联替换元素的垂直margin有效。</p></li><li><p>表格的<tr>和<td>元素设置display值是<code>table-cell</code>或<code>table-row</code>的margin无效。如果计算值是<code>tab-caption</code>、<code>inline-table</code>，可以通过margin控制外边距，甚至::first-letter伪元素也可以解析margin。</td></tr></p></li><li><p>margin合并时候，margin小于合并值设置无效。</p></li><li><p>绝对定位元素非定位方位的margin值“无效”。绝对定位元素无法影响兄弟元素，所以看起来无效。</p></li><li><p>定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。正常流的情况下，margin-top和margin-left有效，而margin-bottom和margin-right则会无效。虽然有，但是影响不到自己，只会影响兄弟元素的定位。</p></li><li><p>float鞭长莫及的margin。<code>float: right</code>和<code>margin-right: 20px</code>这里20px小于元素的宽度的时候，就会无效。</p></li><li><p>内联特性导致的margin无效。</p></li></ol><h1 id="border"><a href="#border" class="headerlink" title="border"></a>border</h1><p>border和padding与margin不同，border-width不支持百分比的数值。border相当于盒子的宽度，包装盒哪里有根据内部容器变大的情况呢。其他诸如outline、box-shadow、text-shadow等都是不支持百分比的数值的。</p><p>border-width还支持若干关键字。thin、medium、thick等。</p><p>border-style有几个点，关于border-style: none为默认值。border-style: double表现规则记录一下：双线宽度永远相等，中间间隔±1。</p><p>借助border也能实现菜单menu啦。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.icon</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">border-top</span>: <span class="number">60px</span> double;</div><div class="line">  <span class="attribute">border-bottom</span>: <span class="number">20px</span> solid;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="border三角形绘制。"><a href="#border三角形绘制。" class="headerlink" title="border三角形绘制。"></a>border三角形绘制。</h2><p>等腰三角形的绘制：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid;</div><div class="line">  <span class="attribute">border-color</span>: <span class="number">#f30</span> transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先我们需要知道border的绘制过程：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">100px</span> solid;</div><div class="line">  <span class="attribute">border-color</span>: <span class="number">#f30</span> <span class="number">#00f</span> <span class="number">#396</span> <span class="number">#0f0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/border_color.png" alt=""> </p><p>所以其他三边透明和宽高为0的等宽三角想也就出来了：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 梯形 */</span></div><div class="line"></div><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">100px</span> solid;</div><div class="line">  <span class="attribute">border-color</span>: <span class="number">#f30</span> transparent transparent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 三角形 */</span></div><div class="line"></div><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">100px</span> solid;</div><div class="line">  <span class="attribute">border-color</span>: <span class="number">#f30</span> transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/border_color_transparent.png" alt=""> <img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/border_single.png" alt=""></p><p>其他一些其他的三角形利用，则是利用两个倾斜度不同的三角形叠加。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是这个总结系列的第二篇文章，关于content、padding、margin、border的。&lt;br&gt;
    
    </summary>
    
      <category term="css世界" scheme="https://hddhyq.github.io/categories/css%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="css" scheme="https://hddhyq.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css世界之流体布局</title>
    <link href="https://hddhyq.github.io/2018/09/23/css%E4%B8%96%E7%95%8C%E4%B9%8B%E6%B5%81%E4%BD%93%E5%B8%83%E5%B1%80/"/>
    <id>https://hddhyq.github.io/2018/09/23/css世界之流体布局/</id>
    <published>2018-09-23T10:23:00.000Z</published>
    <updated>2018-09-24T07:55:41.406Z</updated>
    
    <content type="html"><![CDATA[<p>这将会把看到的css世界里面的知识点提取出来，可能会有5到6篇文章来做总结。</p><p>这是第一篇文章，css世界之流体布局。<br><a id="more"></a></p><h1 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h1><p>想要了解文档流，我们需要关注普通元素默认的布局是怎样的。</p><p>在MDN中<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Normal_Flow" target="_blank" rel="noopener">normal flow</a>章节中有所描述。</p><p>单个元素我们需要关注于它们的盒子模型，首先获取元素的content，然后是它们的padding，最后是border和margin。</p><p>默认来说，块级元素的content是父级元素宽度的100%，高度是元素content的高度。内联元素的高度是content的高度，宽度也是content的宽度。你不能直接设置一个内联元素的高度或者宽度，内联元素的高度仅仅是坐落在块级元素的内容中。如果你想要控制内联元素的高度和宽度，你需要将它们设置为 <code>display: block;</code> 或 <code>display: inline-block;</code></p><p>上面解释了单个元素。如果有多个元素，他们会怎么交互呢？在正常的浏览器布局中，默认来说，块级元素会根据文档的书写方式有关。每一个块级元素将会占据一个新行，他们还会根据所设置的margin值来分离。在英语中，或者其他水平，自上而下的书写的语言中，块级元素会根据垂直布局。</p><p>内联元素的表现方式就有所不同，它们不会在新的一行出现，它们会在同一行一个接一个的排列，直到它们的长度超过父级元素的宽度就会换行。</p><h1 id="width或height作用的具体细节"><a href="#width或height作用的具体细节" class="headerlink" title="width或height作用的具体细节"></a>width或height作用的具体细节</h1><p>由于块级元素的流体特性主要体现在水平上，所以首先讨论的就是宽度。</p><h2 id="width-auto"><a href="#width-auto" class="headerlink" title="width: auto"></a>width: auto</h2><p>width的默认值就是auto。它有以下四种表现：</p><ol><li><p>充分利用可用空间。常见就是<code>&lt;div&gt;&lt;p&gt;</code>元素宽度是100%默认于父级容器的。</p></li><li><p>收缩于包裹。常见于浮动、绝对定位、inline-block元素或table元素。</p></li><li><p>收缩到最小。常见于table-layout为auto的表格中。</p></li><li><p>超出容器限制。上面三种元素都不会使元素超出容器宽度，除非设置了<code>white-space: nowrap</code>。</p></li></ol><p>上述四种宽度情况中，除了第一种是由外部尺寸确定的宽度，其他都是内部尺寸决定的宽度。</p><h3 id="外部尺寸与流体特性"><a href="#外部尺寸与流体特性" class="headerlink" title="外部尺寸与流体特性"></a>外部尺寸与流体特性</h3><ol><li><p>正常流宽度。宽度会自动填充满父级容器。</p></li><li><p>格式化宽度。出现在‘绝对定位模型中’，也就是position为 <strong>absolute</strong> 和 <strong>fixed</strong> 元素中，</p><p> 对于非替换元素，当left/right或者top/bottom对立方位的属性值同时存在的时候，元素的宽度表现为格式化宽度。同样的设置了宽度就会破坏了这种流体性。</p></li></ol><h3 id="内部尺寸与流体特性"><a href="#内部尺寸与流体特性" class="headerlink" title="内部尺寸与流体特性"></a>内部尺寸与流体特性</h3><p>这里我仅仅记录了一个关于包裹性的利用，页面中某个文字内容是动态的，可能是几个字或多很多字，几个字的时候居中显示，多个字的时候居左显示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">text-align</span>: left;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="height-auto"><a href="#height-auto" class="headerlink" title="height: auto"></a>height: auto</h2><p>如果父级元素的高度是100%，那么只要子元素在文档流之中，其百分比值完全被忽略。为什么高度的百分比计算会被忽略呢。在w3c规范中在就给出了答案，如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为 <strong>auto</strong> 。父级容器的高度解释为了auto自然没法与百分比相乘了。</p><p><strong>如何让元素支持height: 100%</strong></p><ol><li><p>设定显式的高度值。给html和body设定100%也是也可以的。</p></li><li><p>使用绝对定位。绝对元素的宽高百分比计算是相对于 <strong>padding box</strong> 计算的，非绝对定位的高度百分比计算则是相对于 <strong>content box</strong> 计算的。</p></li></ol><h1 id="css-min-width-max-width和min-height-max-height"><a href="#css-min-width-max-width和min-height-max-height" class="headerlink" title="css min-width/max-width和min-height/max-height"></a><strong>css</strong> min-width/max-width和min-height/max-height</h1><p>下面简述一下min/max-width/height与width和height的不一样的地方。</p><h2 id="关于初始值"><a href="#关于初始值" class="headerlink" title="关于初始值"></a>关于初始值</h2><p>既然是总结，直接放出来好了，max-*的初始值是none，min-*的初始值是auto。</p><h2 id="覆盖规则"><a href="#覆盖规则" class="headerlink" title="覆盖规则"></a>覆盖规则</h2><p>当max-width小于width设置的时候，即使width加上了<code>!important</code>也没有用，max-width大于width的设置。</p><p>当min-width大于max-width的时候，会以min-width为准则。</p><p>根据覆盖原则，我们可以实现任意高度的展开收起技术。由于设置height为auto无法计算值，过渡和动画效果也无法完成。所以我们可以利用max-height实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.element</span> &#123;</div><div class="line">  <span class="attribute">max-height</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">  <span class="attribute">transition</span>: max-height .<span class="number">25s</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.element</span><span class="selector-class">.active</span> &#123;</div><div class="line">  <span class="attribute">max-height</span>: <span class="number">666px</span>; <span class="comment">/* 一个足够大的最大高度值 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="内联盒模型和幽灵空白节点"><a href="#内联盒模型和幽灵空白节点" class="headerlink" title="内联盒模型和幽灵空白节点"></a>内联盒模型和幽灵空白节点</h1><h2 id="内联盒模型的简易版"><a href="#内联盒模型的简易版" class="headerlink" title="内联盒模型的简易版"></a>内联盒模型的简易版</h2><ol><li><p>内容区域。内容区域指一种围绕文字看不见的盒子，可以理解为em盒。</p></li><li><p>内联盒子。“内联盒子”不会让内容成块显示，而是排成一行。需要注意的是一段单独的文本不一定是“匿名内联盒子”，还有可能是“匿名块级盒子”，主要是看其前后标签是内联还是块级。</p></li><li><p>行框盒子。每一行就是一个行框盒子，每个行框盒子又是一个一个“内联盒子”组成的。</p></li><li><p>包含盒子。又称包含块，包括父级标签。</p></li></ol><h2 id="幽灵空白节点"><a href="#幽灵空白节点" class="headerlink" title="幽灵空白节点"></a>幽灵空白节点</h2><p>“幽灵空白节点”是内联盒子模型的一个非常重要的概念。具体指，在HTML5的文档声明中，内联元素的所有解析盒渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个节点永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但是又确确实实存在。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这将会把看到的css世界里面的知识点提取出来，可能会有5到6篇文章来做总结。&lt;/p&gt;
&lt;p&gt;这是第一篇文章，css世界之流体布局。&lt;br&gt;
    
    </summary>
    
      <category term="css世界" scheme="https://hddhyq.github.io/categories/css%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="css" scheme="https://hddhyq.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>移动端虚拟键盘和滚动穿透小结</title>
    <link href="https://hddhyq.github.io/2018/07/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98%E5%92%8C%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E5%B0%8F%E7%BB%93/"/>
    <id>https://hddhyq.github.io/2018/07/31/移动端虚拟键盘和滚动穿透小结/</id>
    <published>2018-07-31T02:34:12.000Z</published>
    <updated>2018-12-09T14:14:41.198Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下最近遇到的两个小bug，也不算小bug，可能在不同的移动端浏览器表现不同吧。一个是虚拟键盘顶起，一个是滚动穿透问题。<br><a id="more"></a></p><h1 id="虚拟键盘"><a href="#虚拟键盘" class="headerlink" title="虚拟键盘"></a>虚拟键盘</h1><p>首先需要明确的一点是，虚拟键盘的顶起在IOS端和Android端有很大的不同变现。</p><h2 id="监听移动端软键盘弹起和收起"><a href="#监听移动端软键盘弹起和收起" class="headerlink" title="监听移动端软键盘弹起和收起"></a>监听移动端软键盘弹起和收起</h2><h3 id="1-Android端-监听resize"><a href="#1-Android端-监听resize" class="headerlink" title="1. Android端 监听resize"></a>1. <strong>Android端</strong> 监听resize</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> winHeight = $(<span class="built_in">window</span>).height();</div><div class="line"></div><div class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> thisHeight = $(<span class="keyword">this</span>).height();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>( winHeight - thisHeight &gt; <span class="number">140</span>) &#123;</div><div class="line">    <span class="comment">// 键盘弹起，140px是一个预估值，可更改</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 键盘收起</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="2-IOS端-监听input失焦blur"><a href="#2-IOS端-监听input失焦blur" class="headerlink" title="2. IOS端 监听input失焦blur"></a>2. <strong>IOS端</strong> 监听input失焦blur</h3><p>ios中的键盘或者第三方键盘并不会监听到<code>window resize</code>事件，所以不能用<code>resize</code>监听，所以需要通过输入框是否获取焦点来判断。</p><p>在Android中，有一些机型，键盘收起了，输入框仍处于焦点状态，并没有触发<code>focusout</code>事件。</p><p>因为<code>focusin</code>和<code>focusout</code>支持冒泡，对应focus和blur，所以根据需求，我们可以选择相应的事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'focusin'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">　　<span class="comment">//软键盘弹出的事件处理</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'focusout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">　　<span class="comment">//软键盘收起的事件处理</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="input-textarea-contenteditable-quot-true-quot-置底问题"><a href="#input-textarea-contenteditable-quot-true-quot-置底问题" class="headerlink" title="input textarea contenteditable=&quot;true&quot; 置底问题"></a><code>input</code> <code>textarea</code> <code>contenteditable=&quot;true&quot;</code> 置底问题</h2><p>这里也需要了解一下，IOS和Android关于<code>fixed</code>属性的支持是不一样的。</p><h3 id="1-IOS端"><a href="#1-IOS端" class="headerlink" title="1. IOS端"></a>1. IOS端</h3><p>ios中，虚拟键盘顶起来之后，整个页面都会被键盘部分压缩。也就是说页面的高度会变小，并且所有的<code>fixed</code>都会变成<code>absolute</code>。</p><p>也就是说，之前在ios端fixed到底部的<code>input</code>框等可focus元素，会变成<code>absolute</code>定位，并且随着页面能够滑动。</p><h3 id="2-Android端"><a href="#2-Android端" class="headerlink" title="2. Android端"></a>2. Android端</h3><p>android端中，虚拟键盘顶起来之后，<code>fixed</code>属性不会失效，唤起的键盘是覆盖在页面上的，不会压缩页面。</p><h2 id="项目中的bug及一些思考"><a href="#项目中的bug及一些思考" class="headerlink" title="项目中的bug及一些思考"></a>项目中的bug及一些思考</h2><p>在最近的一个项目中，移动端页面布局，因为现在手机的高度不同，简单的背景图并不能放文字了，文字会拉伸，我需要设置一个<code>footer</code>放到底部，这里我最开始考虑的就是用<code>fixed</code>布局到最底部，结果当键盘顶起来的时候，文字也就跟着一起顶上去了，整个页面使用的是<code>overflow: hidden</code>。</p><p>这里就需要监听键盘顶起事件，并执行相应的给元素添加相关css的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oHeight = $(<span class="built_in">document</span>).height();</div><div class="line"><span class="comment">// 监听键盘事件</span></div><div class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> ($(<span class="built_in">document</span>).height() &lt; oHeight) &#123;</div><div class="line">    $(<span class="string">'footer'</span>).addClass(<span class="string">'hide'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    $(<span class="string">'footer'</span>).removeClass(<span class="string">'hide'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>另外，关于底部的输入框顶起的问题，我看了一下手机版微博的解决方案，在Android端，虚拟键盘顶起，应该直接是fixed在底部，在IOS端则是整个添加了一个评论的浮层，总来来说也是一个不错的方案。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/ios_input.jpg" alt=""></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/android_input.jpg" alt=""></p><p>最后介绍一个神奇的东西<code>Element.scrollIntoView()</code>，这个东西能把底部的输入框提高到可视区域，不过经过测试，键盘顶起是需要时间的，我们需要确保，在键盘调起之后，确保元素调用<code>scrollIntoView()</code>。</p><p>下面是我写的一段代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#el'</span>).on(<span class="string">'focus'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#el'</span>).scrollIntoView();</div><div class="line">  &#125;, <span class="number">300</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h1 id="滚动穿透"><a href="#滚动穿透" class="headerlink" title="滚动穿透"></a>滚动穿透</h1><p>在移动端中，滚动穿透问题很常见，处理起来也比较繁琐。下面我还是按照不同的方法进行分类：</p><h2 id="touchmove事件中调用preventDefault"><a href="#touchmove事件中调用preventDefault" class="headerlink" title="touchmove事件中调用preventDefault()"></a>touchmove事件中调用<code>preventDefault()</code></h2><p>这个方法适用于，弹出框内容无需滚动。如果弹出层内部有滚动事件，将会导致，弹出层的滚动事件也无法滚动。</p><h2 id="添加相关的类"><a href="#添加相关的类" class="headerlink" title="添加相关的类"></a>添加相关的类</h2><p>给html上添加一个noscroll的类<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.noscroll</span>,</div><div class="line"><span class="selector-class">.noscroll</span> body</div><div class="line">  <span class="attribute">overflow</span>: hidden</div><div class="line"><span class="selector-class">.noscroll</span> body</div><div class="line">  poition: relative</div></pre></td></tr></table></figure></p><p>缺点：</p><ol><li>html和body的滚动都禁止了，弹出层关闭后，会丢失原有的滚动位置，需要用JS来还原</li><li>有些页面的北京还有能滚的动的效果</li></ol><h2 id="fixed加上js恢复记录位置"><a href="#fixed加上js恢复记录位置" class="headerlink" title="fixed加上js恢复记录位置"></a>fixed加上js恢复记录位置</h2><p>css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span><span class="selector-class">.mask-open</span> &#123;</div><div class="line">  <span class="attribute">position</span>: fixed;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scrollTop = <span class="number">0</span>;</div><div class="line"></div><div class="line">open.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</div><div class="line"></div><div class="line">  <span class="built_in">document</span>.body.classList.add(<span class="string">'mask-open'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">document</span>.body.style.top = -scrollTop + <span class="string">'px'</span>; <span class="comment">// 脱离文档流后回到当前位置</span></div><div class="line"></div><div class="line">  mask.style.display = <span class="string">'block'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">close.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  mask.style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line">  <span class="built_in">document</span>.body.classList.remove(<span class="string">'mask-open'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">document</span>.body.scrollTop = <span class="built_in">document</span>.documentElement.scrollTop = scrollTop <span class="comment">// 滚动到相应位置，确保兼容性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p> 参考</p><ul><li>虚拟键盘<ul><li><a href="https://cloud.tencent.com/developer/article/1004930" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1004930</a></li><li><a href="http://www.cnblogs.com/wangyihong/p/7514304.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangyihong/p/7514304.html</a></li></ul></li><li>滚动穿透<ul><li><a href="https://segmentfault.com/q/1010000002942948" target="_blank" rel="noopener">https://segmentfault.com/q/1010000002942948</a></li><li><a href="https://github.com/pod4g/tool/wiki/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">https://github.com/pod4g/tool/wiki/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98</a> </li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下最近遇到的两个小bug，也不算小bug，可能在不同的移动端浏览器表现不同吧。一个是虚拟键盘顶起，一个是滚动穿透问题。&lt;br&gt;
    
    </summary>
    
      <category term="移动端bug" scheme="https://hddhyq.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AFbug/"/>
    
    
      <category term="移动端" scheme="https://hddhyq.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="bug" scheme="https://hddhyq.github.io/tags/bug/"/>
    
      <category term="兼容性" scheme="https://hddhyq.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>svg简介及svg与canvas对比</title>
    <link href="https://hddhyq.github.io/2018/07/30/svg%E7%AE%80%E4%BB%8B%E5%8F%8Asvg%E4%B8%8Ecanvas%E5%AF%B9%E6%AF%94/"/>
    <id>https://hddhyq.github.io/2018/07/30/svg简介及svg与canvas对比/</id>
    <published>2018-07-30T02:07:05.000Z</published>
    <updated>2018-12-09T14:14:41.196Z</updated>
    
    <content type="html"><![CDATA[<p>SVG(scalable、vector、graphics)是XML语言的一种形式，有点类似XHTML，它可以用来绘制矢量图形。<br><a id="more"></a></p><h1 id="SVG的基本应用"><a href="#SVG的基本应用" class="headerlink" title="SVG的基本应用"></a>SVG的基本应用</h1><p>首先需要记住的是，svg在HTML中的写法是用的XML的语法，所以：</p><ol><li>SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同）</li><li>SVG里的属性值必须用引号引起来，就算是数值也必须这样做。</li></ol><h1 id="svg文件的基本属性"><a href="#svg文件的基本属性" class="headerlink" title="svg文件的基本属性"></a>svg文件的基本属性</h1><h2 id="svg渲染及压缩"><a href="#svg渲染及压缩" class="headerlink" title="svg渲染及压缩"></a>svg渲染及压缩</h2><ul><li>元素的渲染顺序，SVG文件全局有效的规则是“后来居上”，越后面的元素越可见。</li><li>web上的svg文件可以直接展示，或者通过以下几种方法嵌入到HTML文件：<ul><li>HTML是XHTML，并且声明类型为application/xhtml+xml</li><li>HTML是HTML5，并且浏览器支持HTML5，可以直接嵌入SVG</li><li>通过<code>object</code>引入SVG文件。<code>&lt;object data=&quot;image.svg&quot; type=&quot;image/svg+xml&quot; /&gt;</code></li><li>通过<code>iframe</code>引入SVG文件。<code>&lt;iframe src=&quot;image.svg&quot;&gt;&lt;/iframe&gt;</code></li><li>可以使用img元素，但是在低于4.0版本的Firefox中不起作用</li><li>最后SVG可以通过JavaScript动态创建并注入到HTML DOM中</li></ul></li></ul><p>svg有两种文件类型，一个是”.svg”，一个是压缩的”.svgz”。”.svgz”在Firefox不能通过本地的机器加载，微软的IIS服务器对于gzip压缩的SVG文件，在用户代理上也不是很可靠。”.svgz”多用于地图应用等需要大型SVG文件的应用。</p><h2 id="SVG的坐标定位及窗口"><a href="#SVG的坐标定位及窗口" class="headerlink" title="SVG的坐标定位及窗口"></a>SVG的坐标定位及窗口</h2><p>svg的网格布局和canvas是一样的，都是以一个左上角为原点，向下和向右延申的。</p><p>正常情况下，svg的一个像素对应显示屏的一个像素，不过这种情况是可以改变的，我们需要定义<code>viewBox</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span>&gt;</span></div></pre></td></tr></table></figure><p>上面的画板尺寸是<code>200px*200px</code>，画板展示区域是<code>100px*100px</code>，所以<code>100*100</code>的区域会在<code>200*200</code>的画布上展示。</p><h1 id="svg基本形状"><a href="#svg基本形状" class="headerlink" title="svg基本形状"></a>svg基本形状</h1><h2 id="矩形-rect"><a href="#矩形-rect" class="headerlink" title="矩形 rect"></a>矩形 rect</h2><ul><li>x 矩形左上角的x位置</li><li>y 矩形左上角的y位置</li><li>width 矩形的宽度</li><li>height 矩形的高度</li><li>rx 圆角的x方位的半径</li><li>ry 圆角的y方位的半径</li></ul><h2 id="圆形-circle"><a href="#圆形-circle" class="headerlink" title="圆形 circle"></a>圆形 circle</h2><ul><li>r 圆的半径</li><li>cx 圆心的x位置</li><li>cy 圆心的y位置</li></ul><h2 id="椭圆-ellipse"><a href="#椭圆-ellipse" class="headerlink" title="椭圆 ellipse"></a>椭圆 ellipse</h2><ul><li>rx 椭圆的x半径</li><li>ry 椭圆的y半径</li><li>cx 椭圆中心的x位置</li><li>cy 椭圆中心的y位置</li></ul><h2 id="线条-line"><a href="#线条-line" class="headerlink" title="线条 line"></a>线条 line</h2><ul><li>x1 起点的x位置</li><li>y1 起点的y位置</li><li>x2 终点的x位置</li><li>y2 终点的y位置</li></ul><h2 id="折线-polyline"><a href="#折线-polyline" class="headerlink" title="折线 polyline"></a>折线 polyline</h2><p>Polyline是一组连接在一起的直线。因为它可以有很多的点，折线的的所有点位置都放在一个points属性中：</p><p><code>points</code> 点集数列。每个数字用空白、逗号、终止命令符或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。</p><h2 id="多边形-polygon"><a href="#多边形-polygon" class="headerlink" title="多边形 polygon"></a>多边形 polygon</h2><p>polygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。</p><p><code>points</code> 点集数列。每个数字用空白符、逗号、终止命令或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。</p><h1 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h1><p><code>&lt;path&gt;</code>元素是SVG基本形状中最强大的一个，path只需要少量的点就能创建和规划流畅的曲线</p><p>path的形状通过属性<code>&#39;d&#39;</code>定义，属性d的值是一个“命令+参数”的序列。</p><p>每一个命令都用一个关键字母来表示，每一个命令有两种形式。一种是<strong>大写字母</strong>，表示采用绝对定位。另一种是<strong>小写字母</strong>，表示采用相对定位。</p><p>属性<code>d</code>采用的是用户坐标系统，所以不需标明单位。</p><h2 id="直线命令"><a href="#直线命令" class="headerlink" title="直线命令"></a>直线命令</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>M x y (or m dx dy)</td><td>移动画笔坐标</td></tr><tr><td>L x y (or l dx dy)</td><td>L命令将会在当前位置和新位置（L前面画笔所在的点）之间画一条线段</td></tr><tr><td>H x (or h dx)</td><td>标明在x轴移动到的位置</td></tr><tr><td>V y (or v dy)</td><td>标明在y轴移动到的位置</td></tr><tr><td>Z (or z)</td><td>从当前点画一条直线到路径的起点</td></tr></tbody></table><h2 id="曲线命令"><a href="#曲线命令" class="headerlink" title="曲线命令"></a>曲线命令</h2><p>有三个命令：</p><ul><li>三次贝塞尔曲线</li><li>二次贝塞尔曲线</li><li>圆的一部分</li></ul><h3 id="三次贝塞尔曲线"><a href="#三次贝塞尔曲线" class="headerlink" title="三次贝塞尔曲线"></a>三次贝塞尔曲线</h3><p>三次贝塞尔曲线需要定义一个点和两个控制点，所以用C命令创建三次贝塞尔曲线，需要设置三组坐标参数：</p><p><code>C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)</code></p><p>最后一个坐标(x, y)表示的是曲线的终点，另外两个坐标是控制点，(x1, y1)是起点的控制点，(x2, y2)是终点的控制点。</p><p>如何创建平滑的曲线呢？通常情况下，一个点是另一个点的控制点的堆成。这样，你就可以使用一个简写的贝塞尔曲线S:</p><p><code>S x2 y2, x y (or s dx2 dy2, dx dy)</code></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/ShortCut_Cubic_Bezier.png" alt=""></p><h3 id="二次贝塞尔曲线"><a href="#二次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线"></a>二次贝塞尔曲线</h3><p>二次贝塞尔曲线只需要一个控制点。</p><p><code>Q x1 y1, x y (or q dx1 dy1, dx dy)</code></p><p>二次贝塞尔曲线简写<code>T x y (or t dx dy)</code>。</p><h3 id="弧形"><a href="#弧形" class="headerlink" title="弧形"></a>弧形</h3><p><code>A rx ry x-axis-rotation large-arc-flag sweep-flag x y</code></p><p><code>a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy</code></p><p>x轴旋转角度（x轴旋转角度）, large-arc-flag（角度大小） 和sweep-flag（弧线方向）</p><h2 id="Fill和Stroke属性"><a href="#Fill和Stroke属性" class="headerlink" title="Fill和Stroke属性"></a>Fill和Stroke属性</h2><p>这两个属性，可以用直接的css颜色，还有一个就是直接添加颜色的透明度。属性fill-opacity控制填充色的不透明度，属性stroke-opacity控制描边的不透明度。</p><h3 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h3><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/SVG_Stroke_Linecap_Example.png" alt=""></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/SVG_Stroke_Linejoin_Example.png" alt=""></p><h3 id="stroke-dasharray"><a href="#stroke-dasharray" class="headerlink" title="stroke-dasharray"></a>stroke-dasharray</h3><p>是一组用逗号分割的数字组成的数列</p><ol><li>第一个用来表示填色区域的长度</li><li>第二个用来表示非填色区域的长度</li><li>继续定义增加长度</li></ol><h3 id="使用css"><a href="#使用css" class="headerlink" title="使用css"></a>使用css</h3><p>除了定义对象的属性外，你也可以通过CSS来样式化填充和描边。语法和在html里使用CSS一样，只不过你要把background-color、border改成fill和stroke。注意，不是所有的属性都能用CSS来设置。上色和填充的部分一般是可以用CSS来设置的，比如fill，stroke，stroke-dasharray等，但是不包括下面会提到的渐变和图案等功能。另外，width、height，以及路径的命令等等，都不能用css设置。判断它们能不能用CSS设置还是比较容易的。</p><p>可以利用<code>:hover</code>伪类完成触发效果。</p><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>线性渐变沿着直线改变颜色，要插入一个线性渐变，你需要在SVG文件的defs元素内部，创建一个<code>&lt;linearGradient&gt;</code> 节点。</p><p>还有径向渐变也类似，创建径向渐变需要在文档的defs中添加一个<code>&lt;radialGradient&gt;</code>元素。</p><h2 id="图案"><a href="#图案" class="headerlink" title="图案"></a>图案</h2><p>patterns（图案）是SVG中用到最让人混淆的填充类型。</p><h2 id="剪切和遮罩"><a href="#剪切和遮罩" class="headerlink" title="剪切和遮罩"></a>剪切和遮罩</h2><p>Clipping用来移除在别处定义的元素的部分内容。在这里，任何半透明效果都是不行的。它只能要么显示要么不显示。</p><p>Masking允许使用透明度和灰度值遮罩计算得的软边缘。</p><p>Web开发工具箱中有一个很有用的工具是display:none。它虽然几无悬念，但是依然可以在SVG上使用该CSS属性，连同CSS2定义的visibility和clip属性。为了恢复以前设置的display:none，知道这一点很重要：所有的SVG元素的初始display值都是inline。</p><h2 id="其它SVG内容"><a href="#其它SVG内容" class="headerlink" title="其它SVG内容"></a>其它SVG内容</h2><h3 id="嵌入光栅图像"><a href="#嵌入光栅图像" class="headerlink" title="嵌入光栅图像"></a>嵌入光栅图像</h3><pre><code>很像在HTML中的img元素，SVG有一个image元素，用于同样的目的。你可以利用它嵌入任意光栅（以及矢量）图像。它的规格要求应用至少支持PNG、JPG和SVG格式文件。嵌入的图像变成一个普通的SVG元素。这意味着，你可以在其内容上用剪切、遮罩、滤镜、旋转以及其它SVG工具：</code></pre><h3 id="嵌入任意XML"><a href="#嵌入任意XML" class="headerlink" title="嵌入任意XML"></a>嵌入任意XML</h3><p>因为SVG是一个XML应用，所以你总是可以在SVG文档的任何位置嵌入任意XML。但是你没有必要定义周围的SVG需要怎样反作用于这个内容。</p><h2 id="滤镜效果"><a href="#滤镜效果" class="headerlink" title="滤镜效果"></a>滤镜效果</h2><p>有一种情况，基本形状不能提供你想要达到的效果的灵活性。投阴影、提供一个十分流行的示例，利用一个小变组合无法合理地创建它。滤镜是SVG的机制，允许创建精密的效果。</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>字体中需要了解的就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/textPath" target="_blank" rel="noopener">text-path</a>,即tref样式化。</p><h1 id="svg和canvas对比"><a href="#svg和canvas对比" class="headerlink" title="svg和canvas对比"></a>svg和canvas对比</h1><p>这部分参考W3school</p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><blockquote><p>参考</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Introduction" target="_blank" rel="noopener">MDN的svg教程</a></li><li><a href="http://www.w3school.com.cn/svg/svg_intro.asp" target="_blank" rel="noopener">W3school的svg教程</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SVG(scalable、vector、graphics)是XML语言的一种形式，有点类似XHTML，它可以用来绘制矢量图形。&lt;br&gt;
    
    </summary>
    
      <category term="svg" scheme="https://hddhyq.github.io/categories/svg/"/>
    
    
      <category term="html5" scheme="https://hddhyq.github.io/tags/html5/"/>
    
      <category term="svg" scheme="https://hddhyq.github.io/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>canvas的简单了解及应用</title>
    <link href="https://hddhyq.github.io/2018/07/28/canvas%E4%B8%8Esvg%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://hddhyq.github.io/2018/07/28/canvas与svg的简单了解及应用/</id>
    <published>2018-07-28T07:22:33.000Z</published>
    <updated>2018-12-09T14:14:41.195Z</updated>
    
    <content type="html"><![CDATA[<p>这个星期抽空看了下canvas，之前一直就对这两个东西望而却步，连简单的api和应用都没有了解。</p><p>工作中看到了<a href="https://html2canvas.hertzen.com/" target="_blank" rel="noopener">html2canvas</a>这个简单的工具可以根据DOM生成截图，于是抽空将MDN上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial" target="_blank" rel="noopener">canvas</a>教程撸了一遍。<br><a id="more"></a></p><h1 id="canvas基本概念"><a href="#canvas基本概念" class="headerlink" title="canvas基本概念"></a>canvas基本概念</h1><p><code>&lt;canvas&gt;</code>是HTML5新增的元素，可以通过JavaScript中的脚本来绘制图形。例如，它可以绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或渲染。时间太短，没有看canvas的3d部分，下面的介绍都是关于canvas的2d部分的。</p><p>首先需要知道的是canvas的绘图栅格，canvas和svg一样，坐标都是一样的，坐标都是从左上角起始：</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/Canvas_default_grid.png" alt=""></p><h1 id="绘制相关"><a href="#绘制相关" class="headerlink" title="绘制相关"></a>绘制相关</h1><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>fillRect(x, y, width, height)</td><td>绘制一个填充的矩形</td></tr><tr><td>strokeRect(x, y, width, height)</td><td>绘制一个矩形的边框</td></tr><tr><td>clearRect(x, y, width, height)</td><td>清除指定矩形区域，让清除部分完全透明</td></tr><tr><td>beginPath()</td><td>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径</td></tr><tr><td>closePath()</td><td>闭合路径之后图形绘制命令又重新指向到上下文中</td></tr><tr><td>stroke()</td><td>通过线条来绘制图形轮廓</td></tr><tr><td>moveTo(x, y)</td><td>将笔触移动到指定的坐标x以及y上</td></tr><tr><td>lineTo(x, y)</td><td>绘制一条从当前位置到指定x以及y位置的直线</td></tr><tr><td>arc(x, y, radius, startAngle, endAngle, anticlockwise)</td><td>画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成</td></tr><tr><td>arcTo(x1, y1, x2, y2, radius)</td><td>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点</td></tr><tr><td>quadraticCurveTo(cp1x, cp1y, x, y)</td><td>绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点</td></tr><tr><td>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</td><td>绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点</td></tr><tr><td>rect(x, y, width, height)</td><td>绘制一个左上角坐标为（x,y），宽高为width以及height的矩形</td></tr><tr><td>Path2D.addPath(path [, transform])​</td><td>添加了一条路径到当前路径（可能添加了一个变换矩阵）</td></tr><tr><td>fillStyle = color</td><td>设置图形的填充颜色</td></tr><tr><td>strokeStyle = color</td><td>设置图形轮廓的颜色</td></tr><tr><td>globalAlpha = transparencyValue</td><td>这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0</td></tr><tr><td>lineWidth = value</td><td>设置线条宽度</td></tr><tr><td>lineCap = type</td><td>设置线条末端样式(butt，round和square)</td></tr><tr><td>lineJoin = type</td><td>设定线条与线条间接合处的样式(round，bevel和miter)</td></tr><tr><td>miterLimit = value</td><td>限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度</td></tr><tr><td>getLineDash()</td><td>返回一个包含当前虚线样式，长度为非负偶数的数组</td></tr><tr><td>setLineDash(segments)</td><td>设置当前虚线样式</td></tr><tr><td>lineDashOffset = value</td><td>设置虚线样式的起始偏移量</td></tr><tr><td>createLinearGradient(x1, y1, x2, y2)</td><td>createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)</td></tr><tr><td>createRadialGradient(x1, y1, r1, x2, y2, r2)</td><td>createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆</td></tr><tr><td>gradient.addColorStop(position, color)</td><td>addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）</td></tr><tr><td>createPattern(image, type)</td><td>该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat</td></tr><tr><td>shadowOffsetX/Y = float</td><td>shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0</td></tr><tr><td>shadowBlur = float</td><td>shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0</td></tr><tr><td>shadowColor = color</td><td>shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色</td></tr><tr><td>fillText(text, x, y [, maxWidth])</td><td>在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的</td></tr><tr><td>strokeText(text, x, y [, maxWidth])</td><td>在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的</td></tr><tr><td>font = value</td><td>当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif</td></tr><tr><td>textAlign = value</td><td>文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start</td></tr><tr><td>textBaseline = value</td><td>基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic</td></tr><tr><td>direction = value</td><td>文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit</td></tr></tbody></table><h1 id="绘制和使用图片"><a href="#绘制和使用图片" class="headerlink" title="绘制和使用图片"></a>绘制和使用图片</h1><p>canvas具有图像操作能力，可以用于动态的图像合成或者作为图像的背景，已经游戏界面等等。</p><p>引入图像到canvas需要下面两个操作</p><ol><li>获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片</li><li>使用drawImage()函数将图片绘制到画布上</li></ol><h2 id="可获取图片类型"><a href="#可获取图片类型" class="headerlink" title="可获取图片类型"></a>可获取图片类型</h2><ul><li><p><strong>HTMLImageElement</strong></p><p>这些图片是由Image()函数构造出来的，或者任何的 <code>&lt;img&gt;</code> 元素</p></li><li><p><strong>HTMLVideoElement</strong></p><p>用一个HTML的 <code>&lt;video&gt;</code> 元素作为你的图片源，可以从视频中抓取当前帧作为一个图像</p></li><li><p><strong>HTMLCanvasElement</strong></p><p>可以使用另一个 <code>&lt;canvas&gt;</code> 元素作为你的图片源</p></li><li><p><strong>ImageBitmap</strong></p><p>这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成</p></li></ul><h2 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h2><p>我们可以创建一个新的<code>HTMLImageElement</code>元素，或者直接使用相同页面的图片。如果是其他域的图片，图片需要使用<code>crossOrigin</code>属性，需要图片的服务器允许跨域访问这个图片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();   <span class="comment">// 创建img元素</span></div><div class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 执行drawImage语句</span></div><div class="line">&#125;</div><div class="line">img.src = <span class="string">'myImage.png'</span>; <span class="comment">// 设置图片源地址</span></div></pre></td></tr></table></figure><p>新建的图片中，如果图片还没有加载，我们调用<code>drawImage()</code>什么都不会发生，所以我们的drawImage需要在<code>img.onload</code>里面执行，确保图片加载完毕。</p><p>还有一种方法就是通过<code>data:url</code>方式嵌入图片，可以使用base64格式。</p><h2 id="使用视频帧"><a href="#使用视频帧" class="headerlink" title="使用视频帧"></a>使用视频帧</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMyVideo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</div><div class="line">  <span class="keyword">if</span> (canvas.getContext) &#123;</div><div class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">'myvideo'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2><p>我们获取了源图对象，可以使用<code>drawImage</code>方法将它渲染到canvas里。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>drawImage(image, x, y)</td><td>其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标</td></tr><tr><td>drawImage(image, x, y, width, height)</td><td>这个方法多了2个参数：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小</td></tr><tr><td>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</td><td>第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数最好是参照右边的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。</td></tr></tbody></table><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/Canvas_drawimage.jpg" alt=""></p><h1 id="canvas变形"><a href="#canvas变形" class="headerlink" title="canvas变形"></a>canvas变形</h1><p>变形之前，了解两个状态的保存和恢复<code>save()</code>和<code>restore()</code>。</p><p>save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。</p><p>每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。在做变形之前先保存状态是一个良好的习惯，变形也是相对于整个画板的。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>translate(x, y)</td><td>translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量</td></tr><tr><td>rotate(angle)</td><td>这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值</td></tr><tr><td>scale(x, y)</td><td>scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有</td></tr><tr><td>transform(m11, m12, m21, m22, dx, dy)</td><td>这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵</td></tr><tr><td>setTransform(m11, m12, m21, m22, dx, dy)</td><td>这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。如果任意一个参数是无限大，那么变形矩阵也必须被标记为无限大，否则会抛出异常。从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。</td></tr><tr><td>resetTransform()</td><td>重置当前变形为单位矩阵</td></tr></tbody></table><h1 id="合成和裁切"><a href="#合成和裁切" class="headerlink" title="合成和裁切"></a>合成和裁切</h1><p>globalCompositeOperation 属性设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上。</p><p>源图像 = 您打算放置到画布上的绘图。</p><p>目标图像 = 您已经放置在画布上的绘图。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>source-over</td><td>默认。在目标图像上显示源图像。</td></tr><tr><td>source-atop</td><td>在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。</td></tr><tr><td>source-in</td><td>在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。</td></tr><tr><td>source-out</td><td>在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。</td></tr><tr><td>destination-over</td><td>在源图像上方显示目标图像。</td></tr><tr><td>destination-atop</td><td>在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。</td></tr><tr><td>destination-in</td><td>在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。</td></tr><tr><td>destination-out</td><td>在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。</td></tr><tr><td>lighter</td><td>显示源图像 + 目标图像。</td></tr><tr><td>copy</td><td>显示源图像。忽略目标图像。</td></tr><tr><td>xor</td><td>使用异或操作对源图像与目标图像进行组合。</td></tr></tbody></table><h2 id="裁切路径"><a href="#裁切路径" class="headerlink" title="裁切路径"></a>裁切路径</h2><p><code>clip()</code>裁切路径和普通的 <code>canvas</code> 图形差不多，不同的是它的作用是遮罩，用来隐藏不需要的部分。如右图所示。红边五角星就是裁切路径，所有在路径以外的部分都不会在 <code>canvas</code> 上绘制出来。</p><h1 id="canvas动画"><a href="#canvas动画" class="headerlink" title="canvas动画"></a>canvas动画</h1><p>首先了解一下，canvas动画的基本步骤：</p><ol><li><p>清空canvas</p><p>除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。</p></li><li><p>保存canvas状态</p><p>如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。</p></li><li><p>绘制动画图形</p><p>这一步是重画动画帧。</p></li><li><p>回复canvas状态</p><p>如果已经保存了canvas的状态，可以先恢复它，然会重绘下一帧。</p></li></ol><h2 id="操作动画"><a href="#操作动画" class="headerlink" title="操作动画"></a>操作动画</h2><p>实现动画，我们需要一些定时重绘的方法。简单的有两个方法<code>setInterval</code>和<code>setTimeout</code>方法来控制在设定的时间点上执行重绘。</p><p>可以用<code>window.setInterval()</code>, <code>window.setTimeout()</code>,和<code>window.requestAnimationFrame()</code>来设定定期执行一个指定函数</p><ul><li><code>setInterval(function, delay)</code> 当设定好间隔时间后，function会定期执行。</li><li><code>setTimeout(function, delay)</code> 在设定好的事件之后执行函数。</li><li><code>requestAnimationFrame(callback)</code> 告诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。</li></ul><p>如果不需要和用户互动，可以使用<code>setInterval()</code>方法，它可以定期的执行指定代码。如果我们需要做一个游戏，我们可以使用键盘或者鼠标事件配合<code>setTimeout()</code>方法来实现。通过设置事件监听，我们可以捕捉用户的交互，并执行相应的动作。</p><p><code>window.requestAnimationFrame()</code>实现动画效果。这个方法提供了更加平滑更加有效率的方式来执行动画，当系统准备好了重绘条件的时候，才调用绘制动画帧。一般每秒钟回调函数执行60次，也有可能会被降低。</p><p>还有一个<code>window.cancelAnimationFrame()</code>用于取消动画。</p><h1 id="像素操作"><a href="#像素操作" class="headerlink" title="像素操作"></a>像素操作</h1><p>执行像素操作，我们需要了解一下ImageData对象。</p><p>ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：</p><ul><li><strong>width</strong> 图片宽度，单位是像素</li><li><strong>height</strong> 图片高度，单位是像素</li><li><strong>data</strong> <code>Uint8ClampedArray</code>类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）</li></ul><p>data属性返回一个<code>Uint8ClampedArray</code>,它可以被使用作为查看初始像素数据。每个像素用四个1bytes值（按照red，green，blue和alpha），rgba的顺序来排列。</p><p>每个部分的颜色值部分用0至255来表示，每个部分被分配到一个数组内连续的索引，左上角像素的红色部分在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。</p><p>如要读取，第50行，第200列的像素的蓝色部分，你会写以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blueComponent = imageData.data[((<span class="number">50</span>*(imageData.width*<span class="number">4</span>)) + (<span class="number">200</span>*<span class="number">4</span>)) + <span class="number">2</span>];</div></pre></td></tr></table></figure><h2 id="创建一个ImageData对象"><a href="#创建一个ImageData对象" class="headerlink" title="创建一个ImageData对象"></a>创建一个ImageData对象</h2><p>去创建一个新的，空白的ImageData对象，你应该会使用<code>createImageData()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myImageData = ctx.createImageData(width, height);</div><div class="line"><span class="comment">// 创建了一个新的具体特定尺寸的ImageData对象。所有像素被预设为透明黑</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> myImageData = ctx.createImageData(anotherImageData)</div><div class="line"><span class="comment">// 尺寸相同，依旧是透明黑</span></div></pre></td></tr></table></figure><h2 id="得到场景像素数据"><a href="#得到场景像素数据" class="headerlink" title="得到场景像素数据"></a>得到场景像素数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取指定区域的画布对象</span></div><div class="line"><span class="keyword">var</span> myImageData = ctx.getImageData(left, top, width, height)</div></pre></td></tr></table></figure><p>下面看一个颜色选择器的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">img.src = <span class="string">'./cat.jpg'</span>;</div><div class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</div><div class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">  img.style.display = <span class="string">'none'</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> color = <span class="built_in">document</span>.getElementById(<span class="string">'color'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> x = event.layerX;</div><div class="line">  <span class="keyword">var</span> y = event.layerY;</div><div class="line">  <span class="keyword">var</span> pixel = ctx.getImageData(x, y, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">  <span class="keyword">var</span> data = pixel.data;</div><div class="line">  <span class="keyword">var</span> rgba = <span class="string">'rgba('</span> + data[<span class="number">0</span>] + <span class="string">','</span> + data[<span class="number">1</span>] + <span class="string">','</span> + data[<span class="number">2</span>] + <span class="string">','</span> + (data[<span class="number">3</span>] / <span class="number">255</span>) + <span class="string">')'</span>;</div><div class="line">  color.style.background =  rgba;</div><div class="line">  color.textContent = rgba;</div><div class="line">&#125;</div><div class="line">canvas.addEventListener(<span class="string">'mousemove'</span>, pick);</div></pre></td></tr></table></figure><h2 id="在场景中写入数据"><a href="#在场景中写入数据" class="headerlink" title="在场景中写入数据"></a>在场景中写入数据</h2><p>可以利用putImageData()方法对场景进行像素数据的写入。</p><p><code>ctx.putImageData(myImageData, dx, dy);</code></p><p>dx和dy参数表示你希望在场景内左上角绘制的像素数据得到的设备坐标。</p><h2 id="缩放和反锯齿"><a href="#缩放和反锯齿" class="headerlink" title="缩放和反锯齿"></a>缩放和反锯齿</h2><p><code>imageSmoothingEnabled</code>默认是启用的，想要关闭需要添加不同的浏览器前缀来手动关闭。</p><h1 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h1><p><code>HTMLCanvasElement</code>提供一个toDataURL()方法，此方法在保存图片的时候有用。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>canvas.toDataURL(‘image/png’)</td><td>默认设定。创建一个PNG图片。</td></tr><tr><td>canvas.toDataURL(‘image/jpeg’, quality)</td><td>创建一个JPG图片。你可以有选择地提供从0到1的品质量，1表示最好品质，0基本不被辨析但有比较小的文件大小。</td></tr><tr><td>canvas.toBlob(callback, type, encoderOptions)</td><td>这个创建了一个在画布中的代表图片的Blob对象</td></tr></tbody></table><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ul><li>在离屏canvas上预渲染相似的图形或重复的对象</li><li>避免浮点数的坐标点，用整数取而代之</li><li>不要在用drawImage时缩放图像</li><li>使用多层画布去画一个复杂的场景</li><li>用CSS设置大的背景图</li><li>用CSS transforms特性缩放画布</li><li>使用moz-opaque属性(仅限Gecko)</li></ul><h2 id="更多贴士"><a href="#更多贴士" class="headerlink" title="更多贴士"></a>更多贴士</h2><ul><li>将画布的函数调用集合到一起（例如，画一条折线，而不要画多条分开的直线）</li><li>避免不必要的画布状态改变</li><li>渲染画布中的不同点，而非整个新状态</li><li>尽可能避免 shadowBlur特性</li><li>尽可能避免text rendering</li><li>使用不同的办法去清除画布(clearRect() vs. fillRect() vs. 调整canvas大小)</li><li>有动画，请使用window.requestAnimationFrame() 而非window.setInterval()</li><li>请谨慎使用大型物理库</li><li>用<a href="https://jsperf.com/" target="_blank" rel="noopener">JSPerf</a>测试性能</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个星期抽空看了下canvas，之前一直就对这两个东西望而却步，连简单的api和应用都没有了解。&lt;/p&gt;
&lt;p&gt;工作中看到了&lt;a href=&quot;https://html2canvas.hertzen.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;html2canvas&lt;/a&gt;这个简单的工具可以根据DOM生成截图，于是抽空将MDN上的&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;canvas&lt;/a&gt;教程撸了一遍。&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="https://hddhyq.github.io/categories/canvas/"/>
    
    
      <category term="html5" scheme="https://hddhyq.github.io/tags/html5/"/>
    
      <category term="canvas" scheme="https://hddhyq.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>touch事件&amp;&amp;mouse事件&amp;&amp;PC端&amp;&amp;移动端总结</title>
    <link href="https://hddhyq.github.io/2018/07/12/touch%E4%BA%8B%E4%BB%B6-mouse%E4%BA%8B%E4%BB%B6-PC%E7%AB%AF-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://hddhyq.github.io/2018/07/12/touch事件-mouse事件-PC端-移动端总结/</id>
    <published>2018-07-12T09:04:01.000Z</published>
    <updated>2018-12-09T14:14:41.198Z</updated>
    
    <content type="html"><![CDATA[<p>最近几天看的东西比较杂，抽空做下小总结。本来想研究下PC端的mousedown，mousemove，mouseup在移动端的浏览器的表现，如何用touch来替代，结果不知不觉，重新看了下JS高程的事件处理章节，关于各种浏览器的clinetX,pageX也看了不少，接下来就做下总结了。<br><a id="more"></a></p><h1 id="touches对象的各种参数"><a href="#touches对象的各种参数" class="headerlink" title="touches对象的各种参数"></a>touches对象的各种参数</h1><h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><ul><li><code>touchstart</code>: 手指放在屏幕上的时候出发：即使已经有一个手指放在屏幕上也会触发。</li><li><code>touchmove</code>：当手指在屏幕上连续地出发。期间调用<code>preventDefault()</code>会阻止默认滚动。</li><li><code>touchend</code>：当手指从屏幕上移开时出发。</li><li><code>touchcancel</code>：当系统停止跟踪触摸时出发。</li></ul><p>这几个事件都会冒泡，也都能取消。</p><p>下面放一下移动端跟踪触摸的时候三个event事件属性。</p><ul><li><code>touches</code>：表示当前跟踪的触摸操作的<code>Touch</code>对象的数组。</li><li><code>targetTouches</code>：特定于事件目标的<code>Touch</code>对象的数组。</li><li><code>changedTouches</code>：表示自上次触摸以来发生改变的<code>Touch</code>对象的数组。</li></ul><h3 id="touches"><a href="#touches" class="headerlink" title="touches"></a>touches</h3><p>下面是touches属性介绍：</p><table><thead><tr><th>属性</th><th>属性含义</th></tr></thead><tbody><tr><td>clientX, Y</td><td>触摸目标在视口中的x, y坐标，不包括任何滚动偏移</td></tr><tr><td>force</td><td>触摸手指挤压触摸平面的压力大小0.0-1.0之间</td></tr><tr><td>identifier</td><td>表示触摸的唯一ID</td></tr><tr><td>pageX, Y</td><td>触摸目标在页面中的x, y坐标</td></tr><tr><td>radiusX, Y</td><td>能够包围用户和触摸平面的接触面的最小椭圆的水平轴(X轴),垂直轴(Y轴)半径</td></tr><tr><td>rotationAngle</td><td>上述椭圆的能精准覆盖用户与触摸平面的接触面的角度，取值0-90之间</td></tr><tr><td>screenX, Y</td><td>返回触点相对于屏幕左边沿的的X, y坐标. 不包含页面滚动的偏移量</td></tr><tr><td>target</td><td>触摸touchstart触摸在屏幕上返回的element</td></tr></tbody></table><h1 id="mouse事件的各种参数"><a href="#mouse事件的各种参数" class="headerlink" title="mouse事件的各种参数"></a>mouse事件的各种参数</h1><p>DOM3级事件中有九个鼠标事件，顺便放一下<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener">事件速查表</a>.</p><table><thead><tr><th>事件名</th><th>触发条件</th></tr></thead><tbody><tr><td>click</td><td>用户点击主鼠标按钮或者按下回车键触发</td></tr><tr><td>dbclick</td><td>用户双击主鼠标按钮触发</td></tr><tr><td>mousemove</td><td>鼠标指针在元素内部移动时重复触发</td></tr><tr><td>mouseup</td><td>用户释放鼠标shi</td></tr><tr><td>mousedown</td><td>用户按下任意鼠标按钮触发，不能通过键盘触发这个事件</td></tr><tr><td>mouseenter</td><td>指针移到有事件监听的元素内（不冒泡）</td></tr><tr><td>mouseleave</td><td>指针移出元素范围外（不冒泡）</td></tr><tr><td>mouseover</td><td>指针移到有事件监听的元素或者它的子元素内</td></tr><tr><td>mouseout</td><td>指针移出元素，或者移到它的子元素上</td></tr></tbody></table><p>这里了解一下click的顺序，<code>mousedown</code> -&gt; <code>mouseup</code> -&gt; <code>click</code>。这里click是依赖先行事件mousedown，mouseup运行的。也就是说，假如我们的拖动的div上绑定有一个click事件，拖动的过程中，就会在mouseup后面触发click事件。所以我们可以将click事件绑定到mouseup上面，判断是否有mousemove来考虑触发click上绑定的事件的时机。</p><h1 id="事件处理，事件监听，事件委托"><a href="#事件处理，事件监听，事件委托" class="headerlink" title="事件处理，事件监听，事件委托"></a>事件处理，事件监听，事件委托</h1><p>DOM事件流规定中，事件流包含三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。在DOM事件流中，实际的元素在捕获阶段不会接收到事件。这意味着事件处理会被当做冒泡阶段的一部分。</p><h2 id="事件处理的几种常见方法"><a href="#事件处理的几种常见方法" class="headerlink" title="事件处理的几种常见方法"></a>事件处理的几种常见方法</h2><h3 id="1-HTML事件处理程序"><a href="#1-HTML事件处理程序" class="headerlink" title="1. HTML事件处理程序"></a>1. HTML事件处理程序</h3><p>直接在html上绑定一个事件，事件处理程序一般以<code>&#39;on&#39;</code>开头。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 绑定执行语句 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">onclick</span>=<span class="string">"alert('clicked')"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!-- 绑定函数 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">    alert(<span class="string">'clickclickclicked!'</span>)</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><p>上述事件处理程序会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象。</p><p>通过event变量，可以直接访问到事件对象，你不用从函数的参数列表读取。在函数内部，this等于事件的目标元素。那么这里需要注意了，事件处理函数中的this指向的问题。所以在需要添加到this的函数中，我们有时会用词法作用域context来保存需要调用的上下文。像上一篇文章中<a href="https://hddhyq.github.io/2018/07/08/%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96debounce%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81throttle%E7%9A%84%E5%BA%94%E7%94%A8/#more">函数节流</a>，就用到了相关保存运行时this的方法。</p><h3 id="2-DOM-0级事件处理"><a href="#2-DOM-0级事件处理" class="headerlink" title="2. DOM 0级事件处理"></a>2. DOM 0级事件处理</h3><p>使用传统的JavaScript指定事件处理方式，先获取到相关的需要操作对象的引用。</p><p>每个元素都有自己的事件处理程序属性，这些属性通常全部小写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</div><div class="line"></div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'this.id'</span>);  <span class="comment">// 'myBtn'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 清空事件绑定</span></div><div class="line">btn.onclick = <span class="literal">null</span>;</div></pre></td></tr></table></figure><p>这种形式添加的事件处理程序会在事件流的冒泡阶段被处理。</p><h3 id="3-DOM-2级事件处理程序"><a href="#3-DOM-2级事件处理程序" class="headerlink" title="3. DOM 2级事件处理程序"></a>3. DOM 2级事件处理程序</h3><p>所有的DOM节点都包含两个方法，<code>addEventListener()</code>和<code>removeEventListener()</code>，并接受三个参数：事件名，作为事件处理程序的函数和一个布尔值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'hello hdd'</span>);</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line"></div><div class="line">btn.removeEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 没有用</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'hello hdd'</span>);</div><div class="line">&#125;, <span class="literal">false</span>); </div><div class="line"><span class="comment">// 上述代码无法删除相关的事件处理函数，因为两个匿名函数不是同一个函数了。</span></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> handler =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'hello hdd'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>);</div><div class="line">btn.removeEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>);</div></pre></td></tr></table></figure><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>event对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过所有事件都会有下表列出的成员。下表的属性都是只读的。</p><table><thead><tr><th>属性/方法</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>bubbles</td><td>Boolean</td><td>表明事件是否冒泡</td></tr><tr><td>cancelable</td><td>Boolean</td><td>表明是否可以取消事件的默认行为</td></tr><tr><td>currentTarget</td><td>Element</td><td>其事件处理程序当前正在处理的那个元素</td></tr><tr><td>defaultPrevented</td><td>Boolean</td><td>是否调用preventDefault()</td></tr><tr><td>detail</td><td>Integer</td><td>与事件相关的细节信息</td></tr><tr><td>eventPhase</td><td>Interger</td><td>调用事件处理程序的阶段：1.捕获阶段2.处于目标3.冒泡阶段</td></tr><tr><td>preventDefault()</td><td>Function</td><td>取消事件的默认行为。如果cancelable是true，则可以使用这个方法</td></tr><tr><td>stopImmediatePropagation()</td><td>Function</td><td>取消事件的进一步捕获或冒泡，同时阻止任何使劲按处理程序被调用</td></tr><tr><td>stopPropagation</td><td>Function</td><td>取消使劲按的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法</td></tr><tr><td>target</td><td>Element</td><td>事件的目标</td></tr><tr><td>trusted</td><td>Boolean</td><td>true表示浏览器生成的，false表示开发者通过JavaScript创建的</td></tr><tr><td>type</td><td>String</td><td>被触发的事件类型</td></tr><tr><td>view</td><td>AbstractView</td><td>与事件关联的抽象试图。等同于发生对象的window对象</td></tr></tbody></table><p>在事件处理程序的内部，this始终等于<code>currentTarget</code>的值，而<code>target</code>则只包含事件的实际目标。下面点击子元素：</p><ol><li>子元素绑定事件处理程序，父元素绑定事件处理函数。<code>currentTarget</code>等于父元素，<code>target</code>等于子元素</li><li>子元素不绑定事件处理程序，父元素绑定事件处理函数。<code>currentTarget</code>等于父元素，<code>target</code>等于子元素</li><li>子元素绑定事件处理程序，父元素不绑定事件处理函数。<code>currentTarget</code>等于子元素，<code>target</code>等于子元素</li></ol><p>下面看几种常见的事件处理的冒泡次序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</div><div class="line"></div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  alert(event.eventPhase);   <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  alert(event.eventPhase);   <span class="comment">// 1</span></div><div class="line">&#125;, <span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  alert(event.eventPhase);   <span class="comment">// 3</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>最后，事件处理程序执行期间，event对象一直存在，一旦事件处理程序执行完成，event对象就会销毁。</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>想页面添加大量的事件处理程序会占用大量的内存，内存中的对象越多，性能也就越差。而且，必须事先指定所有事件处理程序而导致的DOM访问次数会延迟整个页面的交互就绪时间。</p><p>要理解事件委托，事件冒泡和捕获必须梳理一下。</p><p>当一个事件发生在具有父元素的元素导航，现代浏览器运行两个不同的阶段-捕获阶段和冒泡阶段。</p><p>在现代浏览器中，默认情况下，多有时间处理程序都在冒泡阶段注册，因此当我们点击子元素的时候。会沿着这个事件冒泡线路：</p><ul><li>发现了子元素的事件处理程序，并运行了它。</li><li>往外冒泡发现父元素的事件处理程序，并运行它。</li></ul><p>避免这个问题的方法就是使用<code>stopPropagation()</code>修复问题。</p><p>利用了事件冒泡会发现父元素的事件处理程序。我们就可以利用事件委托。</p><p>如果我们有大量子元素，想要点击任何一个都可以运行一段代码，可以将事件监听器设置在父节点元素，而且对于新添加的元素，事件委托很好的能为动态添加的元素动态的绑定事件处理函数。下面是例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"lists"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"list1"</span>&gt;</span>列表第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"list2"</span>&gt;</span>列表第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"list3"</span>&gt;</span>列表第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'lists'</span>);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  <span class="comment">// 也可以绑定lists元素</span></div><div class="line">  <span class="keyword">var</span> target = event.target;</div><div class="line"></div><div class="line">  <span class="keyword">switch</span>(target.id) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'list1'</span>:</div><div class="line">      <span class="built_in">console</span>.log(target.innerHTML);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'list2'</span>:</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'我是第二项'</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'list3'</span>:</div><div class="line">      alert(<span class="string">'hello world'</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h1 id="浏览器中事件相关的常见几种位置坐标"><a href="#浏览器中事件相关的常见几种位置坐标" class="headerlink" title="浏览器中事件相关的常见几种位置坐标"></a>浏览器中事件相关的常见几种位置坐标</h1><h2 id="clientX-Y"><a href="#clientX-Y" class="headerlink" title="clientX/Y"></a>clientX/Y</h2><p>获取到的是触发点相对浏览器可视区域左上角距离，不随页面滚动而改变。</p><h2 id="pageX-Y"><a href="#pageX-Y" class="headerlink" title="pageX/Y"></a>pageX/Y</h2><p>pageX/Y获取到的是触发点相对文档区域左上角距离，会随着页面滚动而改变。</p><h2 id="offsetX-Y"><a href="#offsetX-Y" class="headerlink" title="offsetX/Y"></a>offsetX/Y</h2><p>offsetX/Y获取到是触发点相对被触发dom的左上角距离，不过左上角基准点在不同浏览器中有区别，其中在IE中以内容区左上角为基准点不包括边框，如果触发点在边框上会返回负值，而chrome中以边框左上角为基准点。</p><h2 id="layerX-Y"><a href="#layerX-Y" class="headerlink" title="layerX/Y"></a>layerX/Y</h2><p>layerX/Y获取到的是触发点相对被触发dom左上角的距离，数值与offsetX/Y相同，这个变量就是firefox用来替代offsetX/Y的，基准点为边框左上角，但是有个条件就是，被触发的dom需要设置为<code>position:relative</code>或者<code>position:absolute</code>，否则会返回相对html文档区域左上角的距离。</p><h2 id="screenX-Y"><a href="#screenX-Y" class="headerlink" title="screenX/Y"></a>screenX/Y</h2><p>screenX/Y获取到的是触发点相对显示器屏幕左上角的距离，不随页面滚动而改变。</p><p>一个图解释：</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/screenX_Y.jpg" alt=""></p><h1 id="简单的移动端-PC端拖动代码"><a href="#简单的移动端-PC端拖动代码" class="headerlink" title="简单的移动端/PC端拖动代码"></a>简单的移动端/PC端拖动代码</h1><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/brokenbonesdd/jabtn2g6/embedded/js,html,css,result/dark" frameborder="0" allowfullscreen></iframe><p>上面的代码中，我将事件的type做了一下判断，进而绑定相关的。</p><h1 id="关于拖拽事件的常见bug及处理方式"><a href="#关于拖拽事件的常见bug及处理方式" class="headerlink" title="关于拖拽事件的常见bug及处理方式"></a>关于拖拽事件的常见bug及处理方式</h1><p>介绍下常见的，拖拽小问题。</p><h2 id="1-鼠标移动过快，离开拖拽物体"><a href="#1-鼠标移动过快，离开拖拽物体" class="headerlink" title="1. 鼠标移动过快，离开拖拽物体"></a>1. 鼠标移动过快，离开拖拽物体</h2><p>由于拖拽的div太小了，拖拽物体不在随着鼠标移动，前面介绍事件的时候也提到了，鼠标移动元素，<code>mousemove</code>事件不再触发，这时我们可以将拖拽物体上的<code>mousemve</code>事件放到<code>document</code>上面，同时将<code>mouseup</code>也改为<code>document</code>上面的事件</p><h2 id="2-会出现将div脱出浏览器窗口"><a href="#2-会出现将div脱出浏览器窗口" class="headerlink" title="2. 会出现将div脱出浏览器窗口"></a>2. 会出现将div脱出浏览器窗口</h2><p>限制div的拖动距离</p><p>还有一些常见bug，一般阻止默认事件都可以解决。</p><h1 id="部分参考"><a href="#部分参考" class="headerlink" title="部分参考"></a>部分参考</h1><ul><li><a href="http://www.cnblogs.com/moqiutao/p/5050225.html" target="_blank" rel="noopener">http://www.cnblogs.com/moqiutao/p/5050225.html</a></li><li><a href="http://www.cnblogs.com/yufann/p/JS-Summary9.html" target="_blank" rel="noopener">http://www.cnblogs.com/yufann/p/JS-Summary9.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几天看的东西比较杂，抽空做下小总结。本来想研究下PC端的mousedown，mousemove，mouseup在移动端的浏览器的表现，如何用touch来替代，结果不知不觉，重新看了下JS高程的事件处理章节，关于各种浏览器的clinetX,pageX也看了不少，接下来就做下总结了。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS基础事件" scheme="https://hddhyq.github.io/tags/JS%E5%9F%BA%E7%A1%80%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="触摸" scheme="https://hddhyq.github.io/tags/%E8%A7%A6%E6%91%B8/"/>
    
  </entry>
  
  <entry>
    <title>函数去抖debounce和函数节流throttle的应用</title>
    <link href="https://hddhyq.github.io/2018/07/08/%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96debounce%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81throttle%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://hddhyq.github.io/2018/07/08/函数去抖debounce和函数节流throttle的应用/</id>
    <published>2018-07-08T04:43:09.000Z</published>
    <updated>2018-07-08T06:42:10.158Z</updated>
    
    <content type="html"><![CDATA[<p>开始以为只有节流函数，原来还有去抖函数啊。两个概念第一次听的话肯定比较容易混淆，接下来就来研究一下它们吧。<br><a id="more"></a></p><h1 id="函数去抖debounce"><a href="#函数去抖debounce" class="headerlink" title="函数去抖debounce"></a>函数去抖debounce</h1><p>在一段时间内执行该动作，在单位时间内重新调用该动作，会重新计算时间。</p><p>我的理解就是，只要触发的够快，函数就追不上我，哈哈哈。</p><p>当我停下来的时候，函数会触发最后一次。所以其中肯定有一个定时器哈，下面展示一下简单实现的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</div><div class="line">    <span class="comment">// 定义一个定时器</span></div><div class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 绑定函数调用时上下文及参数</span></div><div class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</div><div class="line">        args = <span class="built_in">arguments</span>;</div><div class="line">        clearTimeout(timer);</div><div class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'debounce被触发了'</span>);</div><div class="line">            fn.apply(context, args);</div><div class="line">        &#125;, delay);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义一个btn，然后去点它来测试</span></div><div class="line">$(<span class="string">'.btn-click-debounce'</span>).on(<span class="string">'click'</span>, debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'200ms一次'</span>)</div><div class="line">&#125;, <span class="number">200</span>))</div></pre></td></tr></table></figure><h1 id="函数节流throttle"><a href="#函数节流throttle" class="headerlink" title="函数节流throttle"></a>函数节流throttle</h1><p>将倾斜而出的水流，一点一点的流出，这就是节流。放在函数触发中，就是本来快速l连续触发的事件以单位时间为间隔来触发。简单实现的源码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, threshhold</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> last = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</div><div class="line">    threshhold || (threshhold = <span class="number">200</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// Date.now();</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(last &amp;&amp; ((now &lt; last + threshhold)) &#123;</div><div class="line">            <span class="comment">// 判断时间间隔，以及是否第一次触发</span></div><div class="line">            clearTimeout(timer);</div><div class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                last = now;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'throttle被触发了'</span>);</div><div class="line">                fn.apply(context, args);</div><div class="line">            &#125;, threshhold)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            last = now;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'throttle被触发了'</span>);</div><div class="line">            fn.apply(context, args);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$(<span class="string">'.btn-click-throttle'</span>).on(<span class="string">'click'</span>, throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'200ms一次'</span>)</div><div class="line">&#125;, <span class="number">200</span>))</div></pre></td></tr></table></figure></p><h1 id="使用的场景"><a href="#使用的场景" class="headerlink" title="使用的场景"></a>使用的场景</h1><h2 id="throttle函数节流"><a href="#throttle函数节流" class="headerlink" title="throttle函数节流"></a>throttle函数节流</h2><ul><li>Dom元素的拖拽实现（mousemove）</li><li>射击游戏的mousedown/keydown事件（单位时间只能发射一颗子弹）</li><li>计算鼠标移动的距离（mousemove）</li><li>Canvas模拟画板功能</li><li>搜索联想（keyup）</li><li>监听滚动事件是否到底部自动加载更多（<br>监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次）</li></ul><h2 id="debounce应用场景"><a href="#debounce应用场景" class="headerlink" title="debounce应用场景"></a>debounce应用场景</h2><ul><li>每次resize/scroll触发统计</li><li>文本输入的验证（连续输入文字后发送ajax进行验证，验证一次就好）</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/zichi/p/5948936.html" target="_blank" rel="noopener">http://www.cnblogs.com/zichi/p/5948936.html</a></p><p><a href="https://www.cnblogs.com/fsjohnhuang/p/4147810.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsjohnhuang/p/4147810.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始以为只有节流函数，原来还有去抖函数啊。两个概念第一次听的话肯定比较容易混淆，接下来就来研究一下它们吧。&lt;br&gt;
    
    </summary>
    
      <category term="JStricks" scheme="https://hddhyq.github.io/categories/JStricks/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="优化" scheme="https://hddhyq.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于之前看看的一些css</title>
    <link href="https://hddhyq.github.io/2018/06/12/%E5%85%B3%E4%BA%8E%E4%B9%8B%E5%89%8D%E7%9C%8B%E7%9C%8B%E7%9A%84%E4%B8%80%E4%BA%9Bcss/"/>
    <id>https://hddhyq.github.io/2018/06/12/关于之前看看的一些css/</id>
    <published>2018-06-12T06:44:28.000Z</published>
    <updated>2018-07-08T04:25:55.520Z</updated>
    
    <content type="html"><![CDATA[<p>记一下上个月看的图解CSS的一些简单的知识点哈。<br><a id="more"></a></p><h1 id="元素百分比的相对计算"><a href="#元素百分比的相对计算" class="headerlink" title="元素百分比的相对计算"></a>元素百分比的相对计算</h1><table><thead><tr><th>相对的元素计算</th><th>属性</th></tr></thead><tbody><tr><td>父元素宽度</td><td><code>width</code>, <code>left</code>, <code>right</code>, <code>text-indent</code>, <code>padding</code>, <code>margin</code>等</td></tr><tr><td>父元素高度</td><td><code>height</code>, <code>top</code>, <code>bottom</code>等</td></tr><tr><td>主轴长度</td><td><code>flex-basis</code></td></tr><tr><td>继承字号</td><td><code>flex-size</code></td></tr><tr><td>自身字号</td><td><code>line-height</code></td></tr><tr><td>自身宽高</td><td><code>vertical-align</code></td></tr><tr><td>自身设置</td><td><code>background-position</code>; <code>border-image-slice</code></td></tr><tr><td>特殊算法</td><td><code>position: absolute</code>，相对于父元素最近的<code>position</code>不为<code>static</code>的祖先元素。如果没有这样的元素，则相对于视口。</td></tr></tbody></table><h1 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h1><table><thead><tr><th>选择器</th><th>功能描述</th></tr></thead><tbody><tr><td>E:first-child</td><td>作为父元素的第一个子元素E</td></tr><tr><td>E:last-child</td><td>作为父元素的最后一个子元素的元素E</td></tr><tr><td>E:root</td><td>选择匹配元素E所在文档的根元素</td></tr><tr><td>E F:nth-child(n)</td><td>选择父元素的第n个子元素F</td></tr><tr><td>E F:nth-last-child(n)</td><td>选择元素E的倒数第n个子元素F</td></tr><tr><td>E:nth-of-type(n)</td><td>选择父元素内具有指定类型的第n个E元素</td></tr><tr><td>E:nth-last-of-type(n)</td><td>选择父元素内具有指定类型的倒数第n个E元素</td></tr><tr><td>E:first-of-type</td><td>选择父元素内具有指定类型的的第一个E元素，与E:nth-of-type(1)相同</td></tr><tr><td>E:last-of-type</td><td>选择父元素内具有指定类型的的最后一个E元素，与E:nth-last-of-type(1)相同</td></tr><tr><td>E:only-child</td><td>选择父元素只包含一个字元素，且该子元素匹配E元素</td></tr><tr><td>E:only-of-type</td><td>选择父元素只包含一个同类型的子元素，且该子元素匹配E元素</td></tr><tr><td>E:empty</td><td>选择没有子类型的元素，而且该元素也不包含任何文本节点</td></tr></tbody></table><p>关于，伪类元素选择器中n的用法，也就是n取0到+∞，在子元素的个数范围内，取相对应的子元素。</p><h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><p>伪类一般反映无法在CSS中轻松或可靠地检测到的某个元素的属性或状态；伪元素则表示DOM外部的某种元素。</p><table><thead><tr><th>伪元素</th><th>功能描述</th></tr></thead><tbody><tr><td>::first-letter</td><td>选择文本块的第一个字母，除非在同一行中包含一些其他元素</td></tr><tr><td>::first-line</td><td>匹配元素的第一行文本</td></tr><tr><td>::before和::after</td><td>生成的内容不会成为DOM的一部分，但是可以设置样式</td></tr><tr><td>::selection</td><td>匹配突出显示的文本，可设置background和color</td></tr></tbody></table><h1 id="border相关"><a href="#border相关" class="headerlink" title="border相关"></a>border相关</h1><h2 id="border-shadow"><a href="#border-shadow" class="headerlink" title="border-shadow"></a>border-shadow</h2><table><thead><tr><th>属性</th><th>功能描述</th></tr></thead><tbody><tr><td>none</td><td>默认值，元素没有任何阴影效果</td></tr><tr><td>inset</td><td>阴影类型，可选值。默认外投影</td></tr><tr><td>x-offset</td><td>阴影水平偏移量，其值可以是正负值。正值在元素右边</td></tr><tr><td>y-offset</td><td>阴影垂直偏移量，其值可以是正负值。正值在元素底部</td></tr><tr><td>blur-radius</td><td>阴影模糊半径，可选参数。取值为0，表示阴影不具有模糊效果，取值越大，阴影的边缘越模糊</td></tr><tr><td>spread-radius</td><td>阴影扩展半径，可选参数。正值整个阴影都延展扩大，负值，整个阴影缩小</td></tr><tr><td>color</td><td>阴影颜色，不取值则是默认色，各个浏览器的默认色不一样的。</td></tr></tbody></table><h1 id="css3背景"><a href="#css3背景" class="headerlink" title="css3背景"></a>css3背景</h1><p>主要有</p><ul><li>background-color 背景颜色</li><li>background-image 背景图片</li><li>background-repeat 背景图片展示方式</li><li>background-attachment 背景图片是固定还是滚动</li><li>background-position 背景图片位置</li></ul><p>CSS3新增属性</p><ul><li>background-origin 指定绘制背景图片的起点（padding-box||border-box||content-box）</li><li>background-clip 指定背景图片的显示范围（padding-box||border-box||content-box）</li><li>background-size 指定背景图片的尺寸大小（auto||percentage||cover||contain）</li><li>background-break 指定内联元素的背景图片进行平铺时的循环方式</li></ul><h1 id="css文本类型"><a href="#css文本类型" class="headerlink" title="css文本类型"></a>css文本类型</h1><table><thead><tr><th>属性</th><th>功能描述</th><th>取值</th></tr></thead><tbody><tr><td>word-spacing</td><td>定义词与词之间的间距</td><td>normal，length（设置词与词之间间距，可以是负数）</td></tr><tr><td>letter-spacing</td><td>定义字符之间的间距</td><td>normal，length（设置词与词之间间距，可以是负数）</td></tr><tr><td>vertiacl-align</td><td>定义文本的垂直对齐方式</td><td>baseline、sub（上标对齐）、super（下标对齐）、bottom（行框底端对齐）、text-bottom（行内文本底端对齐）、top（顶端对齐）、middle（居中对齐）、百分比数字、长度</td></tr><tr><td>text-decoration</td><td>定义文本的修饰线</td><td>none、underline、overline、line-through、blink</td></tr><tr><td>text-indent</td><td>定义文本首行缩进</td><td>length（长度单位）和百分比</td></tr><tr><td>text-align</td><td>定义文本水平对齐方式</td><td>left（左对齐）、center（水平对齐）、right（右对齐）、justify（两端对齐）</td></tr><tr><td>line-height</td><td>定义文本行高</td><td>normal、长度值、百分比值、数字</td></tr><tr><td>text-transform</td><td>定义文本大小写</td><td>none、uppercase、lowercase、capitalize（首字母大写）</td></tr><tr><td>text-shadow</td><td>定义文本阴影效果</td><td></td></tr><tr><td>white-space</td><td>定义文字之间和文本之间的空白符间距</td><td>normal、nowrap（空白符合并，换行符忽略）、pre（空白符，换行符保留）、pre-wrap（空白符，换行符保留）、pre-line（空白符合，换行符保留）</td></tr><tr><td>direction</td><td>控制文本流入的方向</td><td>ltr、rtl（文本从右到左流入）、inhert（文本流入方向有继承获得）</td></tr></tbody></table><p><code>text-overflow</code>：实现文本溢行处理，<code>word-break: break-all</code>来实现浏览器文本的换行</p><p>多行文本怎么实现文本溢出…,在webkit内核<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">display: -webkit-box</div><div class="line">-webkit-line-clamp: 2</div><div class="line">-webkit-box-orient: vertical</div></pre></td></tr></table></figure></p><h1 id="指定过渡属性transition-property"><a href="#指定过渡属性transition-property" class="headerlink" title="指定过渡属性transition-property"></a>指定过渡属性transition-property</h1><ul><li>none： 没有指定任何样式。</li><li>all：默认值，表示指定元素所有支持transition-property属性的样式。</li><li><code>&lt;single-transition-property&gt;</code>：指定样式，其等于all或者<ident>。</ident></li><li>颜色属性</li><li>具有长度值</li><li>integer（离散步骤，整个数字，在真实的数字空间，以及使用floor()转换为整数时发生，如outline-offset，z-index）</li><li>number</li><li>变形系列属性</li><li>rectangle（通过x，y，width，height（转为数值）变换，如crop属性）</li><li>visibility（离散步骤，在0~1范围内。0表示隐藏，1表示完全显示）</li><li>阴影（shadow，如text-shadow）</li><li>渐变（gradient）：通过每次停止时的位置和颜色进行变化。</li><li>paint server(SVG)</li><li>space-separated list of above</li><li>缩写属性</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记一下上个月看的图解CSS的一些简单的知识点哈。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://hddhyq.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://hddhyq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JS-this和原型对象</title>
    <link href="https://hddhyq.github.io/2018/05/14/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-this%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>https://hddhyq.github.io/2018/05/14/你不知道的JS-this和原型对象/</id>
    <published>2018-05-14T07:11:34.000Z</published>
    <updated>2018-07-08T04:25:55.519Z</updated>
    
    <content type="html"><![CDATA[<p>这里我总结了下，《你不知道的javaScript上卷》第二部分的内容，总结的可能比较简短，相关的知识点，与设计模式中间有重合，设计模式中的相关设计模式，后期也会补上。<br><a id="more"></a></p><h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h1><h2 id="为什么要用this呢？"><a href="#为什么要用this呢？" class="headerlink" title="为什么要用this呢？"></a>为什么要用this呢？</h2><p>如果没有this，我们需要调用变量名，才能在函数或者方法中调用相关它自己，如果有了this，我们就能用一种更优雅的方式“传递”一个对象的引用。因此可以将API设计的更加简洁并且易于复用。</p><p>随着你使用的模式越来越复杂，显示传递上下文对象会使代码变得越来越混乱，使用this则不会这样。</p><h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><p>关于两种常见的对于this的解释，但是他们都是错误的。</p><h3 id="指向自身"><a href="#指向自身" class="headerlink" title="指向自身"></a>指向自身</h3><p>很多人很容易吧this联想到它的英文意思，指向函数本身，但是this的绑定是动态的！</p><p>看一个例子吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</div><div class="line">  <span class="comment">// 记录 foo 被调用的次数</span></div><div class="line">  <span class="keyword">this</span>.count++;</div><div class="line">&#125;</div><div class="line">foo.count = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> i;</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</div><div class="line">    foo( i );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// foo: 6</span></div><div class="line"><span class="comment">// foo: 7</span></div><div class="line"><span class="comment">// foo: 8</span></div><div class="line"><span class="comment">// foo: 9</span></div><div class="line"><span class="comment">// foo 被调用了多少次？</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 0 -- WTF?</span></div></pre></td></tr></table></figure><p>上面的this绑定到哪里了呢？答案是全局。</p><h3 id="它的作用域"><a href="#它的作用域" class="headerlink" title="它的作用域"></a>它的作用域</h3><p>第二种常见的误解是，this指向函数的作用域。</p><p>再看一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="keyword">this</span>.bar();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(); <span class="comment">// ReferenceError: a is not defined</span></div></pre></td></tr></table></figure><p>这里我们既想用词法作用域，又想调用this来引入我们想用的函数体的变量。</p><p>这里稍微解析一下， <code>this.bar()</code> 引用的是外部的全局的 <code>bar()</code> 函数，这样里面的语句， <code>console.log(this.a)</code> 查找的也是全局的 <code>a</code> 变量。我们知道函数定义的 <code>a</code> 变量是影响不了全局的 <code>a</code> 变量的。所以这里我们会抛出一个引用错误。</p><h3 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h3><p>排除了错误的理解后，我们看看this到底是什么样的机制。</p><p>之前我们说过this是在运行时进行绑定的，并不是在编写时绑定，他的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置灭有任何关系，只取决于函数的调用方式。</p><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等消息。this就是记录的其中一个属性，会在函数执行的过程中用到。</p><p>下一章我们会学习如何寻找函数的滴啊用位置，从而判断函数在执行的过程中会如何绑定this。</p><h1 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h1><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>就像前面说的，调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个this到底引用的是什么？</p><p>通常来说，寻找滴啊用位置就是寻找“函数被调用的位置”，但是做起来没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。</p><p>最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当前调用栈是：baz</span></div><div class="line">  <span class="comment">// 因此，当前调用位置是全局作用域</span></div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"baz"</span> );</div><div class="line">  bar(); <span class="comment">// &lt;-- bar 的调用位置</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当前调用栈是 baz -&gt; bar</span></div><div class="line">  <span class="comment">// 因此，当前调用位置在 baz 中</span></div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"bar"</span> );</div><div class="line">  foo(); <span class="comment">// &lt;-- foo 的调用位置</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></div><div class="line">  <span class="comment">// 因此，当前调用位置在 bar 中 // 这里放一个断点可以查看当前调用栈，倒数第二个就是真正的调用位置。</span></div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"foo"</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line">baz(); <span class="comment">// &lt;-- baz 的调用位置</span></div></pre></td></tr></table></figure><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><p>这里也简要的解释四种规则：</p><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h3><p>最常用的函数调用类型：独立函数调用。可以把这条规则看做是无法应用其他规则时的默认规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">foo(); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>怎么知道应用了默认绑定呢？可以通过调用位置来看看 <code>foo()</code> 是如何调用的。在代码中，<code>foo()</code>是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。如果使用严格模式，将默认无法使用默认绑定的，因为this会绑定为undefined。</p><h3 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h3><p>另一种需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。</p><p>常见的对象的方法，就是隐式绑定。对象属性引用链只有最顶层或者说最后一层会影响调用位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  a: <span class="number">42</span>,</div><div class="line">  foo: foo</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  obj2: obj2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj1.obj2.foo(); <span class="comment">// 42</span></div></pre></td></tr></table></figure><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>因为this的绑定会根据runtime，所以，思考下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = obj.foo;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">"全局对象a"</span>;</div><div class="line"></div><div class="line">bar(); <span class="comment">// 全局对象a</span></div></pre></td></tr></table></figure><p>还有一种是常见的回调函数中的this隐式丢失，看下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a 是全局对象的属性</span></div><div class="line"></div><div class="line">setTimeout( obj.foo, <span class="number">100</span> ); <span class="comment">// "oops, global"</span></div><div class="line"></div><div class="line"><span class="comment">// JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn,delay</span>) </span>&#123;</div><div class="line">  <span class="comment">// 等待 delay 毫秒</span></div><div class="line">  fn(); <span class="comment">// &lt;-- 调用位置！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来，我们会介绍相关的通过固定this来fix,this所指向的对象或者说上下文context。</p><h3 id="3-显示绑定"><a href="#3-显示绑定" class="headerlink" title="3. 显示绑定"></a>3. 显示绑定</h3><p>分析隐式绑定时，我们必须在一个对象的内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上。</p><p>我们可以通过call(..)和apply(..)方法，来在某个函数中强制指定到this的上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.call( obj ); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p><h4 id="1-硬绑定"><a href="#1-硬绑定" class="headerlink" title="1. 硬绑定"></a>1. 硬绑定</h4><p>思考下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  foo.call(obj);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  foo.call(obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这里，我们在 <code>bar</code> 内部实现了一个 <code>foo.call(obj)</code>，因此强制把 <code>foo</code> 的 <code>this</code> 绑定到了 <code>obj</code> 。无论之后如何调用函数 <code>bar</code> ，它总会在 <code>obj</code> 上调用 <code>foo</code> 。这种绑定是一种显式的强制绑定，因此我们称之为 <strong>硬绑定</strong>。</p><p>ES5中提供了内置的方法，<strong>Function.prototype.bind</strong></p><h4 id="2-API调用的“上下文”"><a href="#2-API调用的“上下文”" class="headerlink" title="2. API调用的“上下文”"></a>2. API调用的“上下文”</h4><p>第三方库的许多函数，以及 <strong>JavaScript</strong> 语言和宿主环境中许多新的内置函数，都提供了一<br>个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调<br>函数使用指定的 <code>this</code>。</p><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( el, <span class="keyword">this</span>.id );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  id: <span class="string">"awesome"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 调用 foo(..) 时把 this 绑定到 obj</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj );</div><div class="line"><span class="comment">// 1 awesome 2 awesome 3 awesome</span></div></pre></td></tr></table></figure></p><p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些<br>代码。</p><h3 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4. new绑定"></a>4. new绑定</h3><p>在JavaScript中，构造函数只是一些使用 <code>new</code> 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至不能说是一种特殊的函数类型，它们只是被 <code>new</code> 操作符调用的普通函数。</p><p>使用 <code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li>创建（或者说构造）一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的 <code>this</code> 。</li><li>如果函数没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象。</li></ol><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ol><li>函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。</li><li>函数是否通过call、apply（显示绑定）或者硬绑定调用？如果是的话，this绑定的是制定的对象。</li><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。</li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。</li></ol><h2 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h2><p>在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用<br>的可能是默认绑定规则。</p><h3 id="1-被忽略的this"><a href="#1-被忽略的this" class="headerlink" title="1. 被忽略的this"></a>1. 被忽略的this</h3><p>如果你把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用的时候会被忽略，实际应用的是默认绑定规则。</p><p>如果函数并不关心this的话，你仍然需要传入一个占位符，常见的就是用null，可是这里用null来忽略this绑定可能会产生一些副作用。如果这个函数中确实使用了this，那默认绑定规则会把this绑定到全局对象，在浏览器这个对象是window，这将产生不可预计的后果。</p><p><strong>更安全的this</strong></p><p>一种“更安全”的做法是，闯入一个特殊的对象，常见方法，<code>Object.create(null)</code>。如果引入的是这个空对象，这样就比较安全了，这样很明确的表示this是空，即使函数中调用了this，也不会更改全局对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = <span class="number">200</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line"></div><div class="line">foo.call(ø)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a)</div><div class="line"><span class="comment">// 200 2</span></div></pre></td></tr></table></figure><h3 id="2-间接引用"><a href="#2-间接引用" class="headerlink" title="2. 间接引用"></a>2. 间接引用</h3><p>另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这<br>种情况下，调用这个函数会应用默认绑定规则。</p><p>常见的就是赋值的时候发生。</p><p>注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则this 会被绑定到全局对象。</p><h3 id="3-软绑定"><a href="#3-软绑定" class="headerlink" title="3. 软绑定"></a>3. 软绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">// 捕获所有 curried 参数</span></div><div class="line">    <span class="keyword">var</span> curried = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> fn.apply(</div><div class="line">          (!<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global)) ?</div><div class="line">            obj : <span class="keyword">this</span></div><div class="line">          curried.concat.apply( curried, <span class="built_in">arguments</span> )</div><div class="line">      );</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    bound.prototype = <span class="built_in">Object</span>.create( fn.prototype );</div><div class="line">    <span class="keyword">return</span> bound;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>softBind(..)</code>的其他原理和ES5内置的bind(..)类似。它会对制定函数进行封装，首先会检查调用时的this，如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this，否则不会修改this。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"name: "</span> + <span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"obj"</span> &#125;,</div><div class="line">    obj2 = &#123; <span class="attr">name</span>: <span class="string">"obj2"</span> &#125;,</div><div class="line">    obj3 = &#123; <span class="attr">name</span>: <span class="string">"obj3"</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fooOBJ = foo.softBind( obj );</div><div class="line"></div><div class="line">fooOBJ(); <span class="comment">// name: obj</span></div><div class="line"></div><div class="line">obj2.foo = foo.softBind(obj);</div><div class="line"></div><div class="line">obj2.foo(); <span class="comment">// name: obj2 &lt;---- 看！！！</span></div><div class="line"></div><div class="line">fooOBJ.call( obj3 ); <span class="comment">// name: obj3 &lt;---- 看！</span></div><div class="line"></div><div class="line">setTimeout( obj2.foo, <span class="number">10</span> );</div><div class="line"><span class="comment">// name: obj &lt;---- 应用了软绑定</span></div></pre></td></tr></table></figure></p><h2 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h2><p>这里介绍一下箭头函数: <code>() =&gt; {}</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  a: <span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  a: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = foo.call(obj1);</div><div class="line">bar.call(obj2);</div></pre></td></tr></table></figure></p><p><code>foo()</code> 内部创建的箭头函数会捕获调用时<code>foo()</code>的this。由于 <code>foo()</code> 的this绑定到obj1，bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。（new也不行！）</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>两种形式的定义：声明（文字）形式和构造形式。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>了解一下，简单基本类型：<code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>和<code>undefined</code>。null有时会被当做一种对象类型，但是这其实只是语言本身的一个bug。</p><p>JS中有很多复杂基本类型。这些是一些特殊的对象子类型。函数就是对象的一个子类型（从技术角度来说就是“可调用的对象”）</p><p>Javascript中的函数是“一等公民”，因为它们本质上和普通的对象一样（只是可以调用），所以可以像操作其他对象一样操作函数（比如当做另一个函数的参数）。</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>内置对象有：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Object</code>、<code>Function</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code>和<code>Error</code>。</p><p>关于字面量的基本类型调用 <code>Object.prototype.toString()</code> 都会转化成对应的包装类型。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>内容听名字似乎存储在对象内部，其实在语言中，这些值的储存方式是多种多样的，一般不会存在对象容器的内部。存储在对象容器的内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置。</p><p><code>.a</code>通常指的是属性访问，[“a”] 语法通常被称为“键访问”。在 <code>[&quot;..&quot;]</code> 语法使用字符串来访问属性，所以可以在程序中构造这个字符串。</p><h3 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> prefix = <span class="string">"foo"</span>;</div><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">  [prefix + <span class="string">"bar"</span>]: <span class="string">"hello"</span>,</div><div class="line">  [prefix + <span class="string">"baz"</span>]: <span class="string">"world"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject[<span class="string">"foobar"</span>]; <span class="comment">// hello</span></div><div class="line">myObject[<span class="string">"foobaz"</span>]; <span class="comment">// world</span></div></pre></td></tr></table></figure><h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><p>如果访问的对象是一个函数，在JS中，我们喜欢称之为 “方法”，实际上呢，这个所谓的“方法”也仅仅是对方法的引用。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组支持[]访问形式，不过数组期待的是数字下标。所以你添加的属性值并不会使数组的<code>length</code>变长。你完全可以把数组当做一个普通的键/值对来使用。</p><p>而且要注意了：<strong>如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成<br>一个数值下标（因此会修改数组的内容而不是添加一个属性）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [ <span class="string">"foo"</span>, <span class="number">42</span>, <span class="string">"bar"</span> ];</div><div class="line"></div><div class="line">myArray[<span class="string">"3"</span>] = <span class="string">"baz"</span>;</div><div class="line"></div><div class="line">myArray.length; <span class="comment">// 4</span></div><div class="line"></div><div class="line">myArray[<span class="number">3</span>]; <span class="comment">// "baz"</span></div></pre></td></tr></table></figure><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>复制不可避免需要讨论到的就是深拷贝和浅拷贝。</p><p>对于JSON安全的对象，这有一种方法可以用：<code>var newObj = JSON.parse( JSON.stringify( someObj ) );</code></p><p>ES6中定义的 <code>Object.assign(..)</code> 可以用在浅拷贝上，<code>Object.assign(..)</code> 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或者多个源对象。它会遍历一个或多个源对象的多有自由键并把它们复制（使用 = 操作符赋值）到目标对象，最后返回目标对象。</p><h4 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h4><p>在ES5之前，JavaScript语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">a:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor( myObject, <span class="string">"a"</span> );</div><div class="line"></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">// value: 2,</span></div><div class="line"><span class="comment">// writable: true,</span></div><div class="line"><span class="comment">// enumerable: true,</span></div><div class="line"><span class="comment">// configurable: true</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptor(..)</code>和<code>Object.defineProperty(..)</code>了解一下。</p><p>常见配置：</p><ol><li>Writable 是否可以修改属性的值</li><li>Configurable 只要属性是可配置的，就可以使用 <code>defineProperty(..)</code> 方法来修改属性描述符。关于<code>Configurable</code>配置为false，<code>writable</code>可以由<code>true</code>变为<code>false</code>，并且不能再变回来啦！操作不可逆哈。</li><li>Enumerable 最后一个属性描述符（还有两个，我们会在介绍 getter 和 setter 时提到）<br>是 <code>enumerable</code>。</li></ol><p>放一下总结好了，这本书就总结到这里了：</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>JavaScript 中的对象有字面形式（比如 var a = { .. }）和构造形式（比如 var a = newArray(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。</p><p>许多人都以为“JavaScript 中万物都是对象”，这是错误的。对象是 6 个（或者是 7 个，取决于你的观点）基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。</p><p>对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作（在设置属性值时是 [[Put]]），[[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]]链（参见第 5 章）。</p><p>属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象（及其属性）的不可变性级别。</p><p>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。</p><p>你可以使用 ES6 的 for..of 语法来遍历数据结构（数组、对象，等等）中的值，for..of会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里我总结了下，《你不知道的javaScript上卷》第二部分的内容，总结的可能比较简短，相关的知识点，与设计模式中间有重合，设计模式中的相关设计模式，后期也会补上。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="你不知道的JS" scheme="https://hddhyq.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式与开发实践（一）</title>
    <link href="https://hddhyq.github.io/2018/05/02/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hddhyq.github.io/2018/05/02/JavaScript设计模式与开发实践（一）/</id>
    <published>2018-05-02T14:34:41.000Z</published>
    <updated>2018-07-08T04:25:55.512Z</updated>
    
    <content type="html"><![CDATA[<p>全书分为三部分，基础知识，设计模式，设计原则和编程技巧<br>下面我会简单的总结书中的一些有用的设计模式。<br><a id="more"></a><br><strong>第一部分 基础知识</strong></p><p>这一部分，我会快速总结相关的一些知识点，包括</p><ul><li>面向对象的JavaScript</li><li>this,call和apply</li><li>闭包和高阶函数</li></ul><h1 id="面向对象的JavaScript"><a href="#面向对象的JavaScript" class="headerlink" title="面向对象的JavaScript"></a>面向对象的JavaScript</h1><p>首先我们要了解一些基本概念，关于动态类型语言，鸭子类型，原型委托和多态以及原型模式等。</p><h2 id="动态类型语言和鸭子模式"><a href="#动态类型语言和鸭子模式" class="headerlink" title="动态类型语言和鸭子模式"></a>动态类型语言和鸭子模式</h2><p>所谓动态类型语言，必定是相对于静态类型语言所做的比较。</p><ul><li>静态类型语言的优点首先是在编译时就能发现类型不匹配的错误,编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。静态类型语言的缺点首先是迫使程序员依照强契约来编写程序,为每个变量规定数据类型。</li><li>动态类型语言的优点是编写的代码数量更少,看起来也更加简洁,程序员可以把精力更多地放在业务逻辑上面。动态类型语言的缺点是无法保证变量的类型,从而在程序的运行期有可能发生跟类型相关的错误。</li></ul><p>动态语言对变量类型的宽容建立在 <strong>鸭子类型(duck typing)</strong> 的概念。</p><p>所谓鸭子类型的主要思想就是：我们只需要关注对象的行为，或者叫需要对象实现的功能，而不需要关注对象本身。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的实际含义是:同一操作作用于不同的对象上面,可以产生不同的解释和不同的执行结果。换句话说,给不同的对象发送同一个消息的时候,这些对象会根据这个消息分别给出不同的反馈。</p><p>静态语言中，多态的实现需要抽象一个超类，通过继承来实现。</p><p>多态的思想主要是“做什么”和“谁去做”，这样我们就能消除类型之间的耦合关系，完成多态的实现。</p><p>多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性,从而消除这些条件分支语句。</p><p>下面来看一段简单的渲染map的代码，实现多态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> googleMap = &#123;</div><div class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染谷歌地图'</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> baiduMap = &#123;</div><div class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染百度地图'</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params"> map </span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> ( map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span> )&#123;</div><div class="line">        map.show();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">renderMap( googleMap );</div><div class="line">renderMap( baiduMap );</div><div class="line"></div><div class="line"><span class="comment">// 我们需要一个添加新的地图渲染，就死添加一个新的对象就行了，避免判断</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> sosoMap = &#123;</div><div class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染搜搜地图'</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">renderMap( sosoMap );</div></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在 JavaScript 或者其他语言中，封装有很多含义，不仅仅限定于封装数据，只要是将数据隐藏的“任何形式的封装”，我们都能够称之为封装。在 JS 中，我们常见的封装的封装形式就是作用域及闭包了。封装失对象之间的耦合变松散，我们只需要关注对象之间暴露的API，来实现所需功能了。</p><p>《设计模式》中有一段话用来描述封装</p><blockquote><p>“ 考虑你的设计中哪些地方可能变化,这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变,而是考虑你怎样才能够在不重新设计的情况下进行改变。这里的关键在于封装发生变化的概念,这是许多设计模式的主题。”</p></blockquote><p>这段话的核心也就是封装的本质， <strong>“找到变化并封装之”</strong>。</p><h2 id="原型模式和基于原型继承的-JavaScript-对象系统"><a href="#原型模式和基于原型继承的-JavaScript-对象系统" class="headerlink" title="原型模式和基于原型继承的 JavaScript 对象系统"></a>原型模式和基于原型继承的 JavaScript 对象系统</h2><p>如同题目所示，原型模式早就融入到 JavaScript 中了。原型模式不单是一种设计模式,也被称为一种编程泛型。</p><p>原型模式是用于创建对象的一种模式。原型模式的核心就是克隆，原型模式的关键也是语言本身是否提供 clone 方法。ECMAScript 5 提供了 Object.create方法,可以用来克隆对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Plane = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.blood = <span class="number">100</span>;</div><div class="line">    <span class="keyword">this</span>.attackLevel = <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.defenseLevel = <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> Plane();</div><div class="line">plane.blood = <span class="number">500</span>;</div><div class="line">plane.attackLevel = <span class="number">10</span>;</div><div class="line">plane.defenseLevel = <span class="number">7</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> clonePlane = <span class="built_in">Object</span>.create( plane );</div><div class="line"><span class="built_in">console</span>.log( clonePlane );<span class="comment">// 输出:Object &#123;blood: 500, attackLevel: 10, defenseLevel: 7&#125;</span></div></pre></td></tr></table></figure><p>不支持Object.create 方法的浏览器中,则可以使用以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.create = <span class="built_in">Object</span>.create || <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">    F.prototype = obj;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>JavaScript中的原型继承</strong></p><p>JavaScript遵循着一些原型编程的基本规则：</p><ul><li>所有的数据都是对象。</li><li>要得到一个对象,不是通过实例化类,而是找到一个对象作为原型并克隆它。</li><li>对象会记住它的原型。</li><li>如果对象无法响应某个请求,它会把这个请求委托给它自己的原型。</li></ul><ol><li><p>所有的数据都是对象</p><p> JavaScript 在设计的时候,模仿 Java 引入了两套类型机制:基本类型和对象类型。基本类型包括 undefined 、 number 、 boolean 、 string 、 function 、 object 。从现在看来,这并不是一个好的想法。</p><p> 按照 JavaScript 设计者的本意,除了 undefined 之外,一切都应是对象。为了实现这一目标,number 、 boolean 、 string 这几种基本类型数据也可以通过“包装类”的方式变成对象类型数据来处理。</p><p> 我们不能说在 JavaScript 中所有的数据都是对象,但可以说绝大部分数据都是对象。那么相信在 JavaScript 中也一定会有一个根对象存在,这些对象追根溯源都来源于这个根对象。</p><p> 事实上,JavaScript 中的根对象是 Object.prototype 对象。 Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象,实际上都是从 Object.prototype 对象克隆而来的,Object.prototype 对象就是它们的原型。比如下面的 obj1 对象和 obj2 对象:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</div></pre></td></tr></table></figure><p> 可以利用 ECMAScript 5 提供的 Object.getPrototypeOf 来查看这两个对象的原型:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( obj1 ) === <span class="built_in">Object</span>.prototype ); <span class="comment">// 输出:true</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( obj2 ) === <span class="built_in">Object</span>.prototype ); <span class="comment">// 输出:true</span></div></pre></td></tr></table></figure></li><li><p>要得到一个对象,不是通过实例化类,而是找到一个对象作为原型并克隆它</p><p> 了解下，我们new运算符从构造琦中得到一个对象的过程。</p><p> 当使用 new 运算符来调用函数时,此时的函数就是一个构造器。 用new 运算符来创建对象的过程,实际上也只是先克隆 Object.prototype 对象,再进行一些其他额外操作的过程。</p></li><li><p>对象会记住它的原型</p><p> 就 JavaScript 的真正实现来说，其实不能说对象有原型，而至能说对象的构造器有原型。对于”对象吧把请求委托给它自己的原型“这句话，更好的说法是对象委托给它的构造器的原型。那么队形如何把请求顺利的转交给它的构造器的原型呢？</p><p> JavaScript 给对象提供了一个名为 <strong>proto</strong> 的隐藏属性,某个对象的 <strong>proto</strong> 属性默认会指向它的构造器的原型对象,即 {Constructor}.prototype 。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="built_in">console</span>.log ( a.__proto__=== <span class="built_in">Object</span>.prototype );</div><div class="line"><span class="comment">// 输出:true</span></div></pre></td></tr></table></figure><p> 实际上, <strong>proto</strong> 就是对象跟“对象构造器的原型”联系起来的纽带。正因为对象要通过<strong>proto</strong> 属性来记住它的构造器的原型,所以我们用上一节的 objectFactory 函数来模拟用 new创建对象时, 需要手动给 obj 对象设置正确的 <strong>proto</strong> 指向。</p></li><li><p>如果对象无法响应某个请求,它会把这个请求委托给它的构造器的原型</p><p> 这条规则即是原型继承的精髓所在。</p><p> 在 JavaScript 中,每个对象都是从 Object.prototype 对象克隆而来的,如果是这样的话,我们只能得到单一的继承关系,即每个对象都继承自 Object.prototype 对象,这样的对象系统显然是非常受限的。</p><p> 实际上,虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的,但对象构造器的原型并不仅限于 Object.prototype 上,而是可以动态指向其他对象。这样一来,当对象 a 需要借用对象 b 的能力时,可以有选择性地把对象 a 的构造器的原型指向对象 b ,从而达到继承的效果。下面的代码是我们最常用的原型继承方式:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">A.prototype = obj;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log( a.name );</div></pre></td></tr></table></figure><p> 我们来看看执行这段代码的时候,引擎做了哪些事情。</p><ul><li>首先,尝试遍历对象 a 中的所有属性,但没有找到 name 这个属性。</li><li>查找 name 属性的这个请求被委托给对象 a 的构造器的原型,它被 a. <strong>proto</strong> 记录着并且<br>指向 A.prototype ,而 A.prototype 被设置为对象 obj 。</li><li><p>在对象 obj 中找到了 name 属性,并返回它的值。</p><p>当我们期望得到一个“类”继承自另外一个“类”的效果时,往往会用下面的代码来模拟实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">A.prototype = &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">B.prototype = <span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line"><span class="built_in">console</span>.log( b.name ); <span class="comment">// 输出:sven</span></div></pre></td></tr></table></figure><p>再看这段代码执行的时候,引擎做了什么事情。</p></li><li><p>首先,尝试遍历对象 b 中的所有属性,但没有找到 name 这个属性。</p></li><li>查找 name 属性的请求被委托给对象 b 的构造器的原型,它被 b. <strong>proto</strong> 记录着并且指向B.prototype ,而 B.prototype 被设置为一个通过 new A() 创建出来的对象。</li><li>在该对象中依然没有找到 name 属性,于是请求被继续委托给这个对象构造器的原型A.prototype 。</li><li>在 A.prototype 中找到了 name 属性,并返回它的值。</li></ul></li></ol><h2 id="this-、-call-和-apply"><a href="#this-、-call-和-apply" class="headerlink" title="this 、 call 和 apply"></a>this 、 call 和 apply</h2><p>在 JavaScript 的this总是指向一个对象，而具体指向那个对象是运行时 <strong>基于函数的执行环境动态绑定的</strong>，而非函数被声明时的环境。</p><h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><p>除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下四种。</p><ul><li>作为对象的方法调用。</li><li>作为普通函数调用。</li><li>构造器调用。</li><li>Function.prototype.call 或 Function.prototype.apply 调用。</li></ul><h3 id="1-作为对象的方法调用"><a href="#1-作为对象的方法调用" class="headerlink" title="1. 作为对象的方法调用"></a>1. 作为对象的方法调用</h3><p>当函数作为对象的方法被调用时，this指向该对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span> === obj); <span class="comment">// 输出：true</span></div><div class="line">        alert ( <span class="keyword">this</span>.a ); <span class="comment">// 输出: 1 </span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.getA();</div></pre></td></tr></table></figure><h3 id="2-作为普通函数调用"><a href="#2-作为普通函数调用" class="headerlink" title="2. 作为普通函数调用"></a>2. 作为普通函数调用</h3><p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指<br>向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getName());  <span class="comment">// globalName</span></div></pre></td></tr></table></figure><p>注意一下，下面这个例子阐释了this在runtime定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">    name: <span class="string">'sven'</span>,</div><div class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> getName = myObject.getName;</div><div class="line"><span class="built_in">console</span>.log(getName());    <span class="comment">// globalName</span></div></pre></td></tr></table></figure></p><h3 id="3-构造器调用"><a href="#3-构造器调用" class="headerlink" title="3. 构造器调用"></a>3. 构造器调用</h3><p>JavaScript 中没有类，但是能通过 new 运算符从构造器中创建对象。</p><p>除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象，见如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</div><div class="line">alert(obj.name); <span class="comment">// anne</span></div></pre></td></tr></table></figure></p><p>但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span>,</div><div class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 显式地返回一个对象</span></div><div class="line">        name: <span class="string">'anne'</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</div><div class="line">alert(obj.name);</div></pre></td></tr></table></figure><p>如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'anne'</span>; <span class="comment">// 返回 string 类型</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</div><div class="line">alert ( obj.name ); <span class="comment">// 输出：sven</span></div></pre></td></tr></table></figure></p><h3 id="4-Function-prototype-call-或-Function-prototype-apply-调用"><a href="#4-Function-prototype-call-或-Function-prototype-apply-调用" class="headerlink" title="4.  Function.prototype.call 或 Function.prototype.apply 调用"></a>4.  Function.prototype.call 或 Function.prototype.apply 调用</h3><p>跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    name: <span class="string">'sven'</span>,</div><div class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">    name: <span class="string">'anne'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( obj1.getName() ); <span class="comment">// 输出: sven</span></div><div class="line"><span class="built_in">console</span>.log( obj1.getName.call( obj2 ) ); <span class="comment">// 输出：anne</span></div></pre></td></tr></table></figure><h3 id="丢失的this"><a href="#丢失的this" class="headerlink" title="丢失的this"></a>丢失的this</h3><p>何为丢失的this呢？</p><p>其实主要this的指向是runtime的，前面的对象的方法的函数在外部调用也是这个意思哈。</p><h3 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h3><p>call和apply的区别主要就是在传入的参数形式不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> a, b, c </span>)</span>&#123;</div><div class="line">    alert ( [ a, b, c ] ); <span class="comment">// 输出 [ 1, 2, 3 ]</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">func.apply( <span class="literal">null</span>, [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] ); </div><div class="line"></div><div class="line">func.call( <span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> );</div></pre></td></tr></table></figure><p><strong>call和apply的用途</strong></p><ol><li>改变 this 指向</li><li>Function.prototype.bind</li></ol><p>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><p>bind, 没错就是一个语法糖。当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。</p><ol start="3"><li>借用其他对象的方法<br>借用方法的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    A.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">&#125;;</div><div class="line">B.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B( <span class="string">'sven'</span> );</div><div class="line"><span class="built_in">console</span>.log( b.getName() ); <span class="comment">// 输出： 'sven'</span></div></pre></td></tr></table></figure></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">Array</span>.prototype.push.call( <span class="built_in">arguments</span>, <span class="number">3</span> );</div><div class="line">    <span class="built_in">console</span>.log ( <span class="built_in">arguments</span> ); <span class="comment">// 输出[1,2,3]</span></div><div class="line">&#125;)( <span class="number">1</span>, <span class="number">2</span> );</div></pre></td></tr></table></figure><p>想把 arguments 转成真正的数组的时候，可以借用 Array.prototype.slice 方法；想截去<br>arguments 列表中的头一个元素时，又可以借用 Array.prototype.shift 方法。那么这种机制的内<br>部实现原理是什么呢？我们不妨翻开 V8 的引擎源码，以 Array.prototype.push 为例，看看 V8 引<br>擎中的具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> n = TO_UINT32( <span class="keyword">this</span>.length ); <span class="comment">// 被 push 的对象的 length</span></div><div class="line">    <span class="keyword">var</span> m = %_ArgumentsLength(); <span class="comment">// push 的参数个数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">        <span class="keyword">this</span>[ i + n ] = %_Arguments( i ); <span class="comment">// 复制元素 (1)</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.length = n + m; <span class="comment">// 修正 length 属性的值 (2)</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>Array.prototype.slice 实现条件：</p><ul><li>对象本身要可以存取属性</li><li>对象的 length 属性可读写</li></ul><h2 id="闭包和高阶函数"><a href="#闭包和高阶函数" class="headerlink" title="闭包和高阶函数"></a>闭包和高阶函数</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>对于 JavaScript 程序员来说，闭包（closure）是一个难懂又必须征服的概念。闭包的形成与变量的作用域以及变量的生存周期密切相关。下面我们先简单了解这两个知识点。</p><h4 id="1-变量的作用域"><a href="#1-变量的作用域" class="headerlink" title="1. 变量的作用域"></a>1. 变量的作用域</h4><p>当再函数中声明一个变量的时候，如果该变量前面没有带上关键字var，这个变量就会成为全局变量。所以避免变量声明前面不加声明关键词。</p><h4 id="2-变量的生存周期"><a href="#2-变量的生存周期" class="headerlink" title="2. 变量的生存周期"></a>2. 变量的生存周期</h4><p>除了变量的作用域之外，另外一个跟闭包有关的概念是变量的生存周期。</p><p>对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。</p><p>而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        a++;</div><div class="line">        alert(a);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f = func();</div><div class="line"></div><div class="line">f(); <span class="comment">// 输出：2</span></div><div class="line">f(); <span class="comment">// 输出：3</span></div><div class="line">f(); <span class="comment">// 输出：4</span></div><div class="line">f(); <span class="comment">// 输出：5</span></div></pre></td></tr></table></figure><p>在这里我们推出函数后，局部变量 a 并没有消失，而是似乎一直在某个地方存活着。原因是：当执行 var发= function();时，f返回一个匿名函数的引用，它可以访问到func()被调用是产生的环境，而局部变量a一直处在这个环境里。既然局部变量所在环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里就产生了一个闭包结构，局部变量的生命看起来被延续了。</p><p>闭包的一个经典应用是之前var声明的循环遍历中使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">        setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(i)</div><div class="line">        &#125;)(j), <span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func() <span class="comment">// 0, 1, 2, 3, 4</span></div></pre></td></tr></table></figure></p><h4 id="闭包的更多作用"><a href="#闭包的更多作用" class="headerlink" title="闭包的更多作用"></a>闭包的更多作用</h4><ol><li><p>封装变量<br>闭包可以帮助把一些不需要暴露在全局的变量封装乘“私有变量”。假设一个计算乘积的简单函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> calculate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++) &#123;</div><div class="line">            a = a * <span class="built_in">arguments</span>[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">','</span>);</div><div class="line">        <span class="keyword">if</span> ( args <span class="keyword">in</span> cache )&#123;</div><div class="line">            <span class="keyword">return</span> cache[ args ];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cache[args] = calculate.apply( <span class="literal">null</span>, <span class="built_in">arguments</span> );</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></li><li><p>延续局部变量的寿命</p></li></ol><p>####　闭包和面向对象设计<br>过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程,而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能,用闭包也能实现。反之亦然。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 闭包写法</span></div><div class="line"><span class="keyword">var</span> extent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        call: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            value++;</div><div class="line">            <span class="built_in">console</span>.log(value)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> extent = extent();</div><div class="line"></div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line"></div><div class="line"><span class="comment">// 面向对象写法</span></div><div class="line"><span class="keyword">var</span> extent = &#123;</div><div class="line">    value: <span class="number">0</span>,</div><div class="line">    call: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line"></div><div class="line"><span class="comment">// 原型写法</span></div><div class="line"><span class="keyword">var</span> Extent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Extent.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value++;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> extent = <span class="keyword">new</span> Extent();</div><div class="line"></div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line">extent.call();</div></pre></td></tr></table></figure><p>关于闭包域内存管理，将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时,就会删除这些值并回收它们占用的内存。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是指至少满足下列条件之一的函数。</p><ul><li>函数可以作为参数被传递;</li><li>函数可以作为返回值输出。</li></ul><h4 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h4><p>把函数当作参数传递,这代表我们可以抽离出一部分容易变化的业务逻辑,把这部分业务逻辑放在函数参数中,这样一来可以分离业务代码中变化与不变的部分。其中一个重要应用场景就是常见的回调函数。</p><ol><li>回调函数</li><li>Array.prototype.sort</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span> ].sort( <span class="function"><span class="keyword">function</span>(<span class="params"> a, b </span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 输出: [ 1, 3, 4 ]</span></div></pre></td></tr></table></figure><h4 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h4><p>相比把函数当作参数传递,函数当作返回值输出的应用场景也许更多,也更能体现函数式编程的巧妙。让函数继续返回一个可执行的函数,意味着运算过程是可延续的。</p><h4 id="高阶函数实现AOP"><a href="#高阶函数实现AOP" class="headerlink" title="高阶函数实现AOP"></a>高阶函数实现AOP</h4><p>这一部分到后面装饰者模式再细讲。</p><h4 id="高阶函数的其他应用"><a href="#高阶函数的其他应用" class="headerlink" title="高阶函数的其他应用"></a>高阶函数的其他应用</h4><ol><li>currenying</li></ol><p>首先我们讨论的是函数柯里化。currying 又称部分求值。一个 currying 的函数首先会接受一些参数,接受了这些参数之后,该函数并不会立即求值,而是继续返回另外一个函数,刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候,之前传入的所有参数都会被一次性用于求值。</p><ol start="2"><li>uncurrying</li></ol><p>在 JavaScript 中，当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点，也是常说的鸭子类型思想。</p><p>同理，一个对象也未必只能使用它自身的方法，那么有什么办法可以让对象去借用一个原本不属于它的方法呢？</p><p>这里我们借用了一个泛化this的过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">return</span> self.apply(obj, <span class="built_in">arguments</span>)</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// var push = Array.prototype.push.uncurrying();</span></div><div class="line"></div><div class="line"><span class="comment">// (function() &#123;</span></div><div class="line"><span class="comment">//     push(arguments, 4);</span></div><div class="line"><span class="comment">//     console.log(arguments);</span></div><div class="line"><span class="comment">// &#125;)(1,2,3)</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, fn, arr = [<span class="string">'push'</span>, <span class="string">'shift'</span>, <span class="string">'forEach'</span>]; fn = arr[i++];) &#123;</div><div class="line">    <span class="built_in">Array</span>[fn] = <span class="built_in">Array</span>.prototype[fn].uncurrying();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;     </div><div class="line">    <span class="string">'length'</span>: <span class="number">3</span>,</div><div class="line">    <span class="string">'0'</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">'1'</span>: <span class="number">2</span>,</div><div class="line">    <span class="string">'2'</span>: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.push(obj, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(obj.length)</div></pre></td></tr></table></figure><ol start="3"><li>函数节流</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全书分为三部分，基础知识，设计模式，设计原则和编程技巧&lt;br&gt;下面我会简单的总结书中的一些有用的设计模式。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="设计模式" scheme="https://hddhyq.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS中排序和搜索算法</title>
    <link href="https://hddhyq.github.io/2018/02/23/JS%E4%B8%AD%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <id>https://hddhyq.github.io/2018/02/23/JS中排序和搜索算法/</id>
    <published>2018-02-23T06:51:34.000Z</published>
    <updated>2018-12-09T14:14:41.196Z</updated>
    
    <content type="html"><![CDATA[<p>看《学习JavaScript数据结构与算法》，总结了下常用的排序，如冒泡排序、选择排序、插入排序、归并排序和快速排序，以及顺序搜索和二分搜索算法。<br><a id="more"></a></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序算法之前，我们需要创建一个数组表示待排序和搜索的数据结构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayList</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> array = []; <span class="comment">//&#123;1&#125;</span></div><div class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    array.push(item);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.toString= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//&#123;3&#125;</span></div><div class="line">    <span class="keyword">return</span> array.join();</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序最简单，不过它的时间复杂度也是最大的。</p><p>冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length; <span class="comment">//&#123;1&#125;</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length; i++)&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;length<span class="number">-1</span>; j++ )&#123; <span class="comment">//&#123;3&#125;</span></div><div class="line">      <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>])&#123; <span class="comment">//&#123;4&#125;</span></div><div class="line">        swap(array, j, j+<span class="number">1</span>); <span class="comment">//&#123;5&#125;</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="keyword">var</span> swap = <span class="function"><span class="keyword">function</span>(<span class="params">array, index1, index2</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> aux = array[index1];</div><div class="line">  array[index1] = array[index2];</div><div class="line">  array[index2] = aux;</div><div class="line">&#125;; <span class="comment">// 一个私有函数，只能用在ArrayList类的内部代码中</span></div><div class="line"></div><div class="line"><span class="comment">// 可以用ES6的数组拓展</span></div><div class="line"><span class="comment">// [array[index1], array[index2]] = [array[index2], array[index1]];</span></div></pre></td></tr></table></figure><p>首先，声明一个名为length的变量，用来存储数组的长度（行{1}）。这一步可选，它能帮助我们在行{2}和行{3}时直接使用数组的长度。接着，外循环（行{2}）会从数组的第一位迭代至最后一位，它控制了在数组中经过多少轮排序（应该是数组中每项都经过一轮，轮数和数组长度一致）。然后，内循环将从第一位迭代至倒数第二位，内循环实际上进行当前项和下一项的比较（行{4}）。如果这两项顺序不对（当前项比下一项大），则交换它们（行{5}），意思是位置为j+1的值将会被换置到位置j处，反之亦然。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/冒泡算法.png" alt=""></p><p><strong>改进冒泡算法</strong><br>如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较。<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/改进冒泡算法.png" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.modifiedBubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;length<span class="number">-1</span>-i; j++ )&#123;</div><div class="line">      <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>])&#123;</div><div class="line">        swap(j, j+<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>最后，这个排序的事件复杂度是O(n²)。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, <span class="comment">//&#123;1&#125;</span></div><div class="line">    indexMin;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length<span class="number">-1</span>; i++)&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">      indexMin = i; <span class="comment">//&#123;3&#125;</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j=i; j&lt;length; j++)&#123; <span class="comment">//&#123;4&#125;</span></div><div class="line">      <span class="keyword">if</span>(array[indexMin]&gt;array[j])&#123; <span class="comment">//&#123;5&#125;</span></div><div class="line">        indexMin = j; <span class="comment">//&#123;6&#125;</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i !== indexMin)&#123; <span class="comment">//&#123;7&#125;</span></div><div class="line">    swap(i, indexMin);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>首先声明一些将在算法内使用的变量（行{1}）。接着，外循环（行{2}）迭代数组，并控制迭代轮次（数组的第n个值——下一个最小值）。我们假设本迭代轮次的第一个值为数组最小值（行{3}）。然后，从当前i的值开始至数组结束（行{4}），我们比较是否位置j的值比当前最小值小（行{5}）；如果是，则改变最小值至新最小值（行{6}）。当内循环结束（行{4}），将得出数组第n小的值。最后，如果该最小值和原最小值不同（行{7}），则交换其值。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/选择排序.png" alt=""></p><p>选择排序同样也是一个复杂度为O(n²)的算法。和冒泡排序一样，它包含有嵌套的两个循环，这导致了二次方的复杂度。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, <span class="comment">//&#123;1&#125;</span></div><div class="line">      j, temp;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;length; i++)&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    j = i; <span class="comment">//&#123;3&#125;</span></div><div class="line">    temp = array[i]; <span class="comment">//&#123;4&#125;</span></div><div class="line">    <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; array[j<span class="number">-1</span>] &gt; temp)&#123; <span class="comment">//&#123;5&#125;</span></div><div class="line">      array[j] = array[j<span class="number">-1</span>]; <span class="comment">//&#123;6&#125;</span></div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    array[j] = temp; <span class="comment">//&#123;7&#125;</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>算法的第一行用来声明代码中使用的变量（行{1}）。接着，迭代数组来给第i项找到正确的位置（行{2}）。注意，算法是从第二个位置（索引1）而不是0位置开始的（我们认为第一项已排序了）。然后，用i的值来初始化一个辅助变量（行{3}）并将其值亦存储于一临时变量中（行{4}），便于之后将其插入到正确的位置上。下一步是要找到正确的位置来插入项目。只要变量j比0大（因为数组的第一个索引是0——没有负值的索引）并且数组中前面的值比待比较的值大（行{5}），我们就把这个值移到当前位置上（行{6}）并减小j。最终，该项目能插入到正确的位置上。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/插入排序.png" alt=""></p><p>排序小型数组时，此算法比选择排序和冒泡排序性能要好。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是第一个可以被实际使用的排序算法。，其复杂度为O(nlogⁿ)。</p><blockquote><p>JavaScript的Array类定义了一个sort函数（Array.prototype.sort）用以排序JavaScript数组（我们不必自己实现这个算法）。ECMAScript没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox使用归并排序作为Array.prototype.sort的实现，而Chrome使用了一个快速排序（下面我们会学习的）的变体。</p></blockquote><p>归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  array = mergeSortRec(array);</div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="keyword">var</span> mergeSortRec = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length;</div><div class="line">  <span class="keyword">if</span>(length === <span class="number">1</span>) &#123; <span class="comment">//&#123;1&#125;</span></div><div class="line">    <span class="keyword">return</span> array; <span class="comment">//&#123;2&#125;</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>), <span class="comment">//&#123;3&#125;</span></div><div class="line">    left = array.slice(<span class="number">0</span>, mid), <span class="comment">//&#123;4&#125;</span></div><div class="line">    right = array.slice(mid, length); <span class="comment">//&#123;5&#125;</span></div><div class="line">  <span class="keyword">return</span> merge(mergeSortRec(left), mergeSortRec(right)); <span class="comment">//&#123;6&#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>归并排序将一个大数组转化为多个小数组直到只有一个项。由于算法是递归的，我们需要一个停止条件，在这里此条件是判断数组的长度是否为1（行{1}）。如果是，则直接返回这个长度为1的数组（行{2}），因为它已排序了。</p><p>如果数组长度比1大，那么我们得将其分成小数组。为此，首先得找到数组的中间位（行{3}），找到后我们将数组分成两个小数组，分别叫作left（行{4}）和right（行{5}）。left数组由索引0至中间索引的元素组成，而right数组由中间索引至原始数组最后一个位置的元素组成。</p><p>下面的步骤是调用merge函数（行{6}），它负责合并和排序小数组来产生大数组，直到回到原始数组并已排序完成。为了不断将原始数组分成小数组，我们得再次对left数组和right数组递归调用mergeSortRec，并同时作为参数传递给merge函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> result = [], <span class="comment">// &#123;7&#125;</span></div><div class="line">      il = <span class="number">0</span>,</div><div class="line">      ir = <span class="number">0</span>; </div><div class="line">  <span class="keyword">while</span>(il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; <span class="comment">// &#123;8&#125;</span></div><div class="line">    <span class="keyword">if</span>(left[il] &lt; right[ir]) &#123;</div><div class="line">      result.push(left[il++]); <span class="comment">// &#123;9&#125;</span></div><div class="line">    &#125; <span class="keyword">else</span>&#123;</div><div class="line">      result.push(right[ir++]); <span class="comment">// &#123;10&#125;</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (il &lt; left.length)&#123; <span class="comment">// &#123;11&#125;</span></div><div class="line">    result.push(left[il++]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (ir &lt; right.length)&#123; <span class="comment">// &#123;12&#125;</span></div><div class="line">    result.push(right[ir++]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result; <span class="comment">// &#123;13&#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>merge函数接受两个数组作为参数，并将它们归并至一个大数组。排序发生在归并过程中。首先，需要声明归并过程要创建的新数组以及用来迭代两个数组（left和right数组）所需的两个变量（行{7}）。迭代两个数组的过程中（行{8}），我们比较来自left数组的项是否比来自right数组的项小。如果是，将该项从left数组添加至归并结果数组，并递增迭代数组的控制变量（行{9}）；否则，从right数组添加项并递增相应的迭代数组的控制变量（行{10}）。</p><p>接下来，将left数组或者right数组所有剩余的项添加到归并数组中（行{11}和行{12}）。最后，将归并数组作为结果返回（行{13}）。</p><p>如果执行mergeSort函数，下图是具体的执行过程：<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/归并排序.png" alt=""></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序也许是最常用的排序算法了。它的复杂度为O(nlogⁿ)，且它的性能通常比其他的复杂度为O(nlogⁿ)的排序算法要好。和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）。</p><p>快速排序比到目前为止你学过的其他排序算法要复杂一些。让我们一步步地来学习。</p><ol><li>首先，从数组中选择中间一项作为主元。</li><li>创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分操作。</li><li>接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.quickSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> quick(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>就像归并算法那样，开始我们声明一个主方法来调用递归函数，传递待排序数组，以及索引<br>0及其最末的位置（因为我们要排整个数组，而不是一个子数组）作为参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> quick = <span class="function"><span class="keyword">function</span>(<span class="params">array, left, right</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> index; <span class="comment">//&#123;1&#125;</span></div><div class="line">  <span class="keyword">if</span> (array.length &gt; <span class="number">1</span>) &#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    index = partition(array, left, right); <span class="comment">//&#123;3&#125;</span></div><div class="line">    <span class="keyword">if</span> (left &lt; index - <span class="number">1</span>) &#123; <span class="comment">//&#123;4&#125;</span></div><div class="line">      quick(array, left, index - <span class="number">1</span>); <span class="comment">//&#123;5&#125;</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (index &lt; right) &#123; <span class="comment">//&#123;6&#125;</span></div><div class="line">      quick(array, index, right); <span class="comment">//&#123;7&#125;</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>首先声明index（行{1}），该变量能帮助我们将子数组分离为较小值数组和较大值数组，这样，我们就能再次递归的调用quick函数了。partition函数返回值将赋值给index（行{3}）。</p><p>如果数组的长度比1大（因为只有一个元素的数组必然是已排序了的（行{2}），我们将对给定子数组执行partition操作（第一次调用是针对整个数组）以得到index（行{3}）。如果子数组存在较小值的元素（行{4}），则对该数组重复这个过程（行{5}）。同理，对存在较大值得子数组也是如此，如果存在子数组存在较大值，我们也将重复快速排序过程（行{7}）。</p><h3 id="1-划分过程"><a href="#1-划分过程" class="headerlink" title="1. 划分过程"></a>1. 划分过程</h3><p>第一件要做的事情是选择主元（pivot），有好几种方式。最简单的一种是选择数组的第一项（最左项）。然而，研究表明对于几乎已排序的数组，这不是一个好的选择，它将导致该算法的最差表现。另外一种方式是随机选择一个数组项或是选择中间项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span>(<span class="params">array, left, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> pivot = array[<span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)], <span class="comment">//&#123;8&#125;</span></div><div class="line">      i = left, <span class="comment">//&#123;9&#125;</span></div><div class="line">      j = right; <span class="comment">//&#123;10&#125;</span></div><div class="line">  <span class="keyword">while</span> (i &lt;= j) &#123; <span class="comment">//&#123;11&#125;</span></div><div class="line">    <span class="keyword">while</span> (array[i] &lt; pivot) &#123; <span class="comment">//&#123;12&#125;</span></div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (array[j] &gt; pivot) &#123; <span class="comment">//&#123;13&#125;</span></div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i &lt;= j) &#123; <span class="comment">//&#123;14&#125;</span></div><div class="line">      swap(array, i, j); <span class="comment">//&#123;15&#125;</span></div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> i; <span class="comment">//&#123;16&#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>在本实现中，我们选择中间项作为主元（行{8}）。我们初始化两个指针：left（低——行{9}），初始化为数组第一个元素；right（高——行{10}），初始化为数组最后一个元素。</p><p>只要left和right指针没有相互交错（行{11}），就执行划分操作。首先，移动left指针直到找到一个元素比主元大（行{12}）。对right指针，我们做同样的事情，移动right指针直到我们找到一个元素比主元小。</p><p>当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大（行{14}），意思是左项比右项大（值比较）。我们交换它们，然后移动两个指针，并重复此过程（从行{11}再次开始）。</p><p>在划分操作结束后，返回左指针的索引，用来在行{3}处创建子数组。</p><h3 id="2-快速排序实战"><a href="#2-快速排序实战" class="headerlink" title="2. 快速排序实战"></a>2. 快速排序实战</h3><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/快排1.png" alt=""><br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/快排2.png" alt=""><br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/快排3.png" alt=""><br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/快排4.png" alt=""><br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/快排5.png" alt=""></p><h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="顺序搜索"><a href="#顺序搜索" class="headerlink" title="顺序搜索"></a>顺序搜索</h2><p>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.sequentialSearch = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</div><div class="line">    <span class="keyword">if</span> (item === array[i])</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>二分搜索算法的原理和猜数字游戏类似，就是那个有人说“我正想着一个1到100的数字”的游戏。我们每回应一个数字，那个人就会说这个数字是高了、低了还是对了。</p><p>这个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。</p><ol><li>选择数组的中间值。</li><li>如果选中值是待搜索值，那么算法执行完毕（值找到了）。</li><li>如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。</li><li>如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.binarySearch = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.quickSort();</div><div class="line">  <span class="keyword">var</span> low = <span class="number">0</span>,</div><div class="line">    high = array.length - <span class="number">1</span>,</div><div class="line">    mid, element;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (low &lt;= high)&#123;</div><div class="line">    mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</div><div class="line">    element = array[mid];</div><div class="line">    <span class="keyword">if</span> (element &lt; item) &#123;</div><div class="line">      low = mid + <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &gt; item) &#123;</div><div class="line">      high = mid - <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>开始前需要先将数组排序，我们可以选择快速排序等。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/排序时间复杂度.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看《学习JavaScript数据结构与算法》，总结了下常用的排序，如冒泡排序、选择排序、插入排序、归并排序和快速排序，以及顺序搜索和二分搜索算法。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="算法" scheme="https://hddhyq.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Cnode-Pwa 过程中的小坑</title>
    <link href="https://hddhyq.github.io/2018/02/21/Vue-Cnode-Pwa-%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
    <id>https://hddhyq.github.io/2018/02/21/Vue-Cnode-Pwa-过程中的小坑/</id>
    <published>2018-02-21T13:34:46.000Z</published>
    <updated>2018-07-08T04:25:55.512Z</updated>
    
    <content type="html"><![CDATA[<p>总结下开发过程中的一些小坑。<br><a id="more"></a></p><h1 id="项目概括"><a href="#项目概括" class="headerlink" title="项目概括"></a>项目概括</h1><p>线上地址<a href="https://brokenbones.xyz" target="_blank" rel="noopener">https://brokenbones.xyz</a></p><h2 id="页面编写"><a href="#页面编写" class="headerlink" title="页面编写"></a>页面编写</h2><p>页面编写主要采用的MVVM框架<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js</a>开发，是直接用的vue-cli脚手架提供的PWA模板,页面样式采用的是<a href="https://vuetifyjs.com/zh-Hans/" target="_blank" rel="noopener">vuetify</a>，数据管理用的是<a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="noopener">vuex</a>，api通讯采用的<a href="http://www.bootcdn.cn/axios/readme/" target="_blank" rel="noopener">axios</a>,页面的路由采用的<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">vue-router</a>，其中我才用了history模式，这种模式更适合PWA。边写文章部分，采用了，Mavon-Editor的markdown编辑器。</p><h2 id="PWA部分"><a href="#PWA部分" class="headerlink" title="PWA部分"></a>PWA部分</h2><p>主要是自己编写了<code>mainfest.json</code>，sw.js则是利用<strong>sw-precahe-webpack-plugin</strong>生成。</p><h2 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h2><p>PWA应用必须采用https,这里我用的是腾讯云的免费的SSL证书，配置十分方便，推荐，免费一年。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>根据路由拆分=&gt;项目的主要page有：</p><ul><li>主题列表<ul><li>全部</li><li>精华</li><li>分享</li><li>问答</li><li>招聘</li><li>测试</li></ul></li><li>主题详情<ul><li>文章部分</li><li>文章回复列表</li><li>回复收藏文章、点赞和回复他人评论</li></ul></li><li>个人中心<ul><li>最近回复</li><li>最近发布</li><li>话题收藏</li></ul></li><li>我的消息<ul><li>已读消息</li><li>未读消息</li></ul></li><li>新建主题<ul><li>Mavon-Editor</li></ul></li><li>关于</li></ul><p><strong>项目准备工作</strong></p><p>主要是，对常见的字体和ret.styl进行打包下载，也观察了其他一些人做相同的社区的页面的结构。</p><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="路由部分"><a href="#路由部分" class="headerlink" title="路由部分"></a>路由部分</h2><p>这个项目让我对vue-router的认识更加深了一步。</p><h3 id="HTML5-history模式"><a href="#HTML5-history模式" class="headerlink" title="HTML5 history模式"></a>HTML5 history模式</h3><p>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p><p>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p><p>当你使用 history 模式时，URL 就像正常的 url，例如 <a href="http://yoursite.com/user/id" target="_blank" rel="noopener">http://yoursite.com/user/id</a>　，也好看！</p><p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a href="http://oursite.com/user/id" target="_blank" rel="noopener">http://oursite.com/user/id</a> 就会返回 404，这就不好看了。</p><p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p><p>后端配置见:<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">后端配置</a></p><p>最后，给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  mode: <span class="string">'history'</span>,</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'*'</span>, <span class="attr">component</span>: NotFoundComponent &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h3 id="导航守卫和watch路由变化"><a href="#导航守卫和watch路由变化" class="headerlink" title="导航守卫和watch路由变化"></a>导航守卫和watch路由变化</h3><p>导航守卫有：</p><ul><li>beforeRouteEnter</li><li>beforeRouteUpdate (2.2 新增)</li><li>beforeRouteLeave</li></ul><p>这个项目中，我用了直接的<code>watch</code>路由变化和<code>beforeRouteUpdate</code></p><p>主题详情界面有五个分路由，全部、问答和测试等。在路由设置中，我们保持的keep-alive，这样可以保持组件的状态保持，对于项目的体验比较好。可是页面的路由变化，如果使用的是同一组件的时候，页面的内容就不会变化，像主题的切换和主题详情的内容的变化等，这是我们就需要利用<br><code>beforeRouteUpdate</code>或者<code>watch</code>路由的变化。</p><p>例如，ListView组件中的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">beforeRouteUpdate(to, <span class="keyword">from</span>, next) &#123;</div><div class="line">  <span class="keyword">this</span>.postList = []</div><div class="line">  <span class="keyword">this</span>.getTabData(to.query.tab)</div><div class="line">  next()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>和TopicDetail中的<code>watch</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">watch: &#123;</div><div class="line">  $route(to, <span class="keyword">from</span>) &#123;</div><div class="line">    <span class="comment">// 理解一下to＝＝要去的路由 记录TopicId,避免相同页面再重复加载</span></div><div class="line">    <span class="comment">// this.topic = []</span></div><div class="line">    <span class="keyword">if</span> (to.name === <span class="string">'topic'</span> &amp;&amp; to.params.id !== <span class="keyword">this</span>.topicId) &#123;</div><div class="line">      <span class="keyword">this</span>.topic = &#123;&#125;</div><div class="line">      <span class="keyword">this</span>.getDetail(<span class="keyword">this</span>.$route.params.id)</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">from</span>.name === <span class="string">'topic'</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.setTopicId(<span class="keyword">from</span>.params.id)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="页面的滚动状态保持"><a href="#页面的滚动状态保持" class="headerlink" title="页面的滚动状态保持"></a>页面的滚动状态保持</h3><p>当我们，在主题列表滚动了一段距离之后，我们点击了一个主题，然后我们再次返回的时候，主题列表需要保持原来的滚动状态。</p><p>本来我的主题列表想要添加<a href="https://ustbhuangyi.github.io/better-scroll/#/" target="_blank" rel="noopener">better-scroll</a>的。但是每次页面滚动之后，点击新主题，再返回的时候，页面总会跳转到顶端，这样的话，浏览体验就非常不好。然后我了解了一下 better-scroll 的滚动原理：<br><img src="http://static.galileo.xiaojukeji.com/static/tms/shield/scroll-4.png" alt=""><br>绿色部分为 wrapper，也就是父容器，它会有固定的高度。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。</p><p>这里，我们了解到了，better-scroll 的滚动原理中，我们需要一个固定的wrapper，这样的话，我们的内容在我们的页面中的话，就是在一个固定的窗口下。</p><p>vue-router 中有一个scrollBehavior ，<a href="https://router.vuejs.org/zh-cn/advanced/scroll-behavior.html" target="_blank" rel="noopener">滚动行为</a>，使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p><p>我们需要记录scrollTop属性，上面采用 better-scroll 的话，我们的窗口是固定的，也就是，这里的scrollTop是相对于我们wrapper，而wrapper在页面中的位置是固定的就是没有scrollTop，这样的话，我们记录的scrollTop没有用。</p><p>如果用 better-scroll ，我们就需要页面跳转的话每次将scrollTop的值手动传给组件，十分麻烦，最后我放弃了并采用了原生的scroll。</p><h3 id="vue-router懒加载"><a href="#vue-router懒加载" class="headerlink" title="vue-router懒加载"></a>vue-router懒加载</h3><p>没什么好说的，为了加载高效肯定要用的。</p><h2 id="其他一些"><a href="#其他一些" class="headerlink" title="其他一些"></a>其他一些</h2><h3 id="mavonEditor"><a href="#mavonEditor" class="headerlink" title="mavonEditor"></a>mavonEditor</h3><p>论坛的文章编辑，现在大部分写文章的都是md了，所以我找了找，最好的还是这个，安装好npm包，加一个标签再加上一点配置接好了。地址：<a href="https://github.com/hinesboy/mavonEditor" target="_blank" rel="noopener">mavonEditor</a></p><h3 id="多处用的登录验证"><a href="#多处用的登录验证" class="headerlink" title="多处用的登录验证"></a>多处用的登录验证</h3><p>没有登录的时候，很多地方都需要登录验证。因为有路由跳转逻辑，需要 js ，有了 mixin 就很好了。我们写好了 mixin 后，在我们需要添加登录页面的地方添加 mixin 和添加登录页面的组件。</p><p>最后，还想到什么有需要总结的还是会更新文章的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下开发过程中的一些小坑。&lt;br&gt;
    
    </summary>
    
      <category term="vue-items" scheme="https://hddhyq.github.io/categories/vue-items/"/>
    
    
      <category term="vue-cnode" scheme="https://hddhyq.github.io/tags/vue-cnode/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JS总结-作用域和闭包(二)</title>
    <link href="https://hddhyq.github.io/2018/02/05/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E6%80%BB%E7%BB%93-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85-%E4%BA%8C/"/>
    <id>https://hddhyq.github.io/2018/02/05/你不知道的JS总结-作用域和闭包-二/</id>
    <published>2018-02-05T15:10:19.000Z</published>
    <updated>2018-07-08T04:25:55.520Z</updated>
    
    <content type="html"><![CDATA[<p>关于你不知道的JS总结-作用域和闭包的第二部分。<br><a id="more"></a></p><h1 id="第-4-章-提升"><a href="#第-4-章-提升" class="headerlink" title="第 4 章 提升"></a>第 4 章 提升</h1><h2 id="先有鸡还是先有蛋"><a href="#先有鸡还是先有蛋" class="headerlink" title="先有鸡还是先有蛋"></a>先有鸡还是先有蛋</h2><p>关于JS的代码执行顺序，直觉上是由上到下一行一行执行的。实际上并不完全正确，考虑下下面的代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log( a );</div></pre></td></tr></table></figure></p><p>你认为<code>console.log( a );</code>声明会输出什么呢？很多人会认为是<code>undefined</code>，其实真实的输出结果是2。而<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( a );</div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div></pre></td></tr></table></figure></p><p>这段代码输出结果又是<code>ReferenceError</code>异常。</p><p>按照第一章的编译器顺序，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。</p><p>所以看到的<code>var a = 2;</code>其实是<code>var a;</code> 和 <code>a = 2;</code>两个声明。代码的编译过程是如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"></div><div class="line"><span class="comment">// 加上顺序，流程如下：</span></div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a = <span class="number">2</span>;</div></pre></td></tr></table></figure></p><p>从上面的例子可以看出，是现有声明，再有赋值。这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。</p><blockquote><p>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。</p></blockquote><h3 id="关于函数的声明"><a href="#关于函数的声明" class="headerlink" title="关于函数的声明"></a>关于函数的声明</h3><p>首先看一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>foo 函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可以正常执行。</p><p>正确的执行顺序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></div><div class="line">  a = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p><p><strong>函数声明会被提升，但是函数表达式却不会被提升。</strong></p><p>下面看一段函数表达式的代码片段：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// TypeError</span></div><div class="line">bar(); <span class="comment">// ReferenceError</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 经过提升</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line">foo(); <span class="comment">// TypeError</span></div><div class="line">bar(); <span class="comment">// ReferenceError</span></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> bar = ...self...</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h2><p>函数声明和变量声明都会被提升，那么哪一个的优先权大呢？答案就在标题。<br>看这一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// 1</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</div><div class="line">&#125;</div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这个代码片段会被引擎理解为如下形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</div><div class="line">&#125;</div><div class="line">foo(); <span class="comment">// 1</span></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>尽管　<code>var foo</code> 出现在<code>function foo()...</code>，但它是一个重复的声明，会被忽略掉。因为函数声明会被提升到普通变量之前。</p><p>而且，后面的函数声明会覆盖前面的声明。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// 3</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">3</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程 <strong>不会像下面的代码暗示的那样可以被条件判断所控制：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// "b"</span></div><div class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span> (a) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"a"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"b"</span>); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们习惯将 <code>var a = 2</code>; 看作一个声明，而实际上 <strong>JavaScript</strong> 引擎并不这么认为。它将 <code>var a</code>和 <code>a = 2</code> 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。</p><p>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为<strong>提升</strong>。</p><p>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</p><p>要注意避免重复声明，特别是当普通的 <code>var</code> 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！</p><h1 id="第-5-章-作用域闭包"><a href="#第-5-章-作用域闭包" class="headerlink" title="第 5 章 作用域闭包"></a>第 5 章 作用域闭包</h1><h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>闭包无处不在，你所需要的只是理解它</p><h2 id="实质问题"><a href="#实质问题" class="headerlink" title="实质问题"></a>实质问题</h2><p>闭包的定义：</p><blockquote><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p></blockquote><p>下面这段代码的定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">  &#125;</div><div class="line">  bar();</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p><p>上面的代码中，基于词法作用域，函数<code>bar()</code>可以访问外部作用域中的变量a（利用RHS引用调用）。这里的词法作用域的利用，是闭包的一部分，也是最重要的一部分。</p><p>从纯学术的角度说，函数 <code>bar()</code> 具有一个涵盖 <code>foo()</code> 作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域））。也可以认为 bar() 被封闭在了 foo() 的作用域中。为什么呢？原因简单明了，因为 bar() 嵌套在 foo() 内部。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( a );</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> baz = foo();</div><div class="line">baz(); <span class="comment">// 2 —— 朋友，这就是闭包的效果。</span></div></pre></td></tr></table></figure></p><p>函数<code>bar()</code>的词法作用域能够访问<code>foo()</code>的内部作用域。然后我们将<code>bar()</code>函数本身当做一个值类型进行传递。上面这个例子中，我们就是将bar所应用的函数对象本身当做返回值。</p><p>在<code>foo()</code>执行后，其返回值（也就是内部的 <code>bar()</code> 函数）赋值给变量 <code>baz</code> 并调用 <code>baz()</code>，实际上只是通过不同的标识符引用调用了内部的函数<code>bar()</code>。</p><p><code>bar()</code>显然可以被正常执行，但是在这个例子中，它在自己定义的词法作用域以外的地方执行。</p><p><code>foo()</code> 执行后，通常会期待 <code>foo()</code> 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 <code>foo()</code> 的内容不会再被使用，所以很自然地会考虑对其进行回收。</p><p>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 <code>bar()</code> 本身在使用。</p><p>拜 <code>bar()</code> 所声明的位置所赐，它拥有涵盖 <code>foo()</code> 内部作用域的闭包，使得该作用域能够一直存活，以供 <code>bar()</code> 在之后任何时间进行引用。</p><p><code>bar()</code> 依然持有对该作用域的引用，而这个引用就叫作闭包。</p><p>因此，在<strong>几微秒</strong>之后变量 baz 被实际调用（调用内部函数 <code>bar</code>），不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。</p><p>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。</p><p>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">  &#125;</div><div class="line">  bar( baz );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  fn(); <span class="comment">// 妈妈快看呀，这就是闭包！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</p></blockquote><h2 id="现在我懂了"><a href="#现在我懂了" class="headerlink" title="现在我懂了"></a>现在我懂了</h2><p>来看这段代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( message );</div><div class="line">  &#125;, <span class="number">1000</span> );</div><div class="line">&#125;</div><div class="line">wait( <span class="string">"Hello, closure!"</span> );</div></pre></td></tr></table></figure></p><p>将一个内部函数（名为 <code>timer</code>）传递给 <code>setTimeout(..)</code>。<code>timer</code> 具有涵盖 <code>wait(..)</code> 作用域的闭包，因此还保有对变量 <code>message</code> 的引用。</p><p><code>wait(..)</code> 执行 1000 毫秒后，它的内部作用域并不会消失，<code>timer</code> 函数依然保有 <code>wait(..)</code>作用域的闭包。</p><p>深入到引擎的内部原理中，内置的工具函数 <code>setTimeout(..)</code> 持有对一个参数的引用，这个参数也许叫作 <code>fn</code> 或者 <code>func</code>，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 <code>timer</code> 函数，而词法作用域在这个过程中保持完整。</p><p><strong>这就是闭包。</strong></p><p>本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！</p><p>IIFE模式，因为函数（示例代码中的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行。这是是创建了一个闭包但是并不能调用。</p><h2 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h2><p>要说明闭包，for循环是最常见的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( i );</div><div class="line">  &#125;, i*<span class="number">1000</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们预期的效果是:分别输出数字 1~5，每秒一次，每次一个。</p><p>得到的结果是，每秒一次的频率输出五次 6。</p><p>首先我们看一下6是怎么来的。这个例子中的终止条件是<code>i&lt;=5</code>。所以首次成立时的i的值是6，因此，输出显示的是循环结束时 i 的最终值。</p><p>仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 <code>setTimeout(.., 0)</code>，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。</p><p>缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的<strong>副本</strong>。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个<strong>共享的全局作用域中</strong>，因此实际上只有一个 i。</p><p>我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。</p><p>首先试下IIFE<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log( i );</div><div class="line">    &#125;, i*<span class="number">1000</span> );</div><div class="line">  &#125;)();</div><div class="line">&#125; <span class="comment">// 这样的写法不行，为什么呢？因为每个IIFE中i的值并没有定义，也就是说这个作用于是空的</span></div><div class="line"></div><div class="line"><span class="comment">//　改进</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log( j );</div><div class="line">    &#125;, j*<span class="number">1000</span> );</div><div class="line">  &#125;)( i );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>重返块作用域</strong></p><p>我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。第 3 章介绍了 let 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。</p><p>本质上这是将一个块转换成一个可以被关闭的作用域。因此，下面这些看起来很酷的代码就可以正常运行了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="keyword">let</span> j = i; <span class="comment">// 是的，闭包的块作用域！</span></div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( j );</div><div class="line">  &#125;, j*<span class="number">1000</span> );</div><div class="line">&#125;</div><div class="line"><span class="comment">// for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( i );</div><div class="line">  &#125;, i*<span class="number">1000</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>还有其他的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一起来研究其中最强大的一个：<strong>模块</strong>。</p><p>模块模式需要具备两个必要条件。</p><ol><li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够到达那里。但实际上它只是一个标准，显然就是关于如何在函数作为值按需传递的词法环境中书写代码的。</p><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</p><p>如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。</p><p>模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</p><p>现在我们会发现代码中到处都有闭包存在，并且我们能够识别闭包然后用它来做一些有用的事！</p><h1 id="附录-A-动态作用域"><a href="#附录-A-动态作用域" class="headerlink" title="附录 A 动态作用域"></a>附录 A 动态作用域</h1><p>JS中作用域就是词法作用域，（事实上大部分语言都是基于词法作用域的）。</p><p>而JS中，this的机制，类似于动态作用域。</p><p>词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的<strong>书写阶段</strong>（假设你没有使用eval() 或 with）。而动态作用域，是一个运行时被被动确定状态的形式。</p><p>例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">bar();</div></pre></td></tr></table></figure></p><p>词法作用域让 <code>foo()</code> 中的 <code>a</code> 通过 <strong>RHS</strong> 引用到了全局作用域中的 <code>a</code>，因此会输出 2。</p><p>而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。</p><p>因此，如果 JavaScript 具有动态作用域，理论上，上面代码中的 <code>foo()</code> 在执行时将会输出 3。</p><p>为什么会这样？因为当 <code>foo()</code> 无法找到 <code>a</code> 的变量引用时，会顺着调用栈在调用 <code>foo()</code> 的地方查找 <code>a</code>，而不是在嵌套的词法作用域链中向上查找。由于 <code>foo()</code> 是在 <code>bar()</code> 中调用的，引擎会检查 <code>bar()</code> 的作用域，并在其中找到值为 3 的变量 <code>a</code>。</p><h1 id="附录-B-块作用域的替代方案"><a href="#附录-B-块作用域的替代方案" class="headerlink" title="附录 B 块作用域的替代方案"></a>附录 B 块作用域的替代方案</h1><p>第 3 章深入研究了块作用域。至少从 ES3 发布以来，JavaScript 中就有了块作用域，而with 和 catch 分句就是块作用域的两个小例子。</p><p>但随着 ES6 中引入了 let，我们的代码终于有了创建完整、不受约束的块作用域的能力。块作用域在功能上和代码风格上都拥有很多激动人心的新特性。</p><p>但如果我们想在 ES6 之前的环境中使用块作用域呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure><p>这段代码在 ES6 环境中可以正常工作。但是在 ES6 之前的环境中如何才能实现这个效果？答案是使用 catch。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;<span class="keyword">throw</span> <span class="number">2</span>;&#125;<span class="keyword">catch</span>(a)&#123;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p><p>了解原理剩下就交给ES6转换器吧。</p><h1 id="附录-C-this-词法"><a href="#附录-C-this-词法" class="headerlink" title="附录 C this 词法"></a>附录 C this 词法</h1><p>ES6 中有一个主题用非常重要的方式将 this同词法作用域联系起来了，我们会简单地讨论一下。</p><p>ES6 添加了一个特殊的语法形式用于函数声明，叫作箭头函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">a</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log( a );</div><div class="line">&#125;;</div><div class="line">foo( <span class="number">2</span> ); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><p>这里称作“胖箭头”的写法通常被当作单调乏味且冗长（挖苦）的 function 关键字的简写。</p><p>看这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  id: <span class="string">"awesome"</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.id );</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> id = <span class="string">"not awesome"</span></div><div class="line">obj.cool(); <span class="comment">// 酷</span></div><div class="line">setTimeout( obj.cool, <span class="number">100</span> ); <span class="comment">// 不酷</span></div></pre></td></tr></table></figure></p><p>问题在于 cool() 函数丢失了同 this 之间的绑定。解决这个问题有好几种办法，但最长用的就是 var self = this;。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  count: <span class="number">0</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (self.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        self.count++;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"awesome?"</span> );</div><div class="line">      &#125;, <span class="number">100</span> );</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.cool(); <span class="comment">// 酷吧？</span></div></pre></td></tr></table></figure><p><code>var self = this</code> 这种解决方案圆满解决了理解和正确使用 <code>this</code> 绑定的问题，并且没有把问题过于复杂化，它使用的是我们非常熟悉的工具：词法作用域。</p><p>ES6 中的箭头函数引入了一个叫作 this 词法的行为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  count: <span class="number">0</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 箭头函数是什么鬼东西？</span></div><div class="line">        <span class="keyword">this</span>.count++;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"awesome?"</span> );</div><div class="line">      &#125;, <span class="number">100</span> );</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.cool(); <span class="comment">// 很酷吧 ?</span></div></pre></td></tr></table></figure></p><p>简单来说，箭头函数在涉及 <code>this</code> 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 <code>this</code> 绑定的规则，取而代之的是用当前的词法作用域覆盖了 <code>this</code> 本来的值。</p><p>因此，这个代码片段中的箭头函数并非是以某种不可预测的方式同所属的 <code>this</code> 进行了解绑定，而只是“继承”了 <code>cool()</code> 函数的 <code>this</code> 绑定（因此调用它并不会出错）。</p><p>箭头函数将程序员们经常犯的一个错误给标准化了，也就是混淆了 <code>this</code> 绑定规则和词法作用域规则。</p><p>换句话说：为什么要自找麻烦使用 <code>this</code> 风格的代码模式呢？把它和词法作用域结合在一起非常让人头疼。在代码中使用两种风格其中的一种是非常自然的事情，但是不要将两种风格混在一起使用。</p><blockquote><p>另一个导致箭头函数不够理想的原因是它们是匿名而非具名的。具名函数比<br>匿名函数更可取的原因参见第 3 章。</p></blockquote><p>在我看来，解决这个“问题”的另一个更合适的办法是正确使用和包含 this 机制。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  count: <span class="number">0</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.count++; <span class="comment">// this 是安全的</span></div><div class="line">        <span class="comment">// 因为 bind(..)</span></div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"more awesome"</span> );</div><div class="line">      &#125;.bind( <span class="keyword">this</span> ), <span class="number">100</span> ); <span class="comment">// look, bind()!</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.cool(); <span class="comment">// 更酷了。</span></div></pre></td></tr></table></figure></p><p>无论你是喜欢箭头函数中 this 词法的新行为模式，还是喜欢更靠得住的 bind()，都需要注意箭头函数不仅仅意味着可以少写代码。</p><p>它们之间有意为之的不同行为需要我们理解和掌握，才能正确地使用它们。</p><p>现在我们已经完全理解了词法作用域（还有闭包），理解 this 词法是小菜一碟！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于你不知道的JS总结-作用域和闭包的第二部分。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="你不知道的JS" scheme="https://hddhyq.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"/>
    
  </entry>
  
</feed>
