<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hddhyq&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hddhyq.github.io/"/>
  <updated>2018-07-08T06:24:16.304Z</updated>
  <id>https://hddhyq.github.io/</id>
  
  <author>
    <name>hddhyq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数去抖debounce和函数节流throttle的应用</title>
    <link href="https://hddhyq.github.io/2018/07/08/%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96debounce%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81throttle%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://hddhyq.github.io/2018/07/08/函数去抖debounce和函数节流throttle的应用/</id>
    <published>2018-07-08T04:43:09.000Z</published>
    <updated>2018-07-08T06:24:16.304Z</updated>
    
    <content type="html"><![CDATA[<p>开始以为只有节流函数，原来还有去抖函数啊。两个概念第一次听的话肯定比较容易混淆，接下来就来研究一下它们吧。<br><a id="more"></a></p><h1 id="函数去抖debounce"><a href="#函数去抖debounce" class="headerlink" title="函数去抖debounce"></a>函数去抖debounce</h1><p>在一段时间内执行该动作，在单位时间内重新调用该动作，会重新计算时间。</p><p>我的理解就是，只要触发的够快，函数就追不上我，哈哈哈。</p><p>当我停下来的时候，函数会触发最后一次。所以其中肯定有一个定时器哈，下面展示一下简单实现的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</div><div class="line">    <span class="comment">// 定义一个定时器</span></div><div class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 绑定函数调用时上下文及参数</span></div><div class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</div><div class="line">        args = <span class="built_in">arguments</span>;</div><div class="line">        clearTimeout(timer);</div><div class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'debounce被触发了'</span>);</div><div class="line">            fn.apply(context, args);</div><div class="line">        &#125;, delay);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义一个btn，然后去点它来测试</span></div><div class="line">$(<span class="string">'.btn-click-debounce'</span>).on(<span class="string">'click'</span>, debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'200ms一次'</span>)</div><div class="line">&#125;, <span class="number">200</span>))</div></pre></td></tr></table></figure><h1 id="函数节流throttle"><a href="#函数节流throttle" class="headerlink" title="函数节流throttle"></a>函数节流throttle</h1><p>将倾斜而出的水流，一点一点的流出，这就是节流。放在函数触发中，就是本来快速l连续触发的事件以单位时间为间隔来触发。简单实现的源码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, threshhold</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> last = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</div><div class="line">    threshhold || (threshhold = <span class="number">200</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// Date.now();</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(last &amp;&amp; ((now &lt; last + threshhold)) &#123;</div><div class="line">            <span class="comment">// 判断时间间隔，以及是否第一次触发</span></div><div class="line">            clearTimeout(timer);</div><div class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                last = now;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'throttle被触发了'</span>);</div><div class="line">                fn.apply(context, args);</div><div class="line">            &#125;, threshhold)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            last = now;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'throttle被触发了'</span>);</div><div class="line">            fn.apply(context, args);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$(<span class="string">'.btn-click-throttle'</span>).on(<span class="string">'click'</span>, throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'200ms一次'</span>)</div><div class="line">&#125;, <span class="number">200</span>))</div></pre></td></tr></table></figure></p><h1 id="使用的场景"><a href="#使用的场景" class="headerlink" title="使用的场景"></a>使用的场景</h1><h2 id="throttle函数节流"><a href="#throttle函数节流" class="headerlink" title="throttle函数节流"></a>throttle函数节流</h2><ul><li>Dom元素的拖拽实现（mousemove）</li><li>射击游戏的mousedown/keydown事件（单位时间只能发射一颗子弹）</li><li>计算鼠标移动的距离（mousemove）</li><li>Canvas模拟画板功能</li><li>搜索联想（keyup）</li><li>监听滚动事件是否到底部自动加载更多（<br>监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次）</li></ul><h2 id="debounce应用场景"><a href="#debounce应用场景" class="headerlink" title="debounce应用场景"></a>debounce应用场景</h2><ul><li>每次resize/scroll触发统计</li><li>文本输入的验证（连续输入文字后发送ajax进行验证，验证一次就好）</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/zichi/p/5948936.html" target="_blank" rel="noopener">http://www.cnblogs.com/zichi/p/5948936.html</a></p><p><a href="https://www.cnblogs.com/fsjohnhuang/p/4147810.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsjohnhuang/p/4147810.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始以为只有节流函数，原来还有去抖函数啊。两个概念第一次听的话肯定比较容易混淆，接下来就来研究一下它们吧。&lt;br&gt;
    
    </summary>
    
      <category term="JS_tricks" scheme="https://hddhyq.github.io/categories/JS-tricks/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="优化" scheme="https://hddhyq.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于之前看看的一些css</title>
    <link href="https://hddhyq.github.io/2018/06/12/%E5%85%B3%E4%BA%8E%E4%B9%8B%E5%89%8D%E7%9C%8B%E7%9C%8B%E7%9A%84%E4%B8%80%E4%BA%9Bcss/"/>
    <id>https://hddhyq.github.io/2018/06/12/关于之前看看的一些css/</id>
    <published>2018-06-12T06:44:28.000Z</published>
    <updated>2018-07-08T04:25:55.520Z</updated>
    
    <content type="html"><![CDATA[<p>记一下上个月看的图解CSS的一些简单的知识点哈。<br><a id="more"></a></p><h1 id="元素百分比的相对计算"><a href="#元素百分比的相对计算" class="headerlink" title="元素百分比的相对计算"></a>元素百分比的相对计算</h1><table><thead><tr><th>相对的元素计算</th><th>属性</th></tr></thead><tbody><tr><td>父元素宽度</td><td><code>width</code>, <code>left</code>, <code>right</code>, <code>text-indent</code>, <code>padding</code>, <code>margin</code>等</td></tr><tr><td>父元素高度</td><td><code>height</code>, <code>top</code>, <code>bottom</code>等</td></tr><tr><td>主轴长度</td><td><code>flex-basis</code></td></tr><tr><td>继承字号</td><td><code>flex-size</code></td></tr><tr><td>自身字号</td><td><code>line-height</code></td></tr><tr><td>自身宽高</td><td><code>vertical-align</code></td></tr><tr><td>自身设置</td><td><code>background-position</code>; <code>border-image-slice</code></td></tr><tr><td>特殊算法</td><td><code>position: absolute</code>，相对于父元素最近的<code>position</code>不为<code>static</code>的祖先元素。如果没有这样的元素，则相对于视口。</td></tr></tbody></table><h1 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h1><table><thead><tr><th>选择器</th><th>功能描述</th></tr></thead><tbody><tr><td>E:first-child</td><td>作为父元素的第一个子元素E</td></tr><tr><td>E:last-child</td><td>作为父元素的最后一个子元素的元素E</td></tr><tr><td>E:root</td><td>选择匹配元素E所在文档的根元素</td></tr><tr><td>E F:nth-child(n)</td><td>选择父元素的第n个子元素F</td></tr><tr><td>E F:nth-last-child(n)</td><td>选择元素E的倒数第n个子元素F</td></tr><tr><td>E:nth-of-type(n)</td><td>选择父元素内具有指定类型的第n个E元素</td></tr><tr><td>E:nth-last-of-type(n)</td><td>选择父元素内具有指定类型的倒数第n个E元素</td></tr><tr><td>E:first-of-type</td><td>选择父元素内具有指定类型的的第一个E元素，与E:nth-of-type(1)相同</td></tr><tr><td>E:last-of-type</td><td>选择父元素内具有指定类型的的最后一个E元素，与E:nth-last-of-type(1)相同</td></tr><tr><td>E:only-child</td><td>选择父元素只包含一个字元素，且该子元素匹配E元素</td></tr><tr><td>E:only-of-type</td><td>选择父元素只包含一个同类型的子元素，且该子元素匹配E元素</td></tr><tr><td>E:empty</td><td>选择没有子类型的元素，而且该元素也不包含任何文本节点</td></tr></tbody></table><p>关于，伪类元素选择器中n的用法，也就是n取0到+∞，在子元素的个数范围内，取相对应的子元素。</p><h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><p>伪类一般反映无法在CSS中轻松或可靠地检测到的某个元素的属性或状态；伪元素则表示DOM外部的某种元素。</p><table><thead><tr><th>伪元素</th><th>功能描述</th></tr></thead><tbody><tr><td>::first-letter</td><td>选择文本块的第一个字母，除非在同一行中包含一些其他元素</td></tr><tr><td>::first-line</td><td>匹配元素的第一行文本</td></tr><tr><td>::before和::after</td><td>生成的内容不会成为DOM的一部分，但是可以设置样式</td></tr><tr><td>::selection</td><td>匹配突出显示的文本，可设置background和color</td></tr></tbody></table><h1 id="border相关"><a href="#border相关" class="headerlink" title="border相关"></a>border相关</h1><h2 id="border-shadow"><a href="#border-shadow" class="headerlink" title="border-shadow"></a>border-shadow</h2><table><thead><tr><th>属性</th><th>功能描述</th></tr></thead><tbody><tr><td>none</td><td>默认值，元素没有任何阴影效果</td></tr><tr><td>inset</td><td>阴影类型，可选值。默认外投影</td></tr><tr><td>x-offset</td><td>阴影水平偏移量，其值可以是正负值。正值在元素右边</td></tr><tr><td>y-offset</td><td>阴影垂直偏移量，其值可以是正负值。正值在元素底部</td></tr><tr><td>blur-radius</td><td>阴影模糊半径，可选参数。取值为0，表示阴影不具有模糊效果，取值越大，阴影的边缘越模糊</td></tr><tr><td>spread-radius</td><td>阴影扩展半径，可选参数。正值整个阴影都延展扩大，负值，整个阴影缩小</td></tr><tr><td>color</td><td>阴影颜色，不取值则是默认色，各个浏览器的默认色不一样的。</td></tr></tbody></table><h1 id="css3背景"><a href="#css3背景" class="headerlink" title="css3背景"></a>css3背景</h1><p>主要有</p><ul><li>background-color 背景颜色</li><li>background-image 背景图片</li><li>background-repeat 背景图片展示方式</li><li>background-attachment 背景图片是固定还是滚动</li><li>background-position 背景图片位置</li></ul><p>CSS3新增属性</p><ul><li>background-origin 指定绘制背景图片的起点（padding-box||border-box||content-box）</li><li>background-clip 指定背景图片的显示范围（padding-box||border-box||content-box）</li><li>background-size 指定背景图片的尺寸大小（auto||percentage||cover||contain）</li><li>background-break 指定内联元素的背景图片进行平铺时的循环方式</li></ul><h1 id="css文本类型"><a href="#css文本类型" class="headerlink" title="css文本类型"></a>css文本类型</h1><table><thead><tr><th>属性</th><th>功能描述</th><th>取值</th></tr></thead><tbody><tr><td>word-spacing</td><td>定义词与词之间的间距</td><td>normal，length（设置词与词之间间距，可以是负数）</td></tr><tr><td>letter-spacing</td><td>定义字符之间的间距</td><td>normal，length（设置词与词之间间距，可以是负数）</td></tr><tr><td>vertiacl-align</td><td>定义文本的垂直对齐方式</td><td>baseline、sub（上标对齐）、super（下标对齐）、bottom（行框底端对齐）、text-bottom（行内文本底端对齐）、top（顶端对齐）、middle（居中对齐）、百分比数字、长度</td></tr><tr><td>text-decoration</td><td>定义文本的修饰线</td><td>none、underline、overline、line-through、blink</td></tr><tr><td>text-indent</td><td>定义文本首行缩进</td><td>length（长度单位）和百分比</td></tr><tr><td>text-align</td><td>定义文本水平对齐方式</td><td>left（左对齐）、center（水平对齐）、right（右对齐）、justify（两端对齐）</td></tr><tr><td>line-height</td><td>定义文本行高</td><td>normal、长度值、百分比值、数字</td></tr><tr><td>text-transform</td><td>定义文本大小写</td><td>none、uppercase、lowercase、capitalize（首字母大写）</td></tr><tr><td>text-shadow</td><td>定义文本阴影效果</td><td></td></tr><tr><td>white-space</td><td>定义文字之间和文本之间的空白符间距</td><td>normal、nowrap（空白符合并，换行符忽略）、pre（空白符，换行符保留）、pre-wrap（空白符，换行符保留）、pre-line（空白符合，换行符保留）</td></tr><tr><td>direction</td><td>控制文本流入的方向</td><td>ltr、rtl（文本从右到左流入）、inhert（文本流入方向有继承获得）</td></tr></tbody></table><p><code>text-overflow</code>：实现文本溢行处理，<code>word-break: break-all</code>来实现浏览器文本的换行</p><p>多行文本怎么实现文本溢出…,在webkit内核<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">display: -webkit-box</div><div class="line">-webkit-line-clamp: 2</div><div class="line">-webkit-box-orient: vertical</div></pre></td></tr></table></figure></p><h1 id="指定过渡属性transition-property"><a href="#指定过渡属性transition-property" class="headerlink" title="指定过渡属性transition-property"></a>指定过渡属性transition-property</h1><ul><li>none： 没有指定任何样式。</li><li>all：默认值，表示指定元素所有支持transition-property属性的样式。</li><li><code>&lt;single-transition-property&gt;</code>：指定样式，其等于all或者<ident>。</ident></li><li>颜色属性</li><li>具有长度值</li><li>integer（离散步骤，整个数字，在真实的数字空间，以及使用floor()转换为整数时发生，如outline-offset，z-index）</li><li>number</li><li>变形系列属性</li><li>rectangle（通过x，y，width，height（转为数值）变换，如crop属性）</li><li>visibility（离散步骤，在0~1范围内。0表示隐藏，1表示完全显示）</li><li>阴影（shadow，如text-shadow）</li><li>渐变（gradient）：通过每次停止时的位置和颜色进行变化。</li><li>paint server(SVG)</li><li>space-separated list of above</li><li>缩写属性</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记一下上个月看的图解CSS的一些简单的知识点哈。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://hddhyq.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://hddhyq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JS-this和原型对象</title>
    <link href="https://hddhyq.github.io/2018/05/14/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-this%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>https://hddhyq.github.io/2018/05/14/你不知道的JS-this和原型对象/</id>
    <published>2018-05-14T07:11:34.000Z</published>
    <updated>2018-07-08T04:25:55.519Z</updated>
    
    <content type="html"><![CDATA[<p>这里我总结了下，《你不知道的javaScript上卷》第二部分的内容，总结的可能比较简短，相关的知识点，与设计模式中间有重合，设计模式中的相关设计模式，后期也会补上。<br><a id="more"></a></p><h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h1><h2 id="为什么要用this呢？"><a href="#为什么要用this呢？" class="headerlink" title="为什么要用this呢？"></a>为什么要用this呢？</h2><p>如果没有this，我们需要调用变量名，才能在函数或者方法中调用相关它自己，如果有了this，我们就能用一种更优雅的方式“传递”一个对象的引用。因此可以将API设计的更加简洁并且易于复用。</p><p>随着你使用的模式越来越复杂，显示传递上下文对象会使代码变得越来越混乱，使用this则不会这样。</p><h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><p>关于两种常见的对于this的解释，但是他们都是错误的。</p><h3 id="指向自身"><a href="#指向自身" class="headerlink" title="指向自身"></a>指向自身</h3><p>很多人很容易吧this联想到它的英文意思，指向函数本身，但是this的绑定是动态的！</p><p>看一个例子吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</div><div class="line">  <span class="comment">// 记录 foo 被调用的次数</span></div><div class="line">  <span class="keyword">this</span>.count++;</div><div class="line">&#125;</div><div class="line">foo.count = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> i;</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</div><div class="line">    foo( i );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// foo: 6</span></div><div class="line"><span class="comment">// foo: 7</span></div><div class="line"><span class="comment">// foo: 8</span></div><div class="line"><span class="comment">// foo: 9</span></div><div class="line"><span class="comment">// foo 被调用了多少次？</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 0 -- WTF?</span></div></pre></td></tr></table></figure><p>上面的this绑定到哪里了呢？答案是全局。</p><h3 id="它的作用域"><a href="#它的作用域" class="headerlink" title="它的作用域"></a>它的作用域</h3><p>第二种常见的误解是，this指向函数的作用域。</p><p>再看一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="keyword">this</span>.bar();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(); <span class="comment">// ReferenceError: a is not defined</span></div></pre></td></tr></table></figure><p>这里我们既想用词法作用域，又想调用this来引入我们想用的函数体的变量。</p><p>这里稍微解析一下， <code>this.bar()</code> 引用的是外部的全局的 <code>bar()</code> 函数，这样里面的语句， <code>console.log(this.a)</code> 查找的也是全局的 <code>a</code> 变量。我们知道函数定义的 <code>a</code> 变量是影响不了全局的 <code>a</code> 变量的。所以这里我们会抛出一个引用错误。</p><h3 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h3><p>排除了错误的理解后，我们看看this到底是什么样的机制。</p><p>之前我们说过this是在运行时进行绑定的，并不是在编写时绑定，他的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置灭有任何关系，只取决于函数的调用方式。</p><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等消息。this就是记录的其中一个属性，会在函数执行的过程中用到。</p><p>下一章我们会学习如何寻找函数的滴啊用位置，从而判断函数在执行的过程中会如何绑定this。</p><h1 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h1><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>就像前面说的，调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个this到底引用的是什么？</p><p>通常来说，寻找滴啊用位置就是寻找“函数被调用的位置”，但是做起来没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。</p><p>最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当前调用栈是：baz</span></div><div class="line">  <span class="comment">// 因此，当前调用位置是全局作用域</span></div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"baz"</span> );</div><div class="line">  bar(); <span class="comment">// &lt;-- bar 的调用位置</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当前调用栈是 baz -&gt; bar</span></div><div class="line">  <span class="comment">// 因此，当前调用位置在 baz 中</span></div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"bar"</span> );</div><div class="line">  foo(); <span class="comment">// &lt;-- foo 的调用位置</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></div><div class="line">  <span class="comment">// 因此，当前调用位置在 bar 中 // 这里放一个断点可以查看当前调用栈，倒数第二个就是真正的调用位置。</span></div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"foo"</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line">baz(); <span class="comment">// &lt;-- baz 的调用位置</span></div></pre></td></tr></table></figure><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><p>这里也简要的解释四种规则：</p><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h3><p>最常用的函数调用类型：独立函数调用。可以把这条规则看做是无法应用其他规则时的默认规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">foo(); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>怎么知道应用了默认绑定呢？可以通过调用位置来看看 <code>foo()</code> 是如何调用的。在代码中，<code>foo()</code>是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。如果使用严格模式，将默认无法使用默认绑定的，因为this会绑定为undefined。</p><h3 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h3><p>另一种需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。</p><p>常见的对象的方法，就是隐式绑定。对象属性引用链只有最顶层或者说最后一层会影响调用位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  a: <span class="number">42</span>,</div><div class="line">  foo: foo</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  obj2: obj2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj1.obj2.foo(); <span class="comment">// 42</span></div></pre></td></tr></table></figure><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>因为this的绑定会根据runtime，所以，思考下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = obj.foo;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">"全局对象a"</span>;</div><div class="line"></div><div class="line">bar(); <span class="comment">// 全局对象a</span></div></pre></td></tr></table></figure><p>还有一种是常见的回调函数中的this隐式丢失，看下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a 是全局对象的属性</span></div><div class="line"></div><div class="line">setTimeout( obj.foo, <span class="number">100</span> ); <span class="comment">// "oops, global"</span></div><div class="line"></div><div class="line"><span class="comment">// JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn,delay</span>) </span>&#123;</div><div class="line">  <span class="comment">// 等待 delay 毫秒</span></div><div class="line">  fn(); <span class="comment">// &lt;-- 调用位置！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来，我们会介绍相关的通过固定this来fix,this所指向的对象或者说上下文context。</p><h3 id="3-显示绑定"><a href="#3-显示绑定" class="headerlink" title="3. 显示绑定"></a>3. 显示绑定</h3><p>分析隐式绑定时，我们必须在一个对象的内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上。</p><p>我们可以通过call(..)和apply(..)方法，来在某个函数中强制指定到this的上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.call( obj ); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p><h4 id="1-硬绑定"><a href="#1-硬绑定" class="headerlink" title="1. 硬绑定"></a>1. 硬绑定</h4><p>思考下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  foo.call(obj);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  foo.call(obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这里，我们在 <code>bar</code> 内部实现了一个 <code>foo.call(obj)</code>，因此强制把 <code>foo</code> 的 <code>this</code> 绑定到了 <code>obj</code> 。无论之后如何调用函数 <code>bar</code> ，它总会在 <code>obj</code> 上调用 <code>foo</code> 。这种绑定是一种显式的强制绑定，因此我们称之为 <strong>硬绑定</strong>。</p><p>ES5中提供了内置的方法，<strong>Function.prototype.bind</strong></p><h4 id="2-API调用的“上下文”"><a href="#2-API调用的“上下文”" class="headerlink" title="2. API调用的“上下文”"></a>2. API调用的“上下文”</h4><p>第三方库的许多函数，以及 <strong>JavaScript</strong> 语言和宿主环境中许多新的内置函数，都提供了一<br>个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调<br>函数使用指定的 <code>this</code>。</p><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( el, <span class="keyword">this</span>.id );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  id: <span class="string">"awesome"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 调用 foo(..) 时把 this 绑定到 obj</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj );</div><div class="line"><span class="comment">// 1 awesome 2 awesome 3 awesome</span></div></pre></td></tr></table></figure></p><p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些<br>代码。</p><h3 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4. new绑定"></a>4. new绑定</h3><p>在JavaScript中，构造函数只是一些使用 <code>new</code> 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至不能说是一种特殊的函数类型，它们只是被 <code>new</code> 操作符调用的普通函数。</p><p>使用 <code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li>创建（或者说构造）一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的 <code>this</code> 。</li><li>如果函数没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象。</li></ol><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ol><li>函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。</li><li>函数是否通过call、apply（显示绑定）或者硬绑定调用？如果是的话，this绑定的是制定的对象。</li><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。</li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。</li></ol><h2 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h2><p>在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用<br>的可能是默认绑定规则。</p><h3 id="1-被忽略的this"><a href="#1-被忽略的this" class="headerlink" title="1. 被忽略的this"></a>1. 被忽略的this</h3><p>如果你把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用的时候会被忽略，实际应用的是默认绑定规则。</p><p>如果函数并不关心this的话，你仍然需要传入一个占位符，常见的就是用null，可是这里用null来忽略this绑定可能会产生一些副作用。如果这个函数中确实使用了this，那默认绑定规则会把this绑定到全局对象，在浏览器这个对象是window，这将产生不可预计的后果。</p><p><strong>更安全的this</strong></p><p>一种“更安全”的做法是，闯入一个特殊的对象，常见方法，<code>Object.create(null)</code>。如果引入的是这个空对象，这样就比较安全了，这样很明确的表示this是空，即使函数中调用了this，也不会更改全局对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = <span class="number">200</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line"></div><div class="line">foo.call(ø)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a)</div><div class="line"><span class="comment">// 200 2</span></div></pre></td></tr></table></figure><h3 id="2-间接引用"><a href="#2-间接引用" class="headerlink" title="2. 间接引用"></a>2. 间接引用</h3><p>另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这<br>种情况下，调用这个函数会应用默认绑定规则。</p><p>常见的就是赋值的时候发生。</p><p>注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则this 会被绑定到全局对象。</p><h3 id="3-软绑定"><a href="#3-软绑定" class="headerlink" title="3. 软绑定"></a>3. 软绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">// 捕获所有 curried 参数</span></div><div class="line">    <span class="keyword">var</span> curried = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> fn.apply(</div><div class="line">          (!<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global)) ?</div><div class="line">            obj : <span class="keyword">this</span></div><div class="line">          curried.concat.apply( curried, <span class="built_in">arguments</span> )</div><div class="line">      );</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    bound.prototype = <span class="built_in">Object</span>.create( fn.prototype );</div><div class="line">    <span class="keyword">return</span> bound;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>softBind(..)</code>的其他原理和ES5内置的bind(..)类似。它会对制定函数进行封装，首先会检查调用时的this，如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this，否则不会修改this。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"name: "</span> + <span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"obj"</span> &#125;,</div><div class="line">    obj2 = &#123; <span class="attr">name</span>: <span class="string">"obj2"</span> &#125;,</div><div class="line">    obj3 = &#123; <span class="attr">name</span>: <span class="string">"obj3"</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fooOBJ = foo.softBind( obj );</div><div class="line"></div><div class="line">fooOBJ(); <span class="comment">// name: obj</span></div><div class="line"></div><div class="line">obj2.foo = foo.softBind(obj);</div><div class="line"></div><div class="line">obj2.foo(); <span class="comment">// name: obj2 &lt;---- 看！！！</span></div><div class="line"></div><div class="line">fooOBJ.call( obj3 ); <span class="comment">// name: obj3 &lt;---- 看！</span></div><div class="line"></div><div class="line">setTimeout( obj2.foo, <span class="number">10</span> );</div><div class="line"><span class="comment">// name: obj &lt;---- 应用了软绑定</span></div></pre></td></tr></table></figure></p><h2 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h2><p>这里介绍一下箭头函数: <code>() =&gt; {}</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  a: <span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  a: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = foo.call(obj1);</div><div class="line">bar.call(obj2);</div></pre></td></tr></table></figure></p><p><code>foo()</code> 内部创建的箭头函数会捕获调用时<code>foo()</code>的this。由于 <code>foo()</code> 的this绑定到obj1，bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。（new也不行！）</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>两种形式的定义：声明（文字）形式和构造形式。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>了解一下，简单基本类型：<code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>和<code>undefined</code>。null有时会被当做一种对象类型，但是这其实只是语言本身的一个bug。</p><p>JS中有很多复杂基本类型。这些是一些特殊的对象子类型。函数就是对象的一个子类型（从技术角度来说就是“可调用的对象”）</p><p>Javascript中的函数是“一等公民”，因为它们本质上和普通的对象一样（只是可以调用），所以可以像操作其他对象一样操作函数（比如当做另一个函数的参数）。</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>内置对象有：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Object</code>、<code>Function</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code>和<code>Error</code>。</p><p>关于字面量的基本类型调用 <code>Object.prototype.toString()</code> 都会转化成对应的包装类型。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>内容听名字似乎存储在对象内部，其实在语言中，这些值的储存方式是多种多样的，一般不会存在对象容器的内部。存储在对象容器的内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置。</p><p><code>.a</code>通常指的是属性访问，[“a”] 语法通常被称为“键访问”。在 <code>[&quot;..&quot;]</code> 语法使用字符串来访问属性，所以可以在程序中构造这个字符串。</p><h3 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> prefix = <span class="string">"foo"</span>;</div><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">  [prefix + <span class="string">"bar"</span>]: <span class="string">"hello"</span>,</div><div class="line">  [prefix + <span class="string">"baz"</span>]: <span class="string">"world"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject[<span class="string">"foobar"</span>]; <span class="comment">// hello</span></div><div class="line">myObject[<span class="string">"foobaz"</span>]; <span class="comment">// world</span></div></pre></td></tr></table></figure><h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><p>如果访问的对象是一个函数，在JS中，我们喜欢称之为 “方法”，实际上呢，这个所谓的“方法”也仅仅是对方法的引用。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组支持[]访问形式，不过数组期待的是数字下标。所以你添加的属性值并不会使数组的<code>length</code>变长。你完全可以把数组当做一个普通的键/值对来使用。</p><p>而且要注意了：<strong>如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成<br>一个数值下标（因此会修改数组的内容而不是添加一个属性）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [ <span class="string">"foo"</span>, <span class="number">42</span>, <span class="string">"bar"</span> ];</div><div class="line"></div><div class="line">myArray[<span class="string">"3"</span>] = <span class="string">"baz"</span>;</div><div class="line"></div><div class="line">myArray.length; <span class="comment">// 4</span></div><div class="line"></div><div class="line">myArray[<span class="number">3</span>]; <span class="comment">// "baz"</span></div></pre></td></tr></table></figure><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>复制不可避免需要讨论到的就是深拷贝和浅拷贝。</p><p>对于JSON安全的对象，这有一种方法可以用：<code>var newObj = JSON.parse( JSON.stringify( someObj ) );</code></p><p>ES6中定义的 <code>Object.assign(..)</code> 可以用在浅拷贝上，<code>Object.assign(..)</code> 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或者多个源对象。它会遍历一个或多个源对象的多有自由键并把它们复制（使用 = 操作符赋值）到目标对象，最后返回目标对象。</p><h4 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h4><p>在ES5之前，JavaScript语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">a:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor( myObject, <span class="string">"a"</span> );</div><div class="line"></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">// value: 2,</span></div><div class="line"><span class="comment">// writable: true,</span></div><div class="line"><span class="comment">// enumerable: true,</span></div><div class="line"><span class="comment">// configurable: true</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptor(..)</code>和<code>Object.defineProperty(..)</code>了解一下。</p><p>常见配置：</p><ol><li>Writable 是否可以修改属性的值</li><li>Configurable 只要属性是可配置的，就可以使用 <code>defineProperty(..)</code> 方法来修改属性描述符。关于<code>Configurable</code>配置为false，<code>writable</code>可以由<code>true</code>变为<code>false</code>，并且不能再变回来啦！操作不可逆哈。</li><li>Enumerable 最后一个属性描述符（还有两个，我们会在介绍 getter 和 setter 时提到）<br>是 <code>enumerable</code>。</li></ol><p>放一下总结好了，这本书就总结到这里了：</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>JavaScript 中的对象有字面形式（比如 var a = { .. }）和构造形式（比如 var a = newArray(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。</p><p>许多人都以为“JavaScript 中万物都是对象”，这是错误的。对象是 6 个（或者是 7 个，取决于你的观点）基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。</p><p>对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作（在设置属性值时是 [[Put]]），[[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]]链（参见第 5 章）。</p><p>属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象（及其属性）的不可变性级别。</p><p>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。</p><p>你可以使用 ES6 的 for..of 语法来遍历数据结构（数组、对象，等等）中的值，for..of会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里我总结了下，《你不知道的javaScript上卷》第二部分的内容，总结的可能比较简短，相关的知识点，与设计模式中间有重合，设计模式中的相关设计模式，后期也会补上。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="你不知道的JS" scheme="https://hddhyq.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式与开发实践（一）</title>
    <link href="https://hddhyq.github.io/2018/05/02/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hddhyq.github.io/2018/05/02/JavaScript设计模式与开发实践（一）/</id>
    <published>2018-05-02T14:34:41.000Z</published>
    <updated>2018-07-08T04:25:55.512Z</updated>
    
    <content type="html"><![CDATA[<p>全书分为三部分，基础知识，设计模式，设计原则和编程技巧<br>下面我会简单的总结书中的一些有用的设计模式。<br><a id="more"></a><br><strong>第一部分 基础知识</strong></p><p>这一部分，我会快速总结相关的一些知识点，包括</p><ul><li>面向对象的JavaScript</li><li>this,call和apply</li><li>闭包和高阶函数</li></ul><h1 id="面向对象的JavaScript"><a href="#面向对象的JavaScript" class="headerlink" title="面向对象的JavaScript"></a>面向对象的JavaScript</h1><p>首先我们要了解一些基本概念，关于动态类型语言，鸭子类型，原型委托和多态以及原型模式等。</p><h2 id="动态类型语言和鸭子模式"><a href="#动态类型语言和鸭子模式" class="headerlink" title="动态类型语言和鸭子模式"></a>动态类型语言和鸭子模式</h2><p>所谓动态类型语言，必定是相对于静态类型语言所做的比较。</p><ul><li>静态类型语言的优点首先是在编译时就能发现类型不匹配的错误,编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。静态类型语言的缺点首先是迫使程序员依照强契约来编写程序,为每个变量规定数据类型。</li><li>动态类型语言的优点是编写的代码数量更少,看起来也更加简洁,程序员可以把精力更多地放在业务逻辑上面。动态类型语言的缺点是无法保证变量的类型,从而在程序的运行期有可能发生跟类型相关的错误。</li></ul><p>动态语言对变量类型的宽容建立在 <strong>鸭子类型(duck typing)</strong> 的概念。</p><p>所谓鸭子类型的主要思想就是：我们只需要关注对象的行为，或者叫需要对象实现的功能，而不需要关注对象本身。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的实际含义是:同一操作作用于不同的对象上面,可以产生不同的解释和不同的执行结果。换句话说,给不同的对象发送同一个消息的时候,这些对象会根据这个消息分别给出不同的反馈。</p><p>静态语言中，多态的实现需要抽象一个超类，通过继承来实现。</p><p>多态的思想主要是“做什么”和“谁去做”，这样我们就能消除类型之间的耦合关系，完成多态的实现。</p><p>多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性,从而消除这些条件分支语句。</p><p>下面来看一段简单的渲染map的代码，实现多态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> googleMap = &#123;</div><div class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染谷歌地图'</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> baiduMap = &#123;</div><div class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染百度地图'</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params"> map </span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> ( map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span> )&#123;</div><div class="line">        map.show();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">renderMap( googleMap );</div><div class="line">renderMap( baiduMap );</div><div class="line"></div><div class="line"><span class="comment">// 我们需要一个添加新的地图渲染，就死添加一个新的对象就行了，避免判断</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> sosoMap = &#123;</div><div class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染搜搜地图'</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">renderMap( sosoMap );</div></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在 JavaScript 或者其他语言中，封装有很多含义，不仅仅限定于封装数据，只要是将数据隐藏的“任何形式的封装”，我们都能够称之为封装。在 JS 中，我们常见的封装的封装形式就是作用域及闭包了。封装失对象之间的耦合变松散，我们只需要关注对象之间暴露的API，来实现所需功能了。</p><p>《设计模式》中有一段话用来描述封装</p><blockquote><p>“ 考虑你的设计中哪些地方可能变化,这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变,而是考虑你怎样才能够在不重新设计的情况下进行改变。这里的关键在于封装发生变化的概念,这是许多设计模式的主题。”</p></blockquote><p>这段话的核心也就是封装的本质， <strong>“找到变化并封装之”</strong>。</p><h2 id="原型模式和基于原型继承的-JavaScript-对象系统"><a href="#原型模式和基于原型继承的-JavaScript-对象系统" class="headerlink" title="原型模式和基于原型继承的 JavaScript 对象系统"></a>原型模式和基于原型继承的 JavaScript 对象系统</h2><p>如同题目所示，原型模式早就融入到 JavaScript 中了。原型模式不单是一种设计模式,也被称为一种编程泛型。</p><p>原型模式是用于创建对象的一种模式。原型模式的核心就是克隆，原型模式的关键也是语言本身是否提供 clone 方法。ECMAScript 5 提供了 Object.create方法,可以用来克隆对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Plane = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.blood = <span class="number">100</span>;</div><div class="line">    <span class="keyword">this</span>.attackLevel = <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.defenseLevel = <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> Plane();</div><div class="line">plane.blood = <span class="number">500</span>;</div><div class="line">plane.attackLevel = <span class="number">10</span>;</div><div class="line">plane.defenseLevel = <span class="number">7</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> clonePlane = <span class="built_in">Object</span>.create( plane );</div><div class="line"><span class="built_in">console</span>.log( clonePlane );<span class="comment">// 输出:Object &#123;blood: 500, attackLevel: 10, defenseLevel: 7&#125;</span></div></pre></td></tr></table></figure><p>不支持Object.create 方法的浏览器中,则可以使用以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.create = <span class="built_in">Object</span>.create || <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">    F.prototype = obj;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>JavaScript中的原型继承</strong></p><p>JavaScript遵循着一些原型编程的基本规则：</p><ul><li>所有的数据都是对象。</li><li>要得到一个对象,不是通过实例化类,而是找到一个对象作为原型并克隆它。</li><li>对象会记住它的原型。</li><li>如果对象无法响应某个请求,它会把这个请求委托给它自己的原型。</li></ul><ol><li><p>所有的数据都是对象</p><p> JavaScript 在设计的时候,模仿 Java 引入了两套类型机制:基本类型和对象类型。基本类型包括 undefined 、 number 、 boolean 、 string 、 function 、 object 。从现在看来,这并不是一个好的想法。</p><p> 按照 JavaScript 设计者的本意,除了 undefined 之外,一切都应是对象。为了实现这一目标,number 、 boolean 、 string 这几种基本类型数据也可以通过“包装类”的方式变成对象类型数据来处理。</p><p> 我们不能说在 JavaScript 中所有的数据都是对象,但可以说绝大部分数据都是对象。那么相信在 JavaScript 中也一定会有一个根对象存在,这些对象追根溯源都来源于这个根对象。</p><p> 事实上,JavaScript 中的根对象是 Object.prototype 对象。 Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象,实际上都是从 Object.prototype 对象克隆而来的,Object.prototype 对象就是它们的原型。比如下面的 obj1 对象和 obj2 对象:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</div></pre></td></tr></table></figure><p> 可以利用 ECMAScript 5 提供的 Object.getPrototypeOf 来查看这两个对象的原型:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( obj1 ) === <span class="built_in">Object</span>.prototype ); <span class="comment">// 输出:true</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( obj2 ) === <span class="built_in">Object</span>.prototype ); <span class="comment">// 输出:true</span></div></pre></td></tr></table></figure></li><li><p>要得到一个对象,不是通过实例化类,而是找到一个对象作为原型并克隆它</p><p> 了解下，我们new运算符从构造琦中得到一个对象的过程。</p><p> 当使用 new 运算符来调用函数时,此时的函数就是一个构造器。 用new 运算符来创建对象的过程,实际上也只是先克隆 Object.prototype 对象,再进行一些其他额外操作的过程。</p></li><li><p>对象会记住它的原型</p><p> 就 JavaScript 的真正实现来说，其实不能说对象有原型，而至能说对象的构造器有原型。对于”对象吧把请求委托给它自己的原型“这句话，更好的说法是对象委托给它的构造器的原型。那么队形如何把请求顺利的转交给它的构造器的原型呢？</p><p> JavaScript 给对象提供了一个名为 <strong>proto</strong> 的隐藏属性,某个对象的 <strong>proto</strong> 属性默认会指向它的构造器的原型对象,即 {Constructor}.prototype 。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="built_in">console</span>.log ( a.__proto__=== <span class="built_in">Object</span>.prototype );</div><div class="line"><span class="comment">// 输出:true</span></div></pre></td></tr></table></figure><p> 实际上, <strong>proto</strong> 就是对象跟“对象构造器的原型”联系起来的纽带。正因为对象要通过<strong>proto</strong> 属性来记住它的构造器的原型,所以我们用上一节的 objectFactory 函数来模拟用 new创建对象时, 需要手动给 obj 对象设置正确的 <strong>proto</strong> 指向。</p></li><li><p>如果对象无法响应某个请求,它会把这个请求委托给它的构造器的原型</p><p> 这条规则即是原型继承的精髓所在。</p><p> 在 JavaScript 中,每个对象都是从 Object.prototype 对象克隆而来的,如果是这样的话,我们只能得到单一的继承关系,即每个对象都继承自 Object.prototype 对象,这样的对象系统显然是非常受限的。</p><p> 实际上,虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的,但对象构造器的原型并不仅限于 Object.prototype 上,而是可以动态指向其他对象。这样一来,当对象 a 需要借用对象 b 的能力时,可以有选择性地把对象 a 的构造器的原型指向对象 b ,从而达到继承的效果。下面的代码是我们最常用的原型继承方式:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">A.prototype = obj;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log( a.name );</div></pre></td></tr></table></figure><p> 我们来看看执行这段代码的时候,引擎做了哪些事情。</p><ul><li>首先,尝试遍历对象 a 中的所有属性,但没有找到 name 这个属性。</li><li>查找 name 属性的这个请求被委托给对象 a 的构造器的原型,它被 a. <strong>proto</strong> 记录着并且<br>指向 A.prototype ,而 A.prototype 被设置为对象 obj 。</li><li><p>在对象 obj 中找到了 name 属性,并返回它的值。</p><p>当我们期望得到一个“类”继承自另外一个“类”的效果时,往往会用下面的代码来模拟实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">A.prototype = &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">B.prototype = <span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line"><span class="built_in">console</span>.log( b.name ); <span class="comment">// 输出:sven</span></div></pre></td></tr></table></figure><p>再看这段代码执行的时候,引擎做了什么事情。</p></li><li><p>首先,尝试遍历对象 b 中的所有属性,但没有找到 name 这个属性。</p></li><li>查找 name 属性的请求被委托给对象 b 的构造器的原型,它被 b. <strong>proto</strong> 记录着并且指向B.prototype ,而 B.prototype 被设置为一个通过 new A() 创建出来的对象。</li><li>在该对象中依然没有找到 name 属性,于是请求被继续委托给这个对象构造器的原型A.prototype 。</li><li>在 A.prototype 中找到了 name 属性,并返回它的值。</li></ul></li></ol><h2 id="this-、-call-和-apply"><a href="#this-、-call-和-apply" class="headerlink" title="this 、 call 和 apply"></a>this 、 call 和 apply</h2><p>在 JavaScript 的this总是指向一个对象，而具体指向那个对象是运行时 <strong>基于函数的执行环境动态绑定的</strong>，而非函数被声明时的环境。</p><h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><p>除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下四种。</p><ul><li>作为对象的方法调用。</li><li>作为普通函数调用。</li><li>构造器调用。</li><li>Function.prototype.call 或 Function.prototype.apply 调用。</li></ul><h3 id="1-作为对象的方法调用"><a href="#1-作为对象的方法调用" class="headerlink" title="1. 作为对象的方法调用"></a>1. 作为对象的方法调用</h3><p>当函数作为对象的方法被调用时，this指向该对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span> === obj); <span class="comment">// 输出：true</span></div><div class="line">        alert ( <span class="keyword">this</span>.a ); <span class="comment">// 输出: 1 </span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.getA();</div></pre></td></tr></table></figure><h3 id="2-作为普通函数调用"><a href="#2-作为普通函数调用" class="headerlink" title="2. 作为普通函数调用"></a>2. 作为普通函数调用</h3><p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指<br>向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getName());  <span class="comment">// globalName</span></div></pre></td></tr></table></figure><p>注意一下，下面这个例子阐释了this在runtime定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">    name: <span class="string">'sven'</span>,</div><div class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> getName = myObject.getName;</div><div class="line"><span class="built_in">console</span>.log(getName());    <span class="comment">// globalName</span></div></pre></td></tr></table></figure></p><h3 id="3-构造器调用"><a href="#3-构造器调用" class="headerlink" title="3. 构造器调用"></a>3. 构造器调用</h3><p>JavaScript 中没有类，但是能通过 new 运算符从构造器中创建对象。</p><p>除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象，见如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</div><div class="line">alert(obj.name); <span class="comment">// anne</span></div></pre></td></tr></table></figure></p><p>但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span>,</div><div class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 显式地返回一个对象</span></div><div class="line">        name: <span class="string">'anne'</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</div><div class="line">alert(obj.name);</div></pre></td></tr></table></figure><p>如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'anne'</span>; <span class="comment">// 返回 string 类型</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</div><div class="line">alert ( obj.name ); <span class="comment">// 输出：sven</span></div></pre></td></tr></table></figure></p><h3 id="4-Function-prototype-call-或-Function-prototype-apply-调用"><a href="#4-Function-prototype-call-或-Function-prototype-apply-调用" class="headerlink" title="4.  Function.prototype.call 或 Function.prototype.apply 调用"></a>4.  Function.prototype.call 或 Function.prototype.apply 调用</h3><p>跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    name: <span class="string">'sven'</span>,</div><div class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">    name: <span class="string">'anne'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( obj1.getName() ); <span class="comment">// 输出: sven</span></div><div class="line"><span class="built_in">console</span>.log( obj1.getName.call( obj2 ) ); <span class="comment">// 输出：anne</span></div></pre></td></tr></table></figure><h3 id="丢失的this"><a href="#丢失的this" class="headerlink" title="丢失的this"></a>丢失的this</h3><p>何为丢失的this呢？</p><p>其实主要this的指向是runtime的，前面的对象的方法的函数在外部调用也是这个意思哈。</p><h3 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h3><p>call和apply的区别主要就是在传入的参数形式不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> a, b, c </span>)</span>&#123;</div><div class="line">    alert ( [ a, b, c ] ); <span class="comment">// 输出 [ 1, 2, 3 ]</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">func.apply( <span class="literal">null</span>, [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] ); </div><div class="line"></div><div class="line">func.call( <span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> );</div></pre></td></tr></table></figure><p><strong>call和apply的用途</strong></p><ol><li>改变 this 指向</li><li>Function.prototype.bind</li></ol><p>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><p>bind, 没错就是一个语法糖。当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。</p><ol start="3"><li>借用其他对象的方法<br>借用方法的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    A.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">&#125;;</div><div class="line">B.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B( <span class="string">'sven'</span> );</div><div class="line"><span class="built_in">console</span>.log( b.getName() ); <span class="comment">// 输出： 'sven'</span></div></pre></td></tr></table></figure></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">Array</span>.prototype.push.call( <span class="built_in">arguments</span>, <span class="number">3</span> );</div><div class="line">    <span class="built_in">console</span>.log ( <span class="built_in">arguments</span> ); <span class="comment">// 输出[1,2,3]</span></div><div class="line">&#125;)( <span class="number">1</span>, <span class="number">2</span> );</div></pre></td></tr></table></figure><p>想把 arguments 转成真正的数组的时候，可以借用 Array.prototype.slice 方法；想截去<br>arguments 列表中的头一个元素时，又可以借用 Array.prototype.shift 方法。那么这种机制的内<br>部实现原理是什么呢？我们不妨翻开 V8 的引擎源码，以 Array.prototype.push 为例，看看 V8 引<br>擎中的具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> n = TO_UINT32( <span class="keyword">this</span>.length ); <span class="comment">// 被 push 的对象的 length</span></div><div class="line">    <span class="keyword">var</span> m = %_ArgumentsLength(); <span class="comment">// push 的参数个数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">        <span class="keyword">this</span>[ i + n ] = %_Arguments( i ); <span class="comment">// 复制元素 (1)</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.length = n + m; <span class="comment">// 修正 length 属性的值 (2)</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>Array.prototype.slice 实现条件：</p><ul><li>对象本身要可以存取属性</li><li>对象的 length 属性可读写</li></ul><h2 id="闭包和高阶函数"><a href="#闭包和高阶函数" class="headerlink" title="闭包和高阶函数"></a>闭包和高阶函数</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>对于 JavaScript 程序员来说，闭包（closure）是一个难懂又必须征服的概念。闭包的形成与变量的作用域以及变量的生存周期密切相关。下面我们先简单了解这两个知识点。</p><h4 id="1-变量的作用域"><a href="#1-变量的作用域" class="headerlink" title="1. 变量的作用域"></a>1. 变量的作用域</h4><p>当再函数中声明一个变量的时候，如果该变量前面没有带上关键字var，这个变量就会成为全局变量。所以避免变量声明前面不加声明关键词。</p><h4 id="2-变量的生存周期"><a href="#2-变量的生存周期" class="headerlink" title="2. 变量的生存周期"></a>2. 变量的生存周期</h4><p>除了变量的作用域之外，另外一个跟闭包有关的概念是变量的生存周期。</p><p>对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。</p><p>而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        a++;</div><div class="line">        alert(a);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f = func();</div><div class="line"></div><div class="line">f(); <span class="comment">// 输出：2</span></div><div class="line">f(); <span class="comment">// 输出：3</span></div><div class="line">f(); <span class="comment">// 输出：4</span></div><div class="line">f(); <span class="comment">// 输出：5</span></div></pre></td></tr></table></figure><p>在这里我们推出函数后，局部变量 a 并没有消失，而是似乎一直在某个地方存活着。原因是：当执行 var发= function();时，f返回一个匿名函数的引用，它可以访问到func()被调用是产生的环境，而局部变量a一直处在这个环境里。既然局部变量所在环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里就产生了一个闭包结构，局部变量的生命看起来被延续了。</p><p>闭包的一个经典应用是之前var声明的循环遍历中使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">        setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(i)</div><div class="line">        &#125;)(j), <span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func() <span class="comment">// 0, 1, 2, 3, 4</span></div></pre></td></tr></table></figure></p><h4 id="闭包的更多作用"><a href="#闭包的更多作用" class="headerlink" title="闭包的更多作用"></a>闭包的更多作用</h4><ol><li><p>封装变量<br>闭包可以帮助把一些不需要暴露在全局的变量封装乘“私有变量”。假设一个计算乘积的简单函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> calculate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++) &#123;</div><div class="line">            a = a * <span class="built_in">arguments</span>[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">','</span>);</div><div class="line">        <span class="keyword">if</span> ( args <span class="keyword">in</span> cache )&#123;</div><div class="line">            <span class="keyword">return</span> cache[ args ];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cache[args] = calculate.apply( <span class="literal">null</span>, <span class="built_in">arguments</span> );</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></li><li><p>延续局部变量的寿命</p></li></ol><p>####　闭包和面向对象设计<br>过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程,而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能,用闭包也能实现。反之亦然。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 闭包写法</span></div><div class="line"><span class="keyword">var</span> extent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        call: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            value++;</div><div class="line">            <span class="built_in">console</span>.log(value)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> extent = extent();</div><div class="line"></div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line"></div><div class="line"><span class="comment">// 面向对象写法</span></div><div class="line"><span class="keyword">var</span> extent = &#123;</div><div class="line">    value: <span class="number">0</span>,</div><div class="line">    call: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line"></div><div class="line"><span class="comment">// 原型写法</span></div><div class="line"><span class="keyword">var</span> Extent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Extent.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value++;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> extent = <span class="keyword">new</span> Extent();</div><div class="line"></div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line">extent.call();</div></pre></td></tr></table></figure><p>关于闭包域内存管理，将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时,就会删除这些值并回收它们占用的内存。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是指至少满足下列条件之一的函数。</p><ul><li>函数可以作为参数被传递;</li><li>函数可以作为返回值输出。</li></ul><h4 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h4><p>把函数当作参数传递,这代表我们可以抽离出一部分容易变化的业务逻辑,把这部分业务逻辑放在函数参数中,这样一来可以分离业务代码中变化与不变的部分。其中一个重要应用场景就是常见的回调函数。</p><ol><li>回调函数</li><li>Array.prototype.sort</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span> ].sort( <span class="function"><span class="keyword">function</span>(<span class="params"> a, b </span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 输出: [ 1, 3, 4 ]</span></div></pre></td></tr></table></figure><h4 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h4><p>相比把函数当作参数传递,函数当作返回值输出的应用场景也许更多,也更能体现函数式编程的巧妙。让函数继续返回一个可执行的函数,意味着运算过程是可延续的。</p><h4 id="高阶函数实现AOP"><a href="#高阶函数实现AOP" class="headerlink" title="高阶函数实现AOP"></a>高阶函数实现AOP</h4><p>这一部分到后面装饰者模式再细讲。</p><h4 id="高阶函数的其他应用"><a href="#高阶函数的其他应用" class="headerlink" title="高阶函数的其他应用"></a>高阶函数的其他应用</h4><ol><li>currenying</li></ol><p>首先我们讨论的是函数柯里化。currying 又称部分求值。一个 currying 的函数首先会接受一些参数,接受了这些参数之后,该函数并不会立即求值,而是继续返回另外一个函数,刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候,之前传入的所有参数都会被一次性用于求值。</p><ol start="2"><li>uncurrying</li></ol><p>在 JavaScript 中，当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点，也是常说的鸭子类型思想。</p><p>同理，一个对象也未必只能使用它自身的方法，那么有什么办法可以让对象去借用一个原本不属于它的方法呢？</p><p>这里我们借用了一个泛化this的过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">return</span> self.apply(obj, <span class="built_in">arguments</span>)</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// var push = Array.prototype.push.uncurrying();</span></div><div class="line"></div><div class="line"><span class="comment">// (function() &#123;</span></div><div class="line"><span class="comment">//     push(arguments, 4);</span></div><div class="line"><span class="comment">//     console.log(arguments);</span></div><div class="line"><span class="comment">// &#125;)(1,2,3)</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, fn, arr = [<span class="string">'push'</span>, <span class="string">'shift'</span>, <span class="string">'forEach'</span>]; fn = arr[i++];) &#123;</div><div class="line">    <span class="built_in">Array</span>[fn] = <span class="built_in">Array</span>.prototype[fn].uncurrying();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;     </div><div class="line">    <span class="string">'length'</span>: <span class="number">3</span>,</div><div class="line">    <span class="string">'0'</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">'1'</span>: <span class="number">2</span>,</div><div class="line">    <span class="string">'2'</span>: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.push(obj, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(obj.length)</div></pre></td></tr></table></figure><ol start="3"><li>函数节流</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全书分为三部分，基础知识，设计模式，设计原则和编程技巧&lt;br&gt;下面我会简单的总结书中的一些有用的设计模式。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="设计模式" scheme="https://hddhyq.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS中排序和搜索算法</title>
    <link href="https://hddhyq.github.io/2018/02/23/JS%E4%B8%AD%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <id>https://hddhyq.github.io/2018/02/23/JS中排序和搜索算法/</id>
    <published>2018-02-23T06:51:34.000Z</published>
    <updated>2018-07-08T04:25:55.512Z</updated>
    
    <content type="html"><![CDATA[<p>看《学习JavaScript数据结构与算法》，总结了下常用的排序，如冒泡排序、选择排序、插入排序、归并排序和快速排序，以及顺序搜索和二分搜索算法。<br><a id="more"></a></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序算法之前，我们需要创建一个数组表示待排序和搜索的数据结构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayList</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> array = []; <span class="comment">//&#123;1&#125;</span></div><div class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    array.push(item);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.toString= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//&#123;3&#125;</span></div><div class="line">    <span class="keyword">return</span> array.join();</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序最简单，不过它的时间复杂度也是最大的。</p><p>冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length; <span class="comment">//&#123;1&#125;</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length; i++)&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;length<span class="number">-1</span>; j++ )&#123; <span class="comment">//&#123;3&#125;</span></div><div class="line">      <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>])&#123; <span class="comment">//&#123;4&#125;</span></div><div class="line">        swap(array, j, j+<span class="number">1</span>); <span class="comment">//&#123;5&#125;</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="keyword">var</span> swap = <span class="function"><span class="keyword">function</span>(<span class="params">array, index1, index2</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> aux = array[index1];</div><div class="line">  array[index1] = array[index2];</div><div class="line">  array[index2] = aux;</div><div class="line">&#125;; <span class="comment">// 一个私有函数，只能用在ArrayList类的内部代码中</span></div><div class="line"></div><div class="line"><span class="comment">// 可以用ES6的数组拓展</span></div><div class="line"><span class="comment">// [array[index1], array[index2]] = [array[index2], array[index1]];</span></div></pre></td></tr></table></figure><p>首先，声明一个名为length的变量，用来存储数组的长度（行{1}）。这一步可选，它能帮助我们在行{2}和行{3}时直接使用数组的长度。接着，外循环（行{2}）会从数组的第一位迭代至最后一位，它控制了在数组中经过多少轮排序（应该是数组中每项都经过一轮，轮数和数组长度一致）。然后，内循环将从第一位迭代至倒数第二位，内循环实际上进行当前项和下一项的比较（行{4}）。如果这两项顺序不对（当前项比下一项大），则交换它们（行{5}），意思是位置为j+1的值将会被换置到位置j处，反之亦然。</p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//sortWithJs/冒泡算法.png" alt=""></p><p><strong>改进冒泡算法</strong><br>如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较。<br><img src="http://p1aqu3lsq.bkt.clouddn.com//sortWithJs/改进冒泡算法.png" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.modifiedBubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;length<span class="number">-1</span>-i; j++ )&#123;</div><div class="line">      <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>])&#123;</div><div class="line">        swap(j, j+<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>最后，这个排序的事件复杂度是O(n²)。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, <span class="comment">//&#123;1&#125;</span></div><div class="line">    indexMin;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length<span class="number">-1</span>; i++)&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">      indexMin = i; <span class="comment">//&#123;3&#125;</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j=i; j&lt;length; j++)&#123; <span class="comment">//&#123;4&#125;</span></div><div class="line">      <span class="keyword">if</span>(array[indexMin]&gt;array[j])&#123; <span class="comment">//&#123;5&#125;</span></div><div class="line">        indexMin = j; <span class="comment">//&#123;6&#125;</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i !== indexMin)&#123; <span class="comment">//&#123;7&#125;</span></div><div class="line">    swap(i, indexMin);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>首先声明一些将在算法内使用的变量（行{1}）。接着，外循环（行{2}）迭代数组，并控制迭代轮次（数组的第n个值——下一个最小值）。我们假设本迭代轮次的第一个值为数组最小值（行{3}）。然后，从当前i的值开始至数组结束（行{4}），我们比较是否位置j的值比当前最小值小（行{5}）；如果是，则改变最小值至新最小值（行{6}）。当内循环结束（行{4}），将得出数组第n小的值。最后，如果该最小值和原最小值不同（行{7}），则交换其值。</p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//sortWithJs/选择排序.png" alt=""></p><p>选择排序同样也是一个复杂度为O(n²)的算法。和冒泡排序一样，它包含有嵌套的两个循环，这导致了二次方的复杂度。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, <span class="comment">//&#123;1&#125;</span></div><div class="line">      j, temp;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;length; i++)&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    j = i; <span class="comment">//&#123;3&#125;</span></div><div class="line">    temp = array[i]; <span class="comment">//&#123;4&#125;</span></div><div class="line">    <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; array[j<span class="number">-1</span>] &gt; temp)&#123; <span class="comment">//&#123;5&#125;</span></div><div class="line">      array[j] = array[j<span class="number">-1</span>]; <span class="comment">//&#123;6&#125;</span></div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    array[j] = temp; <span class="comment">//&#123;7&#125;</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>算法的第一行用来声明代码中使用的变量（行{1}）。接着，迭代数组来给第i项找到正确的位置（行{2}）。注意，算法是从第二个位置（索引1）而不是0位置开始的（我们认为第一项已排序了）。然后，用i的值来初始化一个辅助变量（行{3}）并将其值亦存储于一临时变量中（行{4}），便于之后将其插入到正确的位置上。下一步是要找到正确的位置来插入项目。只要变量j比0大（因为数组的第一个索引是0——没有负值的索引）并且数组中前面的值比待比较的值大（行{5}），我们就把这个值移到当前位置上（行{6}）并减小j。最终，该项目能插入到正确的位置上。</p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//sortWithJs/插入排序.png" alt=""></p><p>排序小型数组时，此算法比选择排序和冒泡排序性能要好。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是第一个可以被实际使用的排序算法。，其复杂度为O(nlogⁿ)。</p><blockquote><p>JavaScript的Array类定义了一个sort函数（Array.prototype.sort）用以排序JavaScript数组（我们不必自己实现这个算法）。ECMAScript没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox使用归并排序作为Array.prototype.sort的实现，而Chrome使用了一个快速排序（下面我们会学习的）的变体。</p></blockquote><p>归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  array = mergeSortRec(array);</div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="keyword">var</span> mergeSortRec = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length;</div><div class="line">  <span class="keyword">if</span>(length === <span class="number">1</span>) &#123; <span class="comment">//&#123;1&#125;</span></div><div class="line">    <span class="keyword">return</span> array; <span class="comment">//&#123;2&#125;</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>), <span class="comment">//&#123;3&#125;</span></div><div class="line">    left = array.slice(<span class="number">0</span>, mid), <span class="comment">//&#123;4&#125;</span></div><div class="line">    right = array.slice(mid, length); <span class="comment">//&#123;5&#125;</span></div><div class="line">  <span class="keyword">return</span> merge(mergeSortRec(left), mergeSortRec(right)); <span class="comment">//&#123;6&#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>归并排序将一个大数组转化为多个小数组直到只有一个项。由于算法是递归的，我们需要一个停止条件，在这里此条件是判断数组的长度是否为1（行{1}）。如果是，则直接返回这个长度为1的数组（行{2}），因为它已排序了。</p><p>如果数组长度比1大，那么我们得将其分成小数组。为此，首先得找到数组的中间位（行{3}），找到后我们将数组分成两个小数组，分别叫作left（行{4}）和right（行{5}）。left数组由索引0至中间索引的元素组成，而right数组由中间索引至原始数组最后一个位置的元素组成。</p><p>下面的步骤是调用merge函数（行{6}），它负责合并和排序小数组来产生大数组，直到回到原始数组并已排序完成。为了不断将原始数组分成小数组，我们得再次对left数组和right数组递归调用mergeSortRec，并同时作为参数传递给merge函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> result = [], <span class="comment">// &#123;7&#125;</span></div><div class="line">      il = <span class="number">0</span>,</div><div class="line">      ir = <span class="number">0</span>; </div><div class="line">  <span class="keyword">while</span>(il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; <span class="comment">// &#123;8&#125;</span></div><div class="line">    <span class="keyword">if</span>(left[il] &lt; right[ir]) &#123;</div><div class="line">      result.push(left[il++]); <span class="comment">// &#123;9&#125;</span></div><div class="line">    &#125; <span class="keyword">else</span>&#123;</div><div class="line">      result.push(right[ir++]); <span class="comment">// &#123;10&#125;</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (il &lt; left.length)&#123; <span class="comment">// &#123;11&#125;</span></div><div class="line">    result.push(left[il++]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (ir &lt; right.length)&#123; <span class="comment">// &#123;12&#125;</span></div><div class="line">    result.push(right[ir++]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result; <span class="comment">// &#123;13&#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>merge函数接受两个数组作为参数，并将它们归并至一个大数组。排序发生在归并过程中。首先，需要声明归并过程要创建的新数组以及用来迭代两个数组（left和right数组）所需的两个变量（行{7}）。迭代两个数组的过程中（行{8}），我们比较来自left数组的项是否比来自right数组的项小。如果是，将该项从left数组添加至归并结果数组，并递增迭代数组的控制变量（行{9}）；否则，从right数组添加项并递增相应的迭代数组的控制变量（行{10}）。</p><p>接下来，将left数组或者right数组所有剩余的项添加到归并数组中（行{11}和行{12}）。最后，将归并数组作为结果返回（行{13}）。</p><p>如果执行mergeSort函数，下图是具体的执行过程：<br><img src="http://p1aqu3lsq.bkt.clouddn.com//sortWithJs/归并排序.png" alt=""></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序也许是最常用的排序算法了。它的复杂度为O(nlogⁿ)，且它的性能通常比其他的复杂度为O(nlogⁿ)的排序算法要好。和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）。</p><p>快速排序比到目前为止你学过的其他排序算法要复杂一些。让我们一步步地来学习。</p><ol><li>首先，从数组中选择中间一项作为主元。</li><li>创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分操作。</li><li>接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.quickSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> quick(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>就像归并算法那样，开始我们声明一个主方法来调用递归函数，传递待排序数组，以及索引<br>0及其最末的位置（因为我们要排整个数组，而不是一个子数组）作为参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> quick = <span class="function"><span class="keyword">function</span>(<span class="params">array, left, right</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> index; <span class="comment">//&#123;1&#125;</span></div><div class="line">  <span class="keyword">if</span> (array.length &gt; <span class="number">1</span>) &#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    index = partition(array, left, right); <span class="comment">//&#123;3&#125;</span></div><div class="line">    <span class="keyword">if</span> (left &lt; index - <span class="number">1</span>) &#123; <span class="comment">//&#123;4&#125;</span></div><div class="line">      quick(array, left, index - <span class="number">1</span>); <span class="comment">//&#123;5&#125;</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (index &lt; right) &#123; <span class="comment">//&#123;6&#125;</span></div><div class="line">      quick(array, index, right); <span class="comment">//&#123;7&#125;</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>首先声明index（行{1}），该变量能帮助我们将子数组分离为较小值数组和较大值数组，这样，我们就能再次递归的调用quick函数了。partition函数返回值将赋值给index（行{3}）。</p><p>如果数组的长度比1大（因为只有一个元素的数组必然是已排序了的（行{2}），我们将对给定子数组执行partition操作（第一次调用是针对整个数组）以得到index（行{3}）。如果子数组存在较小值的元素（行{4}），则对该数组重复这个过程（行{5}）。同理，对存在较大值得子数组也是如此，如果存在子数组存在较大值，我们也将重复快速排序过程（行{7}）。</p><h3 id="1-划分过程"><a href="#1-划分过程" class="headerlink" title="1. 划分过程"></a>1. 划分过程</h3><p>第一件要做的事情是选择主元（pivot），有好几种方式。最简单的一种是选择数组的第一项（最左项）。然而，研究表明对于几乎已排序的数组，这不是一个好的选择，它将导致该算法的最差表现。另外一种方式是随机选择一个数组项或是选择中间项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span>(<span class="params">array, left, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> pivot = array[<span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)], <span class="comment">//&#123;8&#125;</span></div><div class="line">      i = left, <span class="comment">//&#123;9&#125;</span></div><div class="line">      j = right; <span class="comment">//&#123;10&#125;</span></div><div class="line">  <span class="keyword">while</span> (i &lt;= j) &#123; <span class="comment">//&#123;11&#125;</span></div><div class="line">    <span class="keyword">while</span> (array[i] &lt; pivot) &#123; <span class="comment">//&#123;12&#125;</span></div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (array[j] &gt; pivot) &#123; <span class="comment">//&#123;13&#125;</span></div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i &lt;= j) &#123; <span class="comment">//&#123;14&#125;</span></div><div class="line">      swap(array, i, j); <span class="comment">//&#123;15&#125;</span></div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> i; <span class="comment">//&#123;16&#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>在本实现中，我们选择中间项作为主元（行{8}）。我们初始化两个指针：left（低——行{9}），初始化为数组第一个元素；right（高——行{10}），初始化为数组最后一个元素。</p><p>只要left和right指针没有相互交错（行{11}），就执行划分操作。首先，移动left指针直到找到一个元素比主元大（行{12}）。对right指针，我们做同样的事情，移动right指针直到我们找到一个元素比主元小。</p><p>当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大（行{14}），意思是左项比右项大（值比较）。我们交换它们，然后移动两个指针，并重复此过程（从行{11}再次开始）。</p><p>在划分操作结束后，返回左指针的索引，用来在行{3}处创建子数组。</p><h3 id="2-快速排序实战"><a href="#2-快速排序实战" class="headerlink" title="2. 快速排序实战"></a>2. 快速排序实战</h3><p><img src="http://p1aqu3lsq.bkt.clouddn.com//sortWithJs/快排1.png" alt=""><br><img src="http://p1aqu3lsq.bkt.clouddn.com//sortWithJs/快排2.png" alt=""><br><img src="http://p1aqu3lsq.bkt.clouddn.com//sortWithJs/快排3.png" alt=""><br><img src="http://p1aqu3lsq.bkt.clouddn.com//sortWithJs/快排4.png" alt=""><br><img src="http://p1aqu3lsq.bkt.clouddn.com//sortWithJs/快排5.png" alt=""></p><h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="顺序搜索"><a href="#顺序搜索" class="headerlink" title="顺序搜索"></a>顺序搜索</h2><p>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.sequentialSearch = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</div><div class="line">    <span class="keyword">if</span> (item === array[i])</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>二分搜索算法的原理和猜数字游戏类似，就是那个有人说“我正想着一个1到100的数字”的游戏。我们每回应一个数字，那个人就会说这个数字是高了、低了还是对了。</p><p>这个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。</p><ol><li>选择数组的中间值。</li><li>如果选中值是待搜索值，那么算法执行完毕（值找到了）。</li><li>如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。</li><li>如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.binarySearch = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.quickSort();</div><div class="line">  <span class="keyword">var</span> low = <span class="number">0</span>,</div><div class="line">    high = array.length - <span class="number">1</span>,</div><div class="line">    mid, element;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (low &lt;= high)&#123;</div><div class="line">    mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</div><div class="line">    element = array[mid];</div><div class="line">    <span class="keyword">if</span> (element &lt; item) &#123;</div><div class="line">      low = mid + <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &gt; item) &#123;</div><div class="line">      high = mid - <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>开始前需要先将数组排序，我们可以选择快速排序等。</p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//sortWithJs/排序时间复杂度.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看《学习JavaScript数据结构与算法》，总结了下常用的排序，如冒泡排序、选择排序、插入排序、归并排序和快速排序，以及顺序搜索和二分搜索算法。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="算法" scheme="https://hddhyq.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Cnode-Pwa 过程中的小坑</title>
    <link href="https://hddhyq.github.io/2018/02/21/Vue-Cnode-Pwa-%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
    <id>https://hddhyq.github.io/2018/02/21/Vue-Cnode-Pwa-过程中的小坑/</id>
    <published>2018-02-21T13:34:46.000Z</published>
    <updated>2018-07-08T04:25:55.512Z</updated>
    
    <content type="html"><![CDATA[<p>总结下开发过程中的一些小坑。<br><a id="more"></a></p><h1 id="项目概括"><a href="#项目概括" class="headerlink" title="项目概括"></a>项目概括</h1><p>线上地址<a href="https://brokenbones.xyz" target="_blank" rel="noopener">https://brokenbones.xyz</a></p><h2 id="页面编写"><a href="#页面编写" class="headerlink" title="页面编写"></a>页面编写</h2><p>页面编写主要采用的MVVM框架<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js</a>开发，是直接用的vue-cli脚手架提供的PWA模板,页面样式采用的是<a href="https://vuetifyjs.com/zh-Hans/" target="_blank" rel="noopener">vuetify</a>，数据管理用的是<a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="noopener">vuex</a>，api通讯采用的<a href="http://www.bootcdn.cn/axios/readme/" target="_blank" rel="noopener">axios</a>,页面的路由采用的<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">vue-router</a>，其中我才用了history模式，这种模式更适合PWA。边写文章部分，采用了，Mavon-Editor的markdown编辑器。</p><h2 id="PWA部分"><a href="#PWA部分" class="headerlink" title="PWA部分"></a>PWA部分</h2><p>主要是自己编写了<code>mainfest.json</code>，sw.js则是利用<strong>sw-precahe-webpack-plugin</strong>生成。</p><h2 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h2><p>PWA应用必须采用https,这里我用的是腾讯云的免费的SSL证书，配置十分方便，推荐，免费一年。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>根据路由拆分=&gt;项目的主要page有：</p><ul><li>主题列表<ul><li>全部</li><li>精华</li><li>分享</li><li>问答</li><li>招聘</li><li>测试</li></ul></li><li>主题详情<ul><li>文章部分</li><li>文章回复列表</li><li>回复收藏文章、点赞和回复他人评论</li></ul></li><li>个人中心<ul><li>最近回复</li><li>最近发布</li><li>话题收藏</li></ul></li><li>我的消息<ul><li>已读消息</li><li>未读消息</li></ul></li><li>新建主题<ul><li>Mavon-Editor</li></ul></li><li>关于</li></ul><p><strong>项目准备工作</strong></p><p>主要是，对常见的字体和ret.styl进行打包下载，也观察了其他一些人做相同的社区的页面的结构。</p><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="路由部分"><a href="#路由部分" class="headerlink" title="路由部分"></a>路由部分</h2><p>这个项目让我对vue-router的认识更加深了一步。</p><h3 id="HTML5-history模式"><a href="#HTML5-history模式" class="headerlink" title="HTML5 history模式"></a>HTML5 history模式</h3><p>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p><p>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p><p>当你使用 history 模式时，URL 就像正常的 url，例如 <a href="http://yoursite.com/user/id" target="_blank" rel="noopener">http://yoursite.com/user/id</a>　，也好看！</p><p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a href="http://oursite.com/user/id" target="_blank" rel="noopener">http://oursite.com/user/id</a> 就会返回 404，这就不好看了。</p><p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p><p>后端配置见:<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">后端配置</a></p><p>最后，给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  mode: <span class="string">'history'</span>,</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'*'</span>, <span class="attr">component</span>: NotFoundComponent &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h3 id="导航守卫和watch路由变化"><a href="#导航守卫和watch路由变化" class="headerlink" title="导航守卫和watch路由变化"></a>导航守卫和watch路由变化</h3><p>导航守卫有：</p><ul><li>beforeRouteEnter</li><li>beforeRouteUpdate (2.2 新增)</li><li>beforeRouteLeave</li></ul><p>这个项目中，我用了直接的<code>watch</code>路由变化和<code>beforeRouteUpdate</code></p><p>主题详情界面有五个分路由，全部、问答和测试等。在路由设置中，我们保持的keep-alive，这样可以保持组件的状态保持，对于项目的体验比较好。可是页面的路由变化，如果使用的是同一组件的时候，页面的内容就不会变化，像主题的切换和主题详情的内容的变化等，这是我们就需要利用<br><code>beforeRouteUpdate</code>或者<code>watch</code>路由的变化。</p><p>例如，ListView组件中的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">beforeRouteUpdate(to, <span class="keyword">from</span>, next) &#123;</div><div class="line">  <span class="keyword">this</span>.postList = []</div><div class="line">  <span class="keyword">this</span>.getTabData(to.query.tab)</div><div class="line">  next()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>和TopicDetail中的<code>watch</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">watch: &#123;</div><div class="line">  $route(to, <span class="keyword">from</span>) &#123;</div><div class="line">    <span class="comment">// 理解一下to＝＝要去的路由 记录TopicId,避免相同页面再重复加载</span></div><div class="line">    <span class="comment">// this.topic = []</span></div><div class="line">    <span class="keyword">if</span> (to.name === <span class="string">'topic'</span> &amp;&amp; to.params.id !== <span class="keyword">this</span>.topicId) &#123;</div><div class="line">      <span class="keyword">this</span>.topic = &#123;&#125;</div><div class="line">      <span class="keyword">this</span>.getDetail(<span class="keyword">this</span>.$route.params.id)</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">from</span>.name === <span class="string">'topic'</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.setTopicId(<span class="keyword">from</span>.params.id)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="页面的滚动状态保持"><a href="#页面的滚动状态保持" class="headerlink" title="页面的滚动状态保持"></a>页面的滚动状态保持</h3><p>当我们，在主题列表滚动了一段距离之后，我们点击了一个主题，然后我们再次返回的时候，主题列表需要保持原来的滚动状态。</p><p>本来我的主题列表想要添加<a href="https://ustbhuangyi.github.io/better-scroll/#/" target="_blank" rel="noopener">better-scroll</a>的。但是每次页面滚动之后，点击新主题，再返回的时候，页面总会跳转到顶端，这样的话，浏览体验就非常不好。然后我了解了一下 better-scroll 的滚动原理：<br><img src="http://static.galileo.xiaojukeji.com/static/tms/shield/scroll-4.png" alt=""><br>绿色部分为 wrapper，也就是父容器，它会有固定的高度。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。</p><p>这里，我们了解到了，better-scroll 的滚动原理中，我们需要一个固定的wrapper，这样的话，我们的内容在我们的页面中的话，就是在一个固定的窗口下。</p><p>vue-router 中有一个scrollBehavior ，<a href="https://router.vuejs.org/zh-cn/advanced/scroll-behavior.html" target="_blank" rel="noopener">滚动行为</a>，使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p><p>我们需要记录scrollTop属性，上面采用 better-scroll 的话，我们的窗口是固定的，也就是，这里的scrollTop是相对于我们wrapper，而wrapper在页面中的位置是固定的就是没有scrollTop，这样的话，我们记录的scrollTop没有用。</p><p>如果用 better-scroll ，我们就需要页面跳转的话每次将scrollTop的值手动传给组件，十分麻烦，最后我放弃了并采用了原生的scroll。</p><h3 id="vue-router懒加载"><a href="#vue-router懒加载" class="headerlink" title="vue-router懒加载"></a>vue-router懒加载</h3><p>没什么好说的，为了加载高效肯定要用的。</p><h2 id="其他一些"><a href="#其他一些" class="headerlink" title="其他一些"></a>其他一些</h2><h3 id="mavonEditor"><a href="#mavonEditor" class="headerlink" title="mavonEditor"></a>mavonEditor</h3><p>论坛的文章编辑，现在大部分写文章的都是md了，所以我找了找，最好的还是这个，安装好npm包，加一个标签再加上一点配置接好了。地址：<a href="https://github.com/hinesboy/mavonEditor" target="_blank" rel="noopener">mavonEditor</a></p><h3 id="多处用的登录验证"><a href="#多处用的登录验证" class="headerlink" title="多处用的登录验证"></a>多处用的登录验证</h3><p>没有登录的时候，很多地方都需要登录验证。因为有路由跳转逻辑，需要 js ，有了 mixin 就很好了。我们写好了 mixin 后，在我们需要添加登录页面的地方添加 mixin 和添加登录页面的组件。</p><p>最后，还想到什么有需要总结的还是会更新文章的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下开发过程中的一些小坑。&lt;br&gt;
    
    </summary>
    
      <category term="vue-items" scheme="https://hddhyq.github.io/categories/vue-items/"/>
    
    
      <category term="vue-cnode" scheme="https://hddhyq.github.io/tags/vue-cnode/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JS总结-作用域和闭包(二)</title>
    <link href="https://hddhyq.github.io/2018/02/05/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E6%80%BB%E7%BB%93-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85-%E4%BA%8C/"/>
    <id>https://hddhyq.github.io/2018/02/05/你不知道的JS总结-作用域和闭包-二/</id>
    <published>2018-02-05T15:10:19.000Z</published>
    <updated>2018-07-08T04:25:55.520Z</updated>
    
    <content type="html"><![CDATA[<p>关于你不知道的JS总结-作用域和闭包的第二部分。<br><a id="more"></a></p><h1 id="第-4-章-提升"><a href="#第-4-章-提升" class="headerlink" title="第 4 章 提升"></a>第 4 章 提升</h1><h2 id="先有鸡还是先有蛋"><a href="#先有鸡还是先有蛋" class="headerlink" title="先有鸡还是先有蛋"></a>先有鸡还是先有蛋</h2><p>关于JS的代码执行顺序，直觉上是由上到下一行一行执行的。实际上并不完全正确，考虑下下面的代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log( a );</div></pre></td></tr></table></figure></p><p>你认为<code>console.log( a );</code>声明会输出什么呢？很多人会认为是<code>undefined</code>，其实真实的输出结果是2。而<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( a );</div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div></pre></td></tr></table></figure></p><p>这段代码输出结果又是<code>ReferenceError</code>异常。</p><p>按照第一章的编译器顺序，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。</p><p>所以看到的<code>var a = 2;</code>其实是<code>var a;</code> 和 <code>a = 2;</code>两个声明。代码的编译过程是如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"></div><div class="line"><span class="comment">// 加上顺序，流程如下：</span></div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a = <span class="number">2</span>;</div></pre></td></tr></table></figure></p><p>从上面的例子可以看出，是现有声明，再有赋值。这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。</p><blockquote><p>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。</p></blockquote><h3 id="关于函数的声明"><a href="#关于函数的声明" class="headerlink" title="关于函数的声明"></a>关于函数的声明</h3><p>首先看一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>foo 函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可以正常执行。</p><p>正确的执行顺序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></div><div class="line">  a = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p><p><strong>函数声明会被提升，但是函数表达式却不会被提升。</strong></p><p>下面看一段函数表达式的代码片段：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// TypeError</span></div><div class="line">bar(); <span class="comment">// ReferenceError</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 经过提升</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line">foo(); <span class="comment">// TypeError</span></div><div class="line">bar(); <span class="comment">// ReferenceError</span></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> bar = ...self...</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h2><p>函数声明和变量声明都会被提升，那么哪一个的优先权大呢？答案就在标题。<br>看这一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// 1</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</div><div class="line">&#125;</div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这个代码片段会被引擎理解为如下形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</div><div class="line">&#125;</div><div class="line">foo(); <span class="comment">// 1</span></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>尽管　<code>var foo</code> 出现在<code>function foo()...</code>，但它是一个重复的声明，会被忽略掉。因为函数声明会被提升到普通变量之前。</p><p>而且，后面的函数声明会覆盖前面的声明。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// 3</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">3</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程 <strong>不会像下面的代码暗示的那样可以被条件判断所控制：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// "b"</span></div><div class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span> (a) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"a"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"b"</span>); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们习惯将 <code>var a = 2</code>; 看作一个声明，而实际上 <strong>JavaScript</strong> 引擎并不这么认为。它将 <code>var a</code>和 <code>a = 2</code> 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。</p><p>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为<strong>提升</strong>。</p><p>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</p><p>要注意避免重复声明，特别是当普通的 <code>var</code> 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！</p><h1 id="第-5-章-作用域闭包"><a href="#第-5-章-作用域闭包" class="headerlink" title="第 5 章 作用域闭包"></a>第 5 章 作用域闭包</h1><h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>闭包无处不在，你所需要的只是理解它</p><h2 id="实质问题"><a href="#实质问题" class="headerlink" title="实质问题"></a>实质问题</h2><p>闭包的定义：</p><blockquote><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p></blockquote><p>下面这段代码的定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">  &#125;</div><div class="line">  bar();</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p><p>上面的代码中，基于词法作用域，函数<code>bar()</code>可以访问外部作用域中的变量a（利用RHS引用调用）。这里的词法作用域的利用，是闭包的一部分，也是最重要的一部分。</p><p>从纯学术的角度说，函数 <code>bar()</code> 具有一个涵盖 <code>foo()</code> 作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域））。也可以认为 bar() 被封闭在了 foo() 的作用域中。为什么呢？原因简单明了，因为 bar() 嵌套在 foo() 内部。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( a );</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> baz = foo();</div><div class="line">baz(); <span class="comment">// 2 —— 朋友，这就是闭包的效果。</span></div></pre></td></tr></table></figure></p><p>函数<code>bar()</code>的词法作用域能够访问<code>foo()</code>的内部作用域。然后我们将<code>bar()</code>函数本身当做一个值类型进行传递。上面这个例子中，我们就是将bar所应用的函数对象本身当做返回值。</p><p>在<code>foo()</code>执行后，其返回值（也就是内部的 <code>bar()</code> 函数）赋值给变量 <code>baz</code> 并调用 <code>baz()</code>，实际上只是通过不同的标识符引用调用了内部的函数<code>bar()</code>。</p><p><code>bar()</code>显然可以被正常执行，但是在这个例子中，它在自己定义的词法作用域以外的地方执行。</p><p><code>foo()</code> 执行后，通常会期待 <code>foo()</code> 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 <code>foo()</code> 的内容不会再被使用，所以很自然地会考虑对其进行回收。</p><p>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 <code>bar()</code> 本身在使用。</p><p>拜 <code>bar()</code> 所声明的位置所赐，它拥有涵盖 <code>foo()</code> 内部作用域的闭包，使得该作用域能够一直存活，以供 <code>bar()</code> 在之后任何时间进行引用。</p><p><code>bar()</code> 依然持有对该作用域的引用，而这个引用就叫作闭包。</p><p>因此，在<strong>几微秒</strong>之后变量 baz 被实际调用（调用内部函数 <code>bar</code>），不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。</p><p>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。</p><p>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">  &#125;</div><div class="line">  bar( baz );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  fn(); <span class="comment">// 妈妈快看呀，这就是闭包！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</p></blockquote><h2 id="现在我懂了"><a href="#现在我懂了" class="headerlink" title="现在我懂了"></a>现在我懂了</h2><p>来看这段代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( message );</div><div class="line">  &#125;, <span class="number">1000</span> );</div><div class="line">&#125;</div><div class="line">wait( <span class="string">"Hello, closure!"</span> );</div></pre></td></tr></table></figure></p><p>将一个内部函数（名为 <code>timer</code>）传递给 <code>setTimeout(..)</code>。<code>timer</code> 具有涵盖 <code>wait(..)</code> 作用域的闭包，因此还保有对变量 <code>message</code> 的引用。</p><p><code>wait(..)</code> 执行 1000 毫秒后，它的内部作用域并不会消失，<code>timer</code> 函数依然保有 <code>wait(..)</code>作用域的闭包。</p><p>深入到引擎的内部原理中，内置的工具函数 <code>setTimeout(..)</code> 持有对一个参数的引用，这个参数也许叫作 <code>fn</code> 或者 <code>func</code>，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 <code>timer</code> 函数，而词法作用域在这个过程中保持完整。</p><p><strong>这就是闭包。</strong></p><p>本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！</p><p>IIFE模式，因为函数（示例代码中的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行。这是是创建了一个闭包但是并不能调用。</p><h2 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h2><p>要说明闭包，for循环是最常见的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( i );</div><div class="line">  &#125;, i*<span class="number">1000</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们预期的效果是:分别输出数字 1~5，每秒一次，每次一个。</p><p>得到的结果是，每秒一次的频率输出五次 6。</p><p>首先我们看一下6是怎么来的。这个例子中的终止条件是<code>i&lt;=5</code>。所以首次成立时的i的值是6，因此，输出显示的是循环结束时 i 的最终值。</p><p>仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 <code>setTimeout(.., 0)</code>，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。</p><p>缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的<strong>副本</strong>。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个<strong>共享的全局作用域中</strong>，因此实际上只有一个 i。</p><p>我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。</p><p>首先试下IIFE<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log( i );</div><div class="line">    &#125;, i*<span class="number">1000</span> );</div><div class="line">  &#125;)();</div><div class="line">&#125; <span class="comment">// 这样的写法不行，为什么呢？因为每个IIFE中i的值并没有定义，也就是说这个作用于是空的</span></div><div class="line"></div><div class="line"><span class="comment">//　改进</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log( j );</div><div class="line">    &#125;, j*<span class="number">1000</span> );</div><div class="line">  &#125;)( i );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>重返块作用域</strong></p><p>我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。第 3 章介绍了 let 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。</p><p>本质上这是将一个块转换成一个可以被关闭的作用域。因此，下面这些看起来很酷的代码就可以正常运行了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="keyword">let</span> j = i; <span class="comment">// 是的，闭包的块作用域！</span></div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( j );</div><div class="line">  &#125;, j*<span class="number">1000</span> );</div><div class="line">&#125;</div><div class="line"><span class="comment">// for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( i );</div><div class="line">  &#125;, i*<span class="number">1000</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>还有其他的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一起来研究其中最强大的一个：<strong>模块</strong>。</p><p>模块模式需要具备两个必要条件。</p><ol><li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够到达那里。但实际上它只是一个标准，显然就是关于如何在函数作为值按需传递的词法环境中书写代码的。</p><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</p><p>如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。</p><p>模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</p><p>现在我们会发现代码中到处都有闭包存在，并且我们能够识别闭包然后用它来做一些有用的事！</p><h1 id="附录-A-动态作用域"><a href="#附录-A-动态作用域" class="headerlink" title="附录 A 动态作用域"></a>附录 A 动态作用域</h1><p>JS中作用域就是词法作用域，（事实上大部分语言都是基于词法作用域的）。</p><p>而JS中，this的机制，类似于动态作用域。</p><p>词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的<strong>书写阶段</strong>（假设你没有使用eval() 或 with）。而动态作用域，是一个运行时被被动确定状态的形式。</p><p>例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">bar();</div></pre></td></tr></table></figure></p><p>词法作用域让 <code>foo()</code> 中的 <code>a</code> 通过 <strong>RHS</strong> 引用到了全局作用域中的 <code>a</code>，因此会输出 2。</p><p>而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。</p><p>因此，如果 JavaScript 具有动态作用域，理论上，上面代码中的 <code>foo()</code> 在执行时将会输出 3。</p><p>为什么会这样？因为当 <code>foo()</code> 无法找到 <code>a</code> 的变量引用时，会顺着调用栈在调用 <code>foo()</code> 的地方查找 <code>a</code>，而不是在嵌套的词法作用域链中向上查找。由于 <code>foo()</code> 是在 <code>bar()</code> 中调用的，引擎会检查 <code>bar()</code> 的作用域，并在其中找到值为 3 的变量 <code>a</code>。</p><h1 id="附录-B-块作用域的替代方案"><a href="#附录-B-块作用域的替代方案" class="headerlink" title="附录 B 块作用域的替代方案"></a>附录 B 块作用域的替代方案</h1><p>第 3 章深入研究了块作用域。至少从 ES3 发布以来，JavaScript 中就有了块作用域，而with 和 catch 分句就是块作用域的两个小例子。</p><p>但随着 ES6 中引入了 let，我们的代码终于有了创建完整、不受约束的块作用域的能力。块作用域在功能上和代码风格上都拥有很多激动人心的新特性。</p><p>但如果我们想在 ES6 之前的环境中使用块作用域呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure><p>这段代码在 ES6 环境中可以正常工作。但是在 ES6 之前的环境中如何才能实现这个效果？答案是使用 catch。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;<span class="keyword">throw</span> <span class="number">2</span>;&#125;<span class="keyword">catch</span>(a)&#123;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p><p>了解原理剩下就交给ES6转换器吧。</p><h1 id="附录-C-this-词法"><a href="#附录-C-this-词法" class="headerlink" title="附录 C this 词法"></a>附录 C this 词法</h1><p>ES6 中有一个主题用非常重要的方式将 this同词法作用域联系起来了，我们会简单地讨论一下。</p><p>ES6 添加了一个特殊的语法形式用于函数声明，叫作箭头函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">a</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log( a );</div><div class="line">&#125;;</div><div class="line">foo( <span class="number">2</span> ); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><p>这里称作“胖箭头”的写法通常被当作单调乏味且冗长（挖苦）的 function 关键字的简写。</p><p>看这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  id: <span class="string">"awesome"</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.id );</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> id = <span class="string">"not awesome"</span></div><div class="line">obj.cool(); <span class="comment">// 酷</span></div><div class="line">setTimeout( obj.cool, <span class="number">100</span> ); <span class="comment">// 不酷</span></div></pre></td></tr></table></figure></p><p>问题在于 cool() 函数丢失了同 this 之间的绑定。解决这个问题有好几种办法，但最长用的就是 var self = this;。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  count: <span class="number">0</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (self.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        self.count++;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"awesome?"</span> );</div><div class="line">      &#125;, <span class="number">100</span> );</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.cool(); <span class="comment">// 酷吧？</span></div></pre></td></tr></table></figure><p><code>var self = this</code> 这种解决方案圆满解决了理解和正确使用 <code>this</code> 绑定的问题，并且没有把问题过于复杂化，它使用的是我们非常熟悉的工具：词法作用域。</p><p>ES6 中的箭头函数引入了一个叫作 this 词法的行为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  count: <span class="number">0</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 箭头函数是什么鬼东西？</span></div><div class="line">        <span class="keyword">this</span>.count++;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"awesome?"</span> );</div><div class="line">      &#125;, <span class="number">100</span> );</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.cool(); <span class="comment">// 很酷吧 ?</span></div></pre></td></tr></table></figure></p><p>简单来说，箭头函数在涉及 <code>this</code> 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 <code>this</code> 绑定的规则，取而代之的是用当前的词法作用域覆盖了 <code>this</code> 本来的值。</p><p>因此，这个代码片段中的箭头函数并非是以某种不可预测的方式同所属的 <code>this</code> 进行了解绑定，而只是“继承”了 <code>cool()</code> 函数的 <code>this</code> 绑定（因此调用它并不会出错）。</p><p>箭头函数将程序员们经常犯的一个错误给标准化了，也就是混淆了 <code>this</code> 绑定规则和词法作用域规则。</p><p>换句话说：为什么要自找麻烦使用 <code>this</code> 风格的代码模式呢？把它和词法作用域结合在一起非常让人头疼。在代码中使用两种风格其中的一种是非常自然的事情，但是不要将两种风格混在一起使用。</p><blockquote><p>另一个导致箭头函数不够理想的原因是它们是匿名而非具名的。具名函数比<br>匿名函数更可取的原因参见第 3 章。</p></blockquote><p>在我看来，解决这个“问题”的另一个更合适的办法是正确使用和包含 this 机制。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  count: <span class="number">0</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.count++; <span class="comment">// this 是安全的</span></div><div class="line">        <span class="comment">// 因为 bind(..)</span></div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"more awesome"</span> );</div><div class="line">      &#125;.bind( <span class="keyword">this</span> ), <span class="number">100</span> ); <span class="comment">// look, bind()!</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.cool(); <span class="comment">// 更酷了。</span></div></pre></td></tr></table></figure></p><p>无论你是喜欢箭头函数中 this 词法的新行为模式，还是喜欢更靠得住的 bind()，都需要注意箭头函数不仅仅意味着可以少写代码。</p><p>它们之间有意为之的不同行为需要我们理解和掌握，才能正确地使用它们。</p><p>现在我们已经完全理解了词法作用域（还有闭包），理解 this 词法是小菜一碟！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于你不知道的JS总结-作用域和闭包的第二部分。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="你不知道的JS" scheme="https://hddhyq.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JS总结-作用域和闭包(一)</title>
    <link href="https://hddhyq.github.io/2018/02/05/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E6%80%BB%E7%BB%93-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85(%E4%B8%80)/"/>
    <id>https://hddhyq.github.io/2018/02/05/你不知道的JS总结-作用域和闭包(一)/</id>
    <published>2018-02-05T08:37:10.000Z</published>
    <updated>2018-07-08T04:25:55.519Z</updated>
    
    <content type="html"><![CDATA[<p>这几天读了下《你不知道的JavaScript（上卷）》,对于书中<strong>作用域和闭包</strong>的知识点做一下总结<br><a id="more"></a></p><h1 id="第-1-章-作用域是什么"><a href="#第-1-章-作用域是什么" class="headerlink" title="第 1 章 作用域是什么"></a>第 1 章 作用域是什么</h1><p>要了解作用域的规则，首先需要了解简单的编译原理。</p><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。</p><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p><ul><li><p>分词/词法分析（Tokenizing/Lexing）</p><p>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。<br>如：var a = 2;  =&gt;  var、a、=、2 、;</p></li><li><p>解析/语法分析（Parsing）</p><p>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。</p></li><li><p>代码生成</p><p>将 AST 转换为可执行代码的过程称被称为代码生成。</p></li></ul><h2 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h2><p>  需要理解三个处理过程中的参与者：</p><ul><li><p>引擎</p><p>从头到尾负责整个 JavaScript 程序的编译及执行过程。</p></li><li><p>编译器</p><p>引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。</p></li><li><p>作用域</p><p>引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p></li></ul><p>例子: <code>var a = 2;</code></p><p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p><p>在赋值中，对于引擎来讲，引擎会为变量 a 进行 <strong>LHS</strong> 查询。另外一个查找的类型叫作 <strong>RHS</strong>。</p><p><strong>RHS</strong> 查询与简单地查找某个变量的值别无二致，而 <strong>LHS</strong> 查询则是试图找到变量的容器本身，从而可以对其赋值。<strong>RHS</strong> 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。</p><p>你可以将 <strong>RHS</strong> 理解成 retrieve his source value（取到它的源值）。</p><h2 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h2><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//UDntKnowJS/作用域.png" alt=""></p><p>不管是<strong>LHS</strong> 和 <strong>RHS</strong>都需要对作用域按照上图进行查找。一旦抵达全局作用域，无论你有没有找到所需变量，查找过程都会终止。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>LHS</strong>和<strong>RHS</strong>,在最终没有找到变量的时候处理方式会有差异:</p><ul><li><strong>RHS</strong> 抛出异常<code>ReferenceError</code></li><li><strong>LHS</strong> 在严格模式，抛出异常<code>ReferenceError</code>,正常模式，会创建一个具有该名称的变量，并将其返还给引擎。</li></ul><p><strong>RHS</strong>　中，如果找到一个变量对这个变量进行不合理的操作。会抛出<code>TypeError</code></p><p><code>ReferenceError</code> 同作用域判别失败相关，而 <code>TypeError</code> 则代表作用域判别成功了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 <strong>LHS</strong> 查询；如果目的是获取变量的值，就会使用 <strong>RHS</strong> 查询。赋值操作符会导致 <strong>LHS</strong> 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p><p>JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 <code>var a = 2</code> 这样的声明会被分解成两个独立的步骤：</p><ol><li>首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li><li>接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。</li></ol><p><strong>LHS</strong> 和 <strong>RHS</strong> 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。不成功的 <strong>RHS</strong> 引用会导致抛出 <code>ReferenceError</code> 异常。不成功的 <strong>LHS</strong> 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 <code>ReferenceError</code> 异常（严格模式下）。</p><h1 id="第-2-章-词法作用域"><a href="#第-2-章-词法作用域" class="headerlink" title="第 2 章 词法作用域"></a>第 2 章 词法作用域</h1><p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的 <strong>词法作用域</strong> ，我们会对这种作用域进行深入讨论。另外一种叫作 <strong>动态作用域</strong>，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。</p><h2 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h2><p>第 1 章介绍过，大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。回忆一下，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。</p><p>简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( a, b, c );</div><div class="line">  &#125;</div><div class="line">  bar( b * <span class="number">3</span> );</div><div class="line">&#125;</div><div class="line">foo( <span class="number">2</span> ); <span class="comment">// 2, 4, 12</span></div></pre></td></tr></table></figure><p>这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们想象成几个逐级包含<br>的气泡。<br><img src="http://p1aqu3lsq.bkt.clouddn.com//UDntKnowJS/wordScope.png" alt=""></p><ol><li>包含着整个全局作用域，其中只有一个标识符：foo。</li><li>包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。</li><li>包含着 bar 所创建的作用域，其中只有一个标识符：c</li></ol><p>没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。</p><p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“ <strong>遮蔽效应</strong> ”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。</p><p>无论函数在<em>哪里</em>被调用，也无论它<em>如何</em>被调用，它的词法作用域都<em>只由</em>函数被声明时所处的位置决定。</p><h2 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h2><p>如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？</p><p>JavaScript 中有两种机制来实现这个目的</p><ol><li><p>eval </p><p>JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。</p></li><li>with<br>JavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是with 关键字。</li></ol><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>这是我们抛弃上述两个方法的主要原因，</p><p>JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。</p><p>但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。</p><p>如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</p><p>JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。</p><p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。</p><h1 id="第-3-章-函数作用域和块作用域"><a href="#第-3-章-函数作用域和块作用域" class="headerlink" title="第 3 章 函数作用域和块作用域"></a>第 3 章 函数作用域和块作用域</h1><h2 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">  <span class="comment">// 一些代码</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 更多的代码</span></div><div class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡。 在下一章<strong>提升</strong>中会着重介绍。</p><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript 变量可以根据需要改变值类型的“动态”特性。</p><h2 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h2><p>对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。</p><p>有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  b = a + doSomethingElse( a * <span class="number">2</span> );</div><div class="line">  <span class="built_in">console</span>.log( b * <span class="number">3</span> );</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a - <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b;</div><div class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></div></pre></td></tr></table></figure><p>上述的例子中，就是一个反例，将应该私有的变量b和函数doSomethingElse(..)暴露给了外部作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a - <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> b;</div><div class="line">  b = a + doSomethingElse( a * <span class="number">2</span> );</div><div class="line">  <span class="built_in">console</span>.log( b * <span class="number">3</span> );</div><div class="line">&#125;</div><div class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></div></pre></td></tr></table></figure><p>修改后的代码，b和 <code>doSomethingElse(..)</code>都无法从外部被访问。</p><p><strong>规避冲突</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    i = <span class="number">3</span>; <span class="comment">// 修改 for 循环所属作用域中的 i</span></div><div class="line">    <span class="built_in">console</span>.log( a + i );</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">    bar( i * <span class="number">2</span> ); <span class="comment">// 糟糕，无限循环了！</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p><p>bar(..) 内部的赋值表达式 i = 3 意外地覆盖了声明在 foo(..) 内部 for 循环中的 i。在这个例子中将会导致无限循环，因为 i 被固定设置为 3，永远满足小于 10 这个条件。</p><p>这里我们能选用两种方法，一种新声明一个本地变量，<code>var i = 3;</code>。另一种，新添加一个标识符名称，比如 <code>var j = 3</code>。</p><p>软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，所以通过作用域来“隐藏”内部声明是唯一的最佳选择。</p><ol><li>全局命名空间<br>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。</li></ol><p>这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyReallyCoolLibrary = &#123;</div><div class="line">  awesome: <span class="string">"stuff"</span>,</div><div class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  doAnotherThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><ol start="2"><li>模块管理<br>这种避免冲突的方法和现代的木块机制很接近，从众多的模块管理器挑选一个使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。</li></ol><p>显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>在前面我们知道了，在任意代码片段外部添加包装函数，可以讲变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。</p><p>这个方法也有不理想之处。我们必须声明一个具名函数，这也就意味着，这个具名函数的名称已经“污染”了所在作用域。其次，必须显示的调用这个具名函数，才能运行其中的代码。</p><p>如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。</p><p>JS中的同时解决两种问题的方案：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">// &lt;-- 添加这一行</span></div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></div><div class="line">&#125;)(); <span class="comment">// &lt;-- 以及这一行</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><p>包装函数的声明以 (function… 而不仅是以 function… 开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理。其实就是立即执行了。</p><blockquote><p>区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位<br>置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中<br>的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p></blockquote><p><strong>函数声明</strong> 和 <strong>函数表达式</strong> 之间最重要的区别是它们的名称标识符将会绑定在何处。</p><p>(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。</p><h3 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>);</div><div class="line">&#125;, <span class="number">1000</span> );</div></pre></td></tr></table></figure><p>上述的定时的代码片段，我们很熟悉，这就是 <strong>匿名函数表达式</strong> , 因为<code>function()</code>.. 没有名称标识符。</p><p>匿名函数书写起来简单便捷，不过有几个缺点需要考虑。</p><ol><li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</li><li>如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li><li>匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</li></ol><h3 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h3><p><strong>IIFE</strong>, 代表立即执行函数表达式（Immediately Invoked Function Expression）；</p><p>函数名对于<strong>IIFE</strong>不是必需的，IIFE 最常见的用法是使用一个匿名函数表达式。</p><ul><li><strong>IIFE</strong> 的一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。</li><li><strong>IIFE</strong> 另一个场景，解决undefined 标识符的默认值被错误覆盖导致的异常（虽然不常见）。</li><li><strong>IIFE</strong> 是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。</li></ul><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log( i );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 i 会被绑定在外部作用域（函数或全局）中的事实。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  <span class="keyword">var</span> bar = foo * <span class="number">2</span>;</div><div class="line">  bar = something( bar );</div><div class="line">  <span class="built_in">console</span>.log( bar );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用 var 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。这段代码是为了风格更易读而伪装出的形式上的块作用域，如果使用这种形式，要确保没在作用域其他地方意外地使用 bar 只能依靠自觉性。</p><p>块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。实现方法：</p><ol><li>with</li><li>try/catch catch分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。</li><li>let</li></ol><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>这里我们着重介绍下，let的实现原理。</p><p>let关键字可以将变量绑定到所在的任意作用域中，通常是{ .. } 内部.换句话说，let为其声明的变量隐式地了所在的块作用域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  <span class="keyword">let</span> bar = foo * <span class="number">2</span>;</div><div class="line">  bar = something( bar );</div><div class="line">  <span class="built_in">console</span>.log( bar );</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p><p>用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。</p><p>在开发和修改代码的过程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将其包含在其他的块中，就会导致代码变得混乱。</p><p>显示的块作用域，可以解决上述问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  &#123; <span class="comment">// &lt;-- 显式的快</span></div><div class="line">    <span class="keyword">let</span> bar = foo * <span class="number">2</span>;</div><div class="line">    bar = something( bar );</div><div class="line">    <span class="built_in">console</span>.log( bar );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p><p>例子中，我们在 if 声明内部显式地创建了一个块，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响</p><ol><li>垃圾收集</li></ol><p>另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。通过块作用域，能够让引擎知道我们执行后的代码片段不需要继续保存。</p><ol start="2"><li>let循环</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log( i );</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( i ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure><p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</p><p>下面通过另一种方式来说明每次迭代时进行重新绑定的行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> j;</div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</div><div class="line">    <span class="keyword">let</span> i = j; <span class="comment">// 每个迭代重新绑定！</span></div><div class="line">    <span class="built_in">console</span>.log( i );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>const</strong></p><p>同样可以用来创建块作用域变量，但其值是固定的（常量）。</p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</p><p>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。</p><p>从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。</p><p>在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。</p><p>有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天读了下《你不知道的JavaScript（上卷）》,对于书中&lt;strong&gt;作用域和闭包&lt;/strong&gt;的知识点做一下总结&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="你不知道的JS" scheme="https://hddhyq.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"/>
    
  </entry>
  
  <entry>
    <title>《Web性能权威指南》读书总结</title>
    <link href="https://hddhyq.github.io/2018/01/08/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://hddhyq.github.io/2018/01/08/《Web性能权威指南》读书总结/</id>
    <published>2018-01-08T08:13:58.000Z</published>
    <updated>2018-07-08T04:25:55.518Z</updated>
    
    <content type="html"><![CDATA[<p>总结了针对 <strong>HTTP 1.x</strong> 和 <strong>HTTP 2.0</strong> 的优化，以及 <strong>HTTP 2.0</strong> 的一些历史。<br><a id="more"></a></p><h1 id="Web性能优化要点"><a href="#Web性能优化要点" class="headerlink" title="Web性能优化要点"></a>Web性能优化要点</h1><h2 id="宏观的-Web-性能优化"><a href="#宏观的-Web-性能优化" class="headerlink" title="宏观的 Web 性能优化"></a>宏观的 Web 性能优化</h2><ul><li>延迟和带宽对 Web 性能的影响；</li><li>传输协议（TCP）对 HTTP 的限制；</li><li>HTTP 协议自身的功能和缺陷；</li><li>Web 应用的发展趋势及性能需求；</li><li>浏览器局限性和优化思路。</li></ul><p>页面加载时间，是来衡量 Web 性能的事实标准。页面加载时间常简写为PLT（Page Load Time）。</p><p>PLT 的简单定义就是：“浏览器中的加载旋转图标停止旋转的时间。”更技术的定义则是浏览器中的 onload 事件，这个事件由浏览器在文档及其所有依赖资源（JavaScript、图片，等等）下载完毕时触发。</p><p>除了测量每个资源及整个页面的加载时间（PLT），还要关注有关应用的如下几<br>个问题：</p><ul><li>应用加载过程中的里程碑是什么？</li><li>用户第一次交互的时机何在？</li><li>什么交互应该吸引用户参与？</li><li>每个用户的参与及转化率如何？</li></ul><p>接下来我们了解一下 <strong>脚本、样式表和标记文档之间复杂依赖</strong> :<br><img src="http://p1aqu3lsq.bkt.clouddn.com//WebPerformance/broswer.png" alt=""></p><p>浏览器在解析 HTML 文档的基础上构建  <strong>DOM（Document Object Model，文档对象模型）</strong> 。与此同时，还有一个常常被忽略的模型—— <strong>CSSOM（CSS ObjectModel，CSS 对象模型）</strong> ，也会基于特定的样式表规则和资源构建而成。这两个模型共同创建“渲染树”，之后浏览器就有了足够的信息去进行布局，并在屏幕上绘制图形。到目前为止，一切都很好理解。</p><p>然而，此时不得不提到我们最大的朋友和祸害： <strong>JavaScript</strong> 。脚本执行过程中可能遇到一个同步 <strong>document.write</strong> ，从而阻塞 DOM 的解析和构建。类似地，脚本也可能查询任何对象的计算样式，从而阻塞 CSS 处理。结果，DOM 及 CSSOM的构建频繁地交织在一起：DOM 构建在 JavaScript 执行完毕前无法进行，而 <strong>JavaScript 在 CSSOM 构建完成前也无法进行</strong> 。</p><p>应用的性能，特别是首次加载时的 <strong>“渲染前时间”</strong> ，直接取决于标记、样式表和JavaScript 这三者之间的依赖关系。顺便说一句，还记得流行的“样式在上，脚本在下”的最佳实践吗？现在你该知道为什么了。渲染和脚本执行都会受样式表的阻塞，因此必须让 <strong>CSS</strong> 以最快的速度下载完。</p><p>剩下就是要知道，<strong>延迟是性能瓶颈</strong> 。减少延迟是Web性能优化的关键。分析资源瀑布图，对资源进行合理的分配。</p><h1 id="HTTP-1-x"><a href="#HTTP-1-x" class="headerlink" title="HTTP 1.x"></a>HTTP 1.x</h1><p>放在前面的Steve Souder 的《高性能网站建设指南》中概括了 14 条规则，有一半针对网络优化：</p><ul><li><p>减少DNS查询</p><p>每次域名解析都需要一次网络往返，增加请求的延迟，在查询期间会阻塞请求。</p></li><li><p>减少HTTP请求</p><p><strong>任何请求都不如没有请求更快</strong>，因此要去掉页面上没有必要的资源。</p></li><li><p>使用CDN</p><p>从地理上把数据放到接近客户端的地方，可以显著减少每次 TCP 连接的网络延迟，增加吞吐量。</p></li><li><p>添加Expires首部并配置ETag标签</p><p>相关资源应该缓存，以避免重复请求每个页面中相同的资源。Expires 首部可用于指定缓存时间，在这个时间内可以直接从缓存取得资源，完全避免 HTTP 请求。ETag 及 Last-Modified 首部提供了一个与缓存相关的机制，相当于最后一次更新的指纹或时间戳。</p></li><li><p>Gzip资源</p><p>所有文本资源都应该使用 Gzip 压缩，然后再在客户端与服务器间传输。一般来说，Gzip 可以减少 60%~80% 的文件大小，也是一个相对简单（只要在服务器上配置一个选项），但优化效果较好的举措。</p></li><li><p>避免HTTP重定向</p><p>HTTP 重定向极其耗时，特别是把客户端定向到一个完全不同的域名的情况下，还会导致额外的 DNS 查询、TCP 连接延迟，等等。</p></li></ul><p>现实当中，我们应该对这些技术有正确的认识：它们都是些针对当前HTTP 1.1 协议的局限性而采用的权宜之计。我们本来不应该操心去连接文件、拼合图标、分割域名或嵌入资源。但遗憾的是，“不应该”并不是务实的态度：这些优化手段之所以存在，都是有原因的，在背后的问题被 HTTP 的下一个版本解决之前，必须得依靠它们。</p><h2 id="持久连接的优点"><a href="#持久连接的优点" class="headerlink" title="持久连接的优点"></a>持久连接的优点</h2><p>每个 TCP 连接开始都有三次握手，要经历一次客户端与服务器间完整的往返。此后，会因为 HTTP 请求和响应的两次通信而至少引发另一次往返。最后，还要加上服务器处理时间，才能得到每次请求的总时间。HTTP 持久连接，可以避免再次请求的延迟。</p><p>HTTP 1.1，  默认启用持久连接。用 HTTP 1.0，则可以明确使用 Connection: Keep-Alive 首部声明使用持久连接。</p><h2 id="HTTP管道"><a href="#HTTP管道" class="headerlink" title="HTTP管道"></a>HTTP管道</h2><p>服务器处理完第一次请求后，会发生了一次完整的往返：先是响应回传，接着是第二次请求。在此期间服务器空闲。如果服务器能在处理完第一次请求后，立即开始处理第二次请求呢？</p><p>这就是HTTP管道的作用，通过尽早分派请求，不被每次响应阻塞，可以再次消除额外的网络往返。这样，就从非持久连接状态下的每个请求两次往返，变成了整个请求队列只需要两次网络往返！</p><p>HTTP 1.1 管道的好处，主要就是消除了发送请求和响应的等待时间。这种并行处理请求的能力对提升应用性能的帮助非常之大。</p><p>讨论下HTTP 1.x 协议的一些局限性对，HTTP管道优化的不支持。HTTP 1.x 只能严格串行地返回响应。特别是，HTTP  1.x 不允许一个连接上的多个响应数据交错到达（多路复用），因而一个响应必须完全返回后，下一个响应才会开始传输。</p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//WebPerformance/HttpPipe.png" alt=""></p><p>演示了如下几个方面：</p><ul><li>HTML 和 CSS 请求同时到达，但先处理的是 HTML 请求</li><li>服务器并行处理两个请求，其中处理 HTML 用时 40 ms，处理 CSS 用时 20 ms；</li><li>CSS 请求先处理完成，但被缓冲起来以等候发送 HTML 响应；</li><li>发送完 HTML 响应后，再发送服务器缓冲中的 CSS 响应。</li></ul><p>实际中，由于不可能实现多路复用，HTTP 管道会导致 HTTP 服务器、代理和客户端出现很多微妙的，不见文档记载的问题：</p><ul><li>一个慢响应就会阻塞所有后续请求；</li><li>并行处理请求时，服务器必须缓冲管道中的响应，从而占用服务器资源，如果有个响应非常大，则很容易形成服务器的受攻击面；</li><li>响应失败可能终止 TCP 连接，从页强迫客户端重新发送对所有后续资源的请求，导致重复处理；</li><li>由于可能存在中间代理，因此检测管道兼容性，确保可靠性很重要；</li><li>如果中间代理不支持管道，那它可能会中断连接，也可能会把所有请求串联起来。</li></ul><p>HTTP 管道技术的应用非常有限，虽然其优点毋庸置疑。今天，一些支持管道的浏览器，通常都将其作为一个高级配置选项，但大多数浏览器都会禁用它。</p><p>实践中部署 HTTP 管道的最佳途径，就是在客户端和服务器间使用安全通道（HTTPS）。这样，就能可靠地避免那些不理解或不支持管道的中间代理的干扰。</p><h2 id="使用多个TCP连接"><a href="#使用多个TCP连接" class="headerlink" title="使用多个TCP连接"></a>使用多个TCP连接</h2><p>由于 HTTP 1.x 不支持多路复用，浏览器可以不假思索地在客户端排队所有 HTTP请求，然后通过一个持久连接，一个接一个地发送这些请求。浏览器开发商没有别的办法，只能允许我们并行打开多个 TCP会话。多少个？现实中，大多数现代浏览器，包括桌面和移动浏览器，都支持每个主机打开 6 个连接。</p><p>同时打开多个 TCP 连接意味着什么:</p><ul><li>客户端可以并行分派最多 6 个请求；</li><li>服务器可以并行处理最多 6 个请求；</li><li>第一次往返可以发送的累计分组数量（TCP cwnd）增长为原来的 6 倍。</li></ul><p>这样做的代价：</p><ul><li>更多的套接字会占用客户端、服务器以及代理的资源，包括内存缓冲区和 CPU时钟周期；</li><li>并行 TCP 流之间竞争共享的带宽；</li><li>由于处理多个套接字，实现复杂性更高；</li><li>即使并行 TCP 流，应用的并行能力也受限制</li></ul><p>实践中，CPU 和内存占用并非微不足道，由此会导致客户端和服务器端的资源占用量上升，运维成本提高。</p><p>cwnd 值最近又提高到了 10 个分组，而所有最新的平台都能可靠地支持 TCP 窗口缩放。</p><h3 id="消耗客户端和服务器资源"><a href="#消耗客户端和服务器资源" class="headerlink" title="消耗客户端和服务器资源"></a>消耗客户端和服务器资源</h3><p>限制每个主机最多 6 个连接，可以让浏览器检测出无意（或有意）的 DoS（Denialof Service）攻击。如果没有这个限制，客户端有可能消耗掉服务器的所有资源。</p><p>讽刺的是，同样的安全检测在某些浏览器上却会招致反向攻击：如果客户端超过了最大连接数，那么所有后来的客户端请求都将被阻塞。大家可以做个试验，在一个主机上同时打开 6 个并行下载，然后再打开第 7 个下载请求，这个请求会挂起，直到前面的请求完成才会执行。</p><p>用足客户端连接的限制似乎是一个可以接受的安全问题，但对于需要实时交付数据的应用而言，这样做越来越容易造成部署上的问题。比如 WebSocket、ServerSent Event 和挂起 XHR，这些会话都会占用整整一个 TCP 流，而不管有无数据传输——记住，没有多路复用一说！实际上，如果你不注意，那很可能自己对自己的应用施加 DoS 攻击。</p><h2 id="域名分区"><a href="#域名分区" class="headerlink" title="域名分区"></a>域名分区</h2><p>HTTP 1.x 协议的一项空白强迫浏览器开发商引入并维护着连接池，每个主机最多 6个 TCP 流。好的一方面是对这些连接的管理工作都由浏览器来处理。作为应用开发者，你根本不必修改自己的应用。不好的一方面呢，就是 6 个并行的连接对你的应用来说可能仍然不够用。</p><p>根据 HTTP Archive 的统计，目前平均每个页面都包含 90 多个独立的资源，如果这些资源都来自同一个主机，那么仍然会导致明显的排队等待（图 11-5）。实际上，何必把自己只限制在一个主机上呢？我们不必只通过一个主机（例如 <a href="http://www.example.com）提供所有资源，而是可以手工将所有资源分散到多个子域名：{shard1,shardn}.example.com。由于主机名称不一样了，就可以突破浏览器的连接限制，实现更高的并行能力。域名分区使用得越多，并行能力就越强！" target="_blank" rel="noopener">www.example.com）提供所有资源，而是可以手工将所有资源分散到多个子域名：{shard1,shardn}.example.com。由于主机名称不一样了，就可以突破浏览器的连接限制，实现更高的并行能力。域名分区使用得越多，并行能力就越强！</a></p><p>天下没有免费的午餐，域名分区也不例外：每个新主机名都要求有一次额外的 DNS 查询，每多一个套接字都会多消耗两端的一些资源，而更糟糕的是，站点作者必须手工分离这些资源，并分别把它们托管到多个主机上。</p><p>实践中，把多个域名（如 shard1.example.com、shard2.example.com）解析到同一个 IP 地址是很常见的做法。所有分区都通过 CNAME DNS 记录指向同一个服务器，而浏览器连接限制针对的是主机名，不是 IP 地址。另外，每个分区也可以指向一个 CDN 或其他可以访问到的服务器。</p><p>怎么计算最优的分区数目呢？这个问题不好回答，因为没有简单的方程式。答案取决于页面中资源的数量（每个页面都可能不一样），以及客户端连接的可用带宽和延迟（因客户端而异）。实际上，我们能做的，就是在调查的基础上做出预测，然后使用固定数量的分区。幸运的话，多这么一点复杂性，还是能给大多数用户带来好处的。</p><p>注意:</p><ul><li>首先，把 TCP 利用好</li><li>浏览器会自动为你打开 6 个连接；</li><li>资源的数量、大小和响应时间都会影响最优的分区数目；</li><li>客户端延迟和带宽会影响最优的分区数目；</li><li>域名分区会因为额外的 DNS 查询和 TCP 慢启动而影响性能。</li></ul><p>域名分区是一种合理但又不完美的优化手段。请大家一定先从最小分区数目（不分区）开始，然后逐个增加分区并度量分区后对应用的影响。现实当中，真正因同时打开十几个连接而提升性能的站点并不多，如果你最终使用了很多分区，那么你会发现减少资源数量或者将它们合并为更少的请求，反而能带来更大的好处。</p><h2 id="度量和控制协议开销"><a href="#度量和控制协议开销" class="headerlink" title="度量和控制协议开销"></a>度量和控制协议开销</h2><p>有时，寥寥 15 个字符的 JSON 消息被 352 字节的 HTTP 首部包裹着，全部以纯文本形式发送——协议字节开销占 96%，而且这还是没有 cookie 的最好情况。减少要传输的首部数据（高度重复且未压缩），可以节省相当于一次往返的延迟时间，显著提升很多 Web 应用的性能。</p><p>主要就是度量下，内容和协议大小，为下节连接和拼合做准备。</p><p>注：</p><ul><li>Cookie 在很多应用中都是常见的性能瓶颈，很多开发者都会忽略它给每次请求增加的额外负担。</li></ul><h2 id="连接与拼合"><a href="#连接与拼合" class="headerlink" title="连接与拼合"></a>连接与拼合</h2><p>最快的请求是不用请求。不管使用什么协议，也不管是什么类型的应用，减少请求次数总是最好的性能优化手段。可是，如果你无论如何也无法减少请求，那么对HTTP 1.x 而言，可以考虑把多个资源捆绑打包到一块，通过一次网络请求获取：</p><ul><li><p>连接</p><p>把多个 JavaScript 或 CSS 文件组合为一个文件。</p></li><li><p>拼合</p><p>把多张图片组合为一个更大的复合的图片。</p></li></ul><p>对 JavaScript 和 CSS 来说，只要保持一定的顺序，就可以做到把多个文件连接起来而不影响代码的行为和执行。类似地，多张图片可以组合为一个“图片精灵”，然后使用 CSS 选择这张大图中的适当部分，显示在浏览器中。这两种技术都具备两方面的优点。</p><ul><li><p>减少协议开销</p><p>通过把文件组合成一个资源，可以消除与文件相关的协议开销。如前所述，每个文件很容易招致 KB 级未压缩数据的开销。</p></li><li><p>应用层管道</p><p>说到传输的字节，这两种技术的效果都好像是启用了 HTTP 管道：来自多个响应的数据前后相继地连接在一起，消除了额外的网络延迟。实际上，就是把管道提高了一层，置入了应用中。</p></li></ul><p>连接和拼合技术都属于以内容为中心的应用层优化，它们通过减少网络往返开销，可以获得明显的性能提升。可是，实现这些技术也要求额外的处理、部署和编码（比如选择图片精灵中子图的 CSS 代码），因而也会给应用带来额外的复杂性。此外，把多个资源打包到一块，也可能给缓存带来负担，影响页面的执行速度。</p><p>要理解为什么这些技术会伤害性能，可以考虑一种并不少见的情况：一个包含十来个 JavaScript 和 CSS 文件的应用，在产品状态下把所有文件合并为一个 CSS 文件和一个 JavaScript 文件。</p><ul><li>相同类型的资源都位于一个 URL（缓存键）下面。</li><li>资源包中可能包含当前页面不需要的内容。</li><li>对资源包中任何文件的更新，都要求重新下载整个资源包，导致较高的字节开销。</li><li>JavaScript 和 CSS 只有在传输完成后才能被解析和执行，因而会拖慢应用的执行速度。</li></ul><p>所以将资源合理的打包很重要。这也需要度量。</p><p>内存占用也会成为问题。对图片精灵来说，浏览器必须分析整个图片，即便实际上只显示了其中的一小块，也要始终把整个图片都保存在内存中。浏览器是不会把不显示的部分从内存中剔除掉的！</p><p>为什么执行速度还会受影响呢？我们知道，浏览器是以递增方式处理HTML 的，而对于 JavaScript 和 CSS 的解析及执行，则要等到整个文件下载完毕。JavaScript 和 CSS 处理器都不允许递增式执行。</p><p><strong>CSS 和 JavaScript 文件大小与执行性能</strong></p><p>CSS 文件越大，浏览器在构建 CSSOM 前经历的阻塞时间就越长，从而推迟首次绘制页面的时间。类似地，JavaScript 文件越大，对执行速度的影响同样越大；小文件倒是能实现“递增式”执行。</p><p>打包文件到底多大合适呢？可惜的是，没有理想的大小。然而，谷歌 PageSpeed团队的测试表明，30~50 KB（压缩后）是每个 JavaScript 文件大小的合适范围：既大到了能够减少小文件带来的网络延迟，还能确保递增及分层式的执行。具体的结果可能会由于应用类型和脚本数量而有所不同。</p><p>总之，连接和拼合是在 HTTP 1.x 协议限制（管道没有得到普遍支持，多请求开销大）的现实之下可行的应用层优化。使用得当的话，这两种技术可以带来明显的性能提升，代价则是增加应用的复杂度，以及导致缓存、更新、执行速度，甚至渲染页面的问题。应用这两种优化时，要注意度量结果，根据实际情况考虑如下问题。</p><ul><li>你的应用在下载很多小型的资源时是否会被阻塞？</li><li>有选择地组合一些请求对你的应用有没有好处？</li><li>放弃缓存粒度对用户有没有负面影响？</li><li>组合图片是否会占用过多内存？</li><li>首次渲染时是否会遭遇延迟执行？</li></ul><p><strong>举例：优化 Gmail 性能</strong></p><p>Gmail 使用了大量 JavaScript，而且也不断拓展了现代浏览器的性能边界。要提升首次加载性能，Gmail 团队尝试了各种技术，目前包括如下这些：</p><ul><li>把首次绘制所需的 CSS 单独拿出来，优先于其他 CSS 文件发送；</li><li>递增地交付较小的 JavaScript 块，以实现递增式执行；</li><li>使用定制的外部更新机制，即客户端在后台下载新的 JavaScript 文件，然后在页面刷新时更新。</li></ul><p>鉴于 Gmail 如此庞大的用户数量，如果所有打开的浏览器都要更新脚本，那哪怕一次简单的 JavaScript 更新，都可能演变为一次自残式的 DoS 攻击。为此，Gmail会在用户使用旧版本页面时，在后台预先加载更新文件，这样既可以分散负荷，又能提升下一次刷新时的速度。这个过程每天都重复不止一次。</p><p>在此基础上，为了让用户感觉第一次加载的速度很快，Gmail 团队还在 HTML 文档中嵌入了关键性 CSS 和 JavaScript，然后以块的形式递增加载其余 JavaScript 文件，以加快脚本执行——第一次打开 Gmail 时显示的进度条，反映的就是这个过程！</p><h2 id="嵌入资源"><a href="#嵌入资源" class="headerlink" title="嵌入资源"></a>嵌入资源</h2><p>嵌入资源是另一种非常流行的优化方法，把资源嵌入文档可以减少请求的次数。比如，JavaScript 和 CSS 代码，通过适当的 script 和 style 块可以直接放在页面中，而图片甚至音频或 PDF 文件，都可以通过数据 URI（data:[mediatype][;base64],data）的方式嵌入到页面中：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"data:image/gif;base64,R0lGODlhAQABAIAAAAA</span></span></div><div class="line"><span class="tag"><span class="string"> AAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw=="</span></span></div><div class="line"><span class="tag"> <span class="attr">alt</span>=<span class="string">"1x1 transparent (GIF) pixel"</span> /&gt;</span></div></pre></td></tr></table></figure></p><p>前面的例子是在文档中嵌入了一个 1×1 的透明 GIF 像素。而任何 MIME类型，只要浏览器能理解，都可以通过类似方式嵌入到页面中，包括PDF、音频、视频。不过，有些浏览器会限制数据 URI 的大小，比如 IE8最大只允许 32 KB。</p><p>建议：</p><ul><li>如果文件很小，而且只有个别页面使用，可以考虑嵌入；</li><li>如果文件很小，但需要在多个页面中重用，应该考虑集中打包；</li><li>如果小文件经常需要更新，就不要嵌入了；</li><li>通过减少 HTTP cookie 的大小将协议开销最小化。</li></ul><p>数据 URI 适合特别小的，理想情况下，最好是只用一次的资源。以嵌入方式放到页面中的资源，应该算是页面的一部分，不能被浏览器、CDN 或其他缓存代理作为单独的资源缓存。换句话说，如果在多个页面中都嵌入同样的资源，那么这个资源将会随着每个页面的加载而被加载，从而增大每个页面的总体大小。另外，如果嵌入资源被更新，那么所有以前出现过它的页面都将被宣告无效，而由客户端重新从服务器获取。</p><p>最后，虽然 CSS 和 JavaScript 等基于文本的资源很容易直接嵌入页面，也不会带来多余的开销，但非文本性资源则必须通过 base64 编码，而这会导致开销明显增大：编码后的资源大小比原大小增大 33% ！</p><h1 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h1><p>HTTP 2.0 可以让我们的应用更快、更简单、更健壮——这几词凑到一块是很罕见的！ HTTP 2.0 把很多以前我们针对 HTTP 1.1 想出来的“歪招儿”一笔勾销，把解决那些问题的方案内置在了传输层中。不仅如此，HTTP 2.0 还为我们进一步优化应用、改进性能，提供了全新的机会！</p><p>HTTP 2.0 的目的就是通过支持请求与响应的多路复用来减少延迟，通过压缩 HTTP首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持。为达成这些目标，HTTP 2.0 还会给我们带来大量其他协议层面的辅助实现，比如新的流量控制、错误处理和更新机制。上述几种机制虽然不是全部，但却是最重要的，所有 Web 开发者都应该理解并在自己的应用中利用它们。</p><p>HTTP 2.0 不会改动 HTTP 的语义。HTTP 方法、状态码、URI 及首部字段，等等这些核心概念一如往常。但是，HTTP 2.0 修改了格式化数据（分帧）的方式，以及客户端与服务器间传输这些数据的方式。这两点统帅全局，通过新的组帧机制向我们的应用隐藏了所有复杂性。换句话说，所有原来的应用都可以不必修改而在新协议运行。这当然是好事。</p><p>可是，我们关心的不止是交付能用的应用，我们目标是交付最佳性能！ HTTP 2.0为我们的应用提供了很多新的优化机制，这些机制是前所未有的，而我们的工作就是把它们都利用好。</p><h2 id="历史及其与SPDY的渊源"><a href="#历史及其与SPDY的渊源" class="headerlink" title="历史及其与SPDY的渊源"></a>历史及其与SPDY的渊源</h2><p>SPDY 是谷歌开发的一个实验性协议，于 2009 年年中发布，其主要目标是通过解决HTTP 1.1 中广为人知的一些性能限制，来减少网页的加载延迟。大致上，这个项目设定的目标如下：</p><ul><li>页面加载时间（PLT，Page Load Time）降低 50%；</li><li>无需网站作者修改任何内容；</li><li>把部署复杂性降至最低，无需变更网络基础设施；</li><li>与开源社区合作开发这个新协议；</li><li>收集真实性能数据，验证这个实验性协议是否有效。</li></ul><p>为了达到降低 50% 页面加载时间的目标，SPDY 引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层 TCP 连接。</p><h2 id="走向HTTP-2-0"><a href="#走向HTTP-2-0" class="headerlink" title="走向HTTP 2.0"></a>走向HTTP 2.0</h2><p>SPDY 是 HTTP 2.0 的催化剂，但 SPDY 并非 HTTP 2.0。2012 年初，W3C 向社会征集 HTTP 2.0 的建议，HTTP-WG 经过内部讨论，决定将 SPDY 规范作为制定标准的基础。从那时起，SPDY 已经经过了很多变化和改进，而且在 HTTP 2.0 官方标准公布之前，还将有很多变化和改进。</p><p>HTTP 2.0 致力于突破上一代标准众所周知的性能限制，但它也是对之前1.x 标准的扩展，而非替代。HTTP 的语义不变，提供的功能不变，HTTP 方法、状态码、URI 和首部字段，等等这些核心概念也不变；这些方面的变化都不在考虑之列。既然如此，那“2.0”还名副其实吗？之所以要递增一个大版本到 2.0，主要是因为它改变了客户端与服务器之间交换数据的方式。为实现宏伟的性能改进目标，HTTP 2.0 增加了新的二进制分帧数据层，而这一层并不兼容之前的 HTTP 1.x 服务器及客户端——是谓 2.0。</p><blockquote><p>除非你在实现 Web 服务器或者定制客户端，需要使用原始的 TCP 套接字，否则你很可能注意不到 HTTP 2.0 技术面的实际变化：所有新的、低级分帧机制都是浏览器和服务器为你处理的。或许唯一的区别就是可选的 API多了一些，比如服务器推送！</p></blockquote><h2 id="设计和技术目标"><a href="#设计和技术目标" class="headerlink" title="设计和技术目标"></a>设计和技术目标</h2><h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h3><p><img src="http://p1aqu3lsq.bkt.clouddn.com//WebPerformance/http2_1.png" alt=""></p><h3 id="流、消息和帧"><a href="#流、消息和帧" class="headerlink" title="流、消息和帧"></a>流、消息和帧</h3><ul><li><p>流</p><p>已建立的连接上的双向字节流。</p></li><li><p>消息</p><p>与逻辑消息对应的完整的一系列数据帧。</p></li><li><p>帧</p><p>HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流。</p></li></ul><p><img src="http://p1aqu3lsq.bkt.clouddn.com//WebPerformance/http2_3.png" alt=""></p><p>所有 HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。</p><p>要理解 HTTP 2.0，就必须理解流、消息和帧这几个基本概念。</p><ul><li>所有通信都在一个 TCP 连接上完成。</li><li>流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数<br>标识符（1、2…N）。</li><li>消息是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。</li><li>帧是最小的通信单位，承载着特定类型的数据，如 HTTP 首部、负荷，等等。</li></ul><p>简言之，HTTP 2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。相应地，很多流可以并行地在同一个 TCP 连接上交换消息</p><h3 id="多向请求与响应"><a href="#多向请求与响应" class="headerlink" title="多向请求与响应"></a>多向请求与响应</h3><p>在 HTTP 1.x 中，如果客户端想发送多个并行的请求以及改进性能，那么必须使用多个 TCP 连接。这是 HTTP 1.x 交付模型的直接结果，该模型会保证每个连接每次只交付一个响应（多个响应必须排队）。更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下。</p><p>HTTP 2.0 中新的二进制分帧层突破了这些限制，实现了多向请求和响应：客户端和服务器可以把 HTTP 消息分解为互不依赖的帧（图 12-3），然后乱序发送，最后再在另一端把它们重新组合起来。</p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//WebPerformance/http2_2.png" alt=""></p><p>优点：</p><ul><li>可以并行交错地发送请求，请求之间互不影响；</li><li>可以并行交错地发送响应，响应之间互不干扰；</li><li>只使用一个连接即可并行发送多个请求和响应；</li><li>消除不必要的延迟，从而减少页面加载的时间；</li><li>不必再为绕过 HTTP 1.x 限制而多做很多工作；</li><li>更多优势。</li></ul><p>总之，HTTP 2.0 的二进制分帧机制解决了 HTTP 1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。结果，就是应用速度更快、开发更简单、部署成本更低。</p><blockquote><p>支持多向请求与响应，可以省掉针对 HTTP 1.x 限制所费的那些脑筋和工作，比如拼接文件、图片精灵、域名分区。类似地，通过减少 TCP 连接的数量，HTTP 2.0 也会减少客户端和服务器的 CPU 及内存占用。</p></blockquote><h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，进一步提升性能。为了做到这一点，每个流都可以带有一个 31 比特的优先值：</p><ul><li>0 表示最高优先级；</li><li>2^31-1 表示最低优先级。</li></ul><p><strong>浏览器请求优先级与 HTTP 2.0</strong><br>浏览器在渲染页面时，并非所有资源都具有相同的优先级：HTML 文档本身对构建 DOM 不可或缺，CSS 对构建 CSSOM 不可或缺，而 DOM 和 CSSOM 的构建都可能受到 JavaScript 资源的阻塞，其他资源（如图片）的优先级都可以降低。</p><p>为加快页面加载速度，所有现代浏览器都会基于资源的类型以及它在页面中的位置排定请求的优先次序，甚至通过之前的访问来学习优先级模式——比如，之前的渲染如果被某些资源阻塞了，那么同样的资源在下一次访问时可能就会被赋予更高的优先级。</p><p>在 HTTP 1.x 中，浏览器极少能利用上述优先级信息，因为协议本身并不支持多路复用，也没有办法向服务器通告请求的优先级。此时，浏览器只能依赖并行连接，且最多只能同时向一个域名发送 6 个请求。于是，在等连接可用期间，请求只能在客户端排队，从而增加了不必要的网络延迟。理论上，HTTP 管道可以解决这个问题，只是由于缺乏支持而无法付诸实践。</p><p>HTTP 2.0 一举解决了所有这些低效的问题：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。</p><p>我们也要合理度量，因为：</p><p>如果服务器不理睬所有优先值，那么可能会导致应用响应变慢：浏览器明明在等关键的 CSS 和 JavaScript，服务器却在发送图片，从而造成渲染阻塞。不过，规定严格的优先级次序也可能带来次优的结果，因为这可能又会引入队首阻塞问题，即某个高优先级的慢请求会不必要地阻塞其他资源的交付。</p><p>服务器可以而且应该交错发送不同优先级别的帧。只要可能，高优先级流都应该优先，包括分配处理资源和客户端与服务器间的带宽。不过，为了最高效地利用底层连接，不同优先级的混合也是必需的。</p><h2 id="每个来源一个连接"><a href="#每个来源一个连接" class="headerlink" title="每个来源一个连接"></a>每个来源一个连接</h2><p>有了新的分帧机制后，HTTP 2.0 不再依赖多个 TCP 连接去实现多流并行了。现在，每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别优先级。于是，所有HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。</p><p>所以我们可以停止<strong>域名分区</strong>了。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>在同一个 TCP 连接上传输多个数据流，就意味着要共享带宽。标定数据流的优先级有助于按序交付，但只有优先级还不足以确定多个数据流或多个连接间的资源分配。为解决这个问题，HTTP 2.0 为数据流和连接的流量控制提供了一个简单的机制：</p><ul><li>流量控制基于每一跳进行，而非端到端的控制；</li><li>流量控制基于窗口更新帧进行，即接收方广播自己准备接收某个数据流的多少字节，以及对整个连接要接收多少字节；</li><li>流量控制窗口大小通过 WINDOW_UPDATE 帧更新，这个字段指定了流 ID 和窗口大小递增值；</li><li>流量控制有方向性，即接收方可能根据自己的情况为每个流乃至整个连接设置任意窗口大小；</li><li>流量控制可以由接收方禁用，包括针对个别的流和针对整个连接。</li></ul><blockquote><p>HTTP 2.0 连接建立之后，客户端与服务器交换 SETTINGS 帧，目的是设置双向的流量控制窗口大小。除此之外，任何一端都可以选择禁用个别流或整个连接的流量控制。</p></blockquote><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。</p><p>为什么需要这样一个机制呢？通常的 Web 应用都由几十个资源组成，客户端需要分析服务器提供的文档才能逐个找到它们。那为什么不让服务器提前就把这些资源推送给客户端，从而减少额外的时间延迟呢？服务器已经知道客户端下一步要请求什么资源了，这时候服务器推送即可派上用场。事实上，如果你在网页里嵌入过 CSS、JavaScript，或者通过数据 URI 嵌入过其他资源，那你就已经亲身体验过服务器推送了。</p><p>把资源直接插入到文档中，就是把资源直接推送给客户端，而无需客户端请求。在HTTP 2.0 中，唯一的不同就是可以把这个过程从应用中拿出来，放到 HTTP 协议本身来实现，而且还带来了如下好处：</p><ul><li>客户端可以缓存推送过来的资源；</li><li>客户端可以拒绝推送过来的资源；</li><li>推送资源可以由不同的页面共享；</li><li>服务器可以按照优先级推送资源。</li></ul><blockquote><p>所有推送的资源都遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。</p></blockquote><h2 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h2><p>HTTP 的每一次通信都会携带一组首部，用于描述传输的资源及其属性。在 HTTP  1.x 中，这些元数据都是以纯文本形式发送的，通常会给每个请求增加 500~800 字节的负荷。如果算上 HTTP cookie，增加的负荷通常会达到上千字节。为减少这些开销并提升性能，HTTP 2.0 会压缩首部元数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结了针对 &lt;strong&gt;HTTP 1.x&lt;/strong&gt; 和 &lt;strong&gt;HTTP 2.0&lt;/strong&gt; 的优化，以及 &lt;strong&gt;HTTP 2.0&lt;/strong&gt; 的一些历史。&lt;br&gt;
    
    </summary>
    
      <category term="web优化" scheme="https://hddhyq.github.io/categories/web%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Web优化" scheme="https://hddhyq.github.io/tags/Web%E4%BC%98%E5%8C%96/"/>
    
      <category term="Web性能" scheme="https://hddhyq.github.io/tags/Web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>css揭秘总结(四)</title>
    <link href="https://hddhyq.github.io/2018/01/05/css%E6%8F%AD%E7%A7%98%E6%80%BB%E7%BB%93%E5%9B%9B/"/>
    <id>https://hddhyq.github.io/2018/01/05/css揭秘总结四/</id>
    <published>2018-01-05T06:15:37.000Z</published>
    <updated>2018-07-08T04:25:55.514Z</updated>
    
    <content type="html"><![CDATA[<p>主要是CSS揭秘的最后一章，过渡与动画。<br><a id="more"></a></p><h1 id="过渡和动画"><a href="#过渡和动画" class="headerlink" title="过渡和动画"></a>过渡和动画</h1><h2 id="42-缓动效果"><a href="#42-缓动效果" class="headerlink" title="42. 缓动效果"></a>42. 缓动效果</h2><blockquote><p>背景知识：基本的 CSS 过渡，基本的 CSS 动画</p></blockquote><h3 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h3><p>给过渡和动画加上缓动效果（比如具有回弹效果的过渡过程）是一种流行的表现手法，可以让界面显得更加生动和真实：在现实世界中，物体从 A点到 B 点的移动往往不是完全匀速的。所以我们主要要讨论的就是回弹效果。这里主要要讲的就是贝塞尔曲线。</p><p>常见需要回弹的效果体验：</p><ul><li>尺寸变化（比如：元素在 :hover 时变大，弹出框从 transform:scale(0) 的状态开始放大显示，柱状图中的每根柱子动态地冒出来，等等）</li><li>角度变化（比如：元素的旋转动作，饼图中的各个扇区以动画的方式从 0°开始展开为实际大小，等等）</li></ul><h3 id="弹跳动画"><a href="#弹跳动画" class="headerlink" title="弹跳动画"></a>弹跳动画</h3><p>常见的内置缓动曲线：<br><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/easeLinear.png" alt=""></p><p>ease-out 是 ease-in 是反向版本。这一对组合正好是实现回弹效果所需要的：每当小球的运动方向相反时，我们希望调速函数也是相反的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> bounce &#123;</div><div class="line"> 60%, 80%, <span class="selector-tag">to</span> &#123;</div><div class="line">   <span class="attribute">transform</span>: <span class="built_in">translateY</span>(400px);</div><div class="line"> <span class="attribute">animation-timing-function</span>: ease-out;</div><div class="line"> &#125;</div><div class="line"> 70% &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(300px); &#125;</div><div class="line"> 90% &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(360px); &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.ball</span> &#123;</div><div class="line"> <span class="comment">/* 其余样式写在这里 */</span></div><div class="line"> <span class="attribute">animation</span>: bounce <span class="number">3s</span> ease-in;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="cubic-bezier-函数"><a href="#cubic-bezier-函数" class="headerlink" title="cubic-bezier() 函数"></a>cubic-bezier() 函数</h3><p>把控制锚点的水平坐标和垂直坐标互换，就可以得到任何调速函数的反向版本。</p><p>cubic-bezier.com</p><h3 id="弹性过渡"><a href="#弹性过渡" class="headerlink" title="弹性过渡"></a>弹性过渡</h3><p>假设有一个文本输入框，每当它被聚焦时，都需要展示一个提示框。</p><p>如果我们需要一个文本框先慢慢扩大至1.1倍，再回弹至1倍，那么收缩的时候，会有一个scale(-0.1)的收缩，而不是scale(1.1)。<br><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/收缩.png" alt=""></p><p>这里我们需要单独设置，盖 <code>transition-duration</code>,可以用 <code>transition</code> 这个简写属性来覆盖所有的值，就不需要显式指定 <code>ease</code>，因为它本来就是初始值。再指定一下<code>transition-property</code>就可以了。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:focus)</span> + <span class="selector-class">.callout</span> &#123;</div><div class="line"> <span class="attribute">transform</span>: <span class="built_in">scale</span>(0);</div><div class="line"> <span class="attribute">transition</span>: .<span class="number">25s</span> transform;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.callout</span> &#123;</div><div class="line"> <span class="attribute">transform-origin</span>: <span class="number">1.4em</span> -.<span class="number">4em</span>;</div><div class="line"> <span class="attribute">transition</span>: .<span class="number">5s</span> <span class="built_in">cubic-bezier</span>(.25,.1,.3,1.5) transform;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="43-逐帧动画"><a href="#43-逐帧动画" class="headerlink" title="43. 逐帧动画"></a>43. 逐帧动画</h2><p>在很多时候，我们需要一个很难（或不可能）只通过某些 CSS 属性的过渡来实现的动画。比如一段卡通影片，或是一个复杂的进度指示框。在这种场景下，基于图片的逐帧动画才是完美的选择；不过想在网页中以一种灵活的方式来实现这种动画，可谓是一项惊人的挑战。</p><h3 id="GIF动画短板"><a href="#GIF动画短板" class="headerlink" title="GIF动画短板"></a>GIF动画短板</h3><ul><li>GIF 图片的所能使用的颜色数量被限制在 256 色。</li><li>GIF 不具备 Alpha 透明的特性。当我们不确定 GIF 动画的下层是什么时，这往往是一个大问题。</li><li>我们无法在 CSS 层面修改动画的某些参数，比如动画的持续时间、循环次数、是否暂停等。</li></ul><p>2004 年，Mozilla 发起了一个建议：在 PNG 格式中增加对逐帧动画的支持，就像 GIF 格式同时支持静态图像和动画一样。这种格式被称作APNG。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>假设我们已经把动画中的所有帧全部拼合到一张 PNG 图片中了，如图:<br><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/菊花图.png" alt=""></p><p>动画平滑特性恰恰毁掉了我们想实现的逐帧动画效果。此时我们需要<code>steps()</code> ：<br><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/steps.png" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loader"</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> loader &#123;</div><div class="line"> <span class="selector-tag">to</span> &#123; <span class="attribute">background-position</span>: -<span class="number">800px</span> <span class="number">0</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.loader</span> &#123;</div><div class="line"> <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line"> <span class="attribute">background</span>: <span class="built_in">url</span>(img/loader.png) <span class="number">0</span> <span class="number">0</span>;</div><div class="line"> <span class="attribute">animation</span>: loader <span class="number">1s</span> infinite <span class="built_in">steps</span>(8);</div><div class="line"> <span class="comment">/* 把文本隐藏起来 */</span></div><div class="line"> <span class="attribute">text-indent</span>: <span class="number">200%</span>;</div><div class="line"> <span class="attribute">white-space</span>: nowrap;</div><div class="line"> <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="44-闪烁效果"><a href="#44-闪烁效果" class="headerlink" title="44. 闪烁效果"></a>44. 闪烁效果</h2><blockquote><p>背景知识：基本的 CSS 动画，“逐帧动画”</p></blockquote><h3 id="难题-1"><a href="#难题-1" class="headerlink" title="难题"></a>难题</h3><p>就是通过数次闪烁（不超过三次）来提示用户界面中有某处发生了变化，或者用来凸显出当前链接的目标。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="50-循环动画"><a href="#50-循环动画" class="headerlink" title="50%循环动画"></a>50%循环动画</h4><p><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/生硬闪烁.png" alt="">，<br>将动画的起点，调整到50%来避免生硬的跳转。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> blink-smooth &#123; 50% &#123; <span class="attribute">color</span>: transparent &#125; &#125;</div><div class="line"><span class="selector-class">.highlight</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: <span class="number">1s</span> blink-smooth <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="alternate动画（alternate-reverse动画）"><a href="#alternate动画（alternate-reverse动画）" class="headerlink" title="alternate动画（alternate-reverse动画）"></a>alternate动画（alternate-reverse动画）</h4><p><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/alternate闪烁.png" alt=""><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> blink-smooth &#123; <span class="selector-tag">to</span> &#123; <span class="attribute">color</span>: transparent &#125; &#125;</div><div class="line"><span class="selector-class">.highlight</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: .<span class="number">5s</span> blink-smooth <span class="number">6</span> alternate;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="普通闪烁效果"><a href="#普通闪烁效果" class="headerlink" title="普通闪烁效果"></a>普通闪烁效果</h4><p><code>steps(1)</code>本质上等同于 <code>steps(1, end)</code>。如果直接从0开始跳转，那么感觉就是没有任何效果。颜色值的切换只会发生在动画周期的末尾。因此，我们会看到起始值贯穿于整个动画周期，而终止值只在动画结尾的无限短的时间点处出现。</p><p>唯一的解决方案是调整动画的关键帧，让切换动作发生在 50% 处。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> blink &#123; 50% &#123; <span class="attribute">color</span>: transparent &#125; &#125;</div><div class="line"><span class="selector-class">.highlight</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> blink <span class="number">3</span> <span class="built_in">steps</span>(1); <span class="comment">/* 或用step-end */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="45-打字动画"><a href="#45-打字动画" class="headerlink" title="45. 打字动画"></a>45. 打字动画</h2><blockquote><p>背景知识：基本的 CSS 动画，“逐帧动画”，“闪烁效果”</p></blockquote><h3 id="难题-2"><a href="#难题-2" class="headerlink" title="难题"></a>难题</h3><p>有些时候，我们希望一段文本中的字符逐个显现，模拟出一种打字的效果。这个效果在技术类网站中尤为流行，用等宽字体可以营造出一种终端命令行的感觉。</p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/打字动画.png" alt=""></p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>核心思路就是让容器的宽度成为动画的主体：把所有文本包裹在这个容器中，然后让它的宽度从 0 开始以步进动画的方式、一个字一个字地扩张到它应有的宽度。你可能已经察觉到了，这个方法是有局限的：它并不适用于多行文本 。然而幸运的是，在绝大多数情况下，我们把这种效果应用在类似标题的单行文本上。</p><p>另外一件需要注意的事情是，动画的持续时间越长，动画效果越差：持续时间较短的动画会让界面显得更加精致，在某些场景下还是有益于可用性的。反之，动画的持续时间越长，越容易让用户感到厌烦。因此，即使这个技巧可以用在大段文本身上，也不一定是个好主意。</p><p>中间需要解决的问题有：</p><ul><li>宽度的变化需要<code>steps</code>，所以<code>steps()</code>来修复。</li><li>我们已经用 em 单位指定了宽度，虽然它比像素单位要好一些，但仍然不够理想。通过 ch 单位来缓解。取值就是字符的数量。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> typing &#123;</div><div class="line"> <span class="selector-tag">from</span> &#123; <span class="attribute">width</span>: <span class="number">0</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line"> <span class="attribute">width</span>: <span class="number">15ch</span>; <span class="comment">/* 文本的宽度 */</span></div><div class="line"> <span class="attribute">overflow</span>: hidden;</div><div class="line"> <span class="attribute">white-space</span>: nowrap;</div><div class="line"> <span class="attribute">animation</span>: typing <span class="number">6s</span> <span class="built_in">steps</span>(15);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后添加上一个闪烁的光标</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> typing &#123;</div><div class="line"> <span class="selector-tag">from</span> &#123; <span class="attribute">width</span>: <span class="number">0</span> &#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> caret &#123;</div><div class="line"> 50% &#123; <span class="attribute">border-color</span>: transparent; &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line"> <span class="attribute">width</span>: <span class="number">15ch</span>; <span class="comment">/* 文本的宽度 */</span></div><div class="line"> <span class="attribute">overflow</span>: hidden;</div><div class="line"> <span class="attribute">white-space</span>: nowrap;</div><div class="line"> <span class="attribute">border-right</span>: .<span class="number">05em</span> solid;</div><div class="line"> <span class="attribute">animation</span>: typing <span class="number">6s</span> <span class="built_in">steps</span>(15),</div><div class="line"> caret <span class="number">1s</span> <span class="built_in">steps</span>(1) infinite;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="46-状态平滑的动画"><a href="#46-状态平滑的动画" class="headerlink" title="46. 状态平滑的动画"></a>46. 状态平滑的动画</h2><blockquote><p>背景知识: 基本的 CSS 动画，animation-direction（在“闪烁效果”中曾简要提及）</p></blockquote><p>不是所有动画都是在页面一加载好就立即播放的。更常见的情况是，我们想通过动画来响应用户的动作，比如用户的鼠标悬停在某个元素上（:hover），或者按住鼠标（:active），等等。在这种场景下，我们将无法控制动画实际的循环次数，因为用户的动作会随时中断动画，而此时动画不可能刚好插放到我们事先指定的循环次数。举例来说，用户的鼠标可能会触发一个华丽的:hover 动画，而在动画还没有播完的时候，鼠标就从元素上移走了。在这种情况下，你觉得动画会如何收场呢？</p><h3 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h3><p>暂停和继续一个一直存在的动画，重要的属性。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">animation-play-state</span>: <span class="selector-tag">paused</span>;</div><div class="line"><span class="selector-tag">animation-play-state</span>: <span class="selector-tag">running</span>;</div></pre></td></tr></table></figure></p><h2 id="沿环形路径平移的动画"><a href="#沿环形路径平移的动画" class="headerlink" title="沿环形路径平移的动画"></a>沿环形路径平移的动画</h2><blockquote><p>背景知识：CSS 动画，CSS 变形，“平行四边形”，“菱形图片”，“闪烁效果”</p></blockquote><h3 id="难题-3"><a href="#难题-3" class="headerlink" title="难题"></a>难题</h3><p><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/环形路径.png" alt=""></p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//Wallpapers/csssercets/404page.png" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"path"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"lea.jpg"</span> <span class="attr">class</span>=<span class="string">"avatar"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> spin &#123;</div><div class="line"> <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(1turn); &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.avatar</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: spin <span class="number">3s</span> infinite linear;</div><div class="line"> <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">150px</span>; <span class="comment">/* 150px = 路径的半径 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它不仅让头像沿着环形路径转动，同时还会让头像自身旋转</p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/自身旋转.png" alt=""></p><p>这里我只放出两个div方案。</p><h3 id="需要两个元素的解决方案"><a href="#需要两个元素的解决方案" class="headerlink" title="需要两个元素的解决方案"></a>需要两个元素的解决方案</h3><p>用内层的变形来抵消外层的变形效果。</p><p>抵消作用是贯穿于整个动画的每一帧的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"path"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"avatar"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"lea.jpg"</span> /&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> spin &#123;</div><div class="line"> <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(1turn); &#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> spin-reverse &#123;</div><div class="line"> <span class="selector-tag">from</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(1turn); &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.avatar</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: spin <span class="number">3s</span> infinite linear;</div><div class="line"> <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">150px</span>; <span class="comment">/* 150px = 路径的半径 */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.avatar</span> &gt; <span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: spin-reverse <span class="number">3s</span> infinite linear;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>利用一套动画css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> spin &#123;</div><div class="line"> <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(1turn); &#125;</div><div class="line"> &#125;</div><div class="line"><span class="selector-class">.avatar</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: spin <span class="number">3s</span> infinite linear;</div><div class="line"> <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">150px</span>; <span class="comment">/* 150px = 路径的半径 */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.avatar</span> &gt; <span class="selector-tag">img</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: inherit;</div><div class="line"> <span class="attribute">animation-direction</span>: reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是CSS揭秘的最后一章，过渡与动画。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://hddhyq.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://hddhyq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css揭秘总结(三)</title>
    <link href="https://hddhyq.github.io/2018/01/03/css%E6%8F%AD%E7%A7%98%E6%80%BB%E7%BB%93%E4%B8%89/"/>
    <id>https://hddhyq.github.io/2018/01/03/css揭秘总结三/</id>
    <published>2018-01-03T10:16:27.000Z</published>
    <updated>2018-07-08T04:25:55.513Z</updated>
    
    <content type="html"><![CDATA[<p>主要总结了书里的字体排版，用户体验，结构与布局。字体排版由于介绍英文比较多，这里就直接跳过了几个段落。<br><a id="more"></a></p><h1 id="字体排印"><a href="#字体排印" class="headerlink" title="字体排印"></a>字体排印</h1><h2 id="20-连字符断行"><a href="#20-连字符断行" class="headerlink" title="20. 连字符断行"></a>20. 连字符断行</h2><p>CSS 文本（第三版）引入了一个新的属性 hyphens。它接受三个值：none、manual 和 auto。manual 是它的初始值，其行为正好对应了现有的工作方式：我们可以在任何时候手工插入软连字符，来实现断词折行的效果。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">hyphens</span>: <span class="selector-tag">auto</span>;</div></pre></td></tr></table></figure></p><h2 id="21-插入换行"><a href="#21-插入换行" class="headerlink" title="21. 插入换行"></a>21. 插入换行</h2><p>通过 CSS 来插入换行的需求通常与定义列表有关。</p><p>利用伪类。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">dd</span> + <span class="selector-tag">dd</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">', '</span>;</div><div class="line"> <span class="attribute">margin-left</span>: -.<span class="number">25em</span>;</div><div class="line"> <span class="attribute">font-weight</span>: normal;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="22-文本行的斑马条纹"><a href="#22-文本行的斑马条纹" class="headerlink" title="22. 文本行的斑马条纹"></a>22. 文本行的斑马条纹</h2><blockquote><p>背景知识: CSS 渐变，background-size，“条纹背景”，“灵活的背景定位”</p></blockquote><h3 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(even)</span> &#123;</div><div class="line"> <span class="attribute">background</span>: <span class="built_in">rgba</span>(0,0,0,.2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>表格的“斑马条纹”，只需要一个伪类的选择就可以了。而文本呢。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们可以在CSS 中用渐变直接生成背景图像，为了让背景自动跟着内边距的宽度走，我们需要在解析 <code>background-position</code>时以 <code>content box</code> 的外沿作为基准。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">padding</span>: <span class="selector-class">.5em</span>;</div><div class="line"><span class="selector-tag">line-height</span>: 1<span class="selector-class">.5</span>;</div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">beige</span>;</div><div class="line"><span class="selector-tag">background-size</span>: <span class="selector-tag">auto</span> 3<span class="selector-tag">em</span>;</div><div class="line"><span class="selector-tag">background-origin</span>: <span class="selector-tag">content-box</span>;</div><div class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">rgba</span>(0,0,0,<span class="selector-class">.2</span>) 50%,</div><div class="line"> <span class="selector-tag">transparent</span> 0);</div></pre></td></tr></table></figure></p><h2 id="23-调整-tab-的宽度"><a href="#23-调整-tab-的宽度" class="headerlink" title="23. 调整 tab 的宽度"></a>23. 调整 tab 的宽度</h2><h3 id="难题-1"><a href="#难题-1" class="headerlink" title="难题"></a>难题</h3><p>调整网页code的宽度。</p><p>利用新属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">pre</span> &#123;</div><div class="line"> <span class="attribute">tab-size</span>: <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="24-连字"><a href="#24-连字" class="headerlink" title="24. 连字"></a>24. 连字</h2><p><code>font-variant-ligatures</code>来控制启用所有可能连字。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">font-variant-ligatures</span>: <span class="selector-tag">common-ligatures</span></div><div class="line">                        <span class="selector-tag">discretionary-ligatures</span></div><div class="line">                        <span class="selector-tag">historical-ligatures</span>;</div></pre></td></tr></table></figure><h2 id="25-华丽的-amp-符号"><a href="#25-华丽的-amp-符号" class="headerlink" title="25. 华丽的 &amp; 符号"></a>25. 华丽的 &amp; 符号</h2><blockquote><p>背景知识: 通过 @font-face </p></blockquote><p>规则实现基本的字体嵌入我们通常会在 font-family 声明中同时指定多个字体（即字体队列）。这样，即使我们指定的最优先字体不可用，浏览器还可以回退到其他符合整体设计风格的字体。</p><p>在这个规则之下，如果有一款字体只包含一个字符（你肯定猜到是哪个了吧），那这款字体将只用于显示这个字符，其他字符会由字体队列中排在第二位、第三位或更后面的字体来显示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">font-face</span> &#123;</div><div class="line"> <span class="attribute">font-family</span>: Ampersand;</div><div class="line"> <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">"fonts/ampersand.woff"</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line"> <span class="attribute">font-family</span>: Ampersand, Helvetica, sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>还需要一个描述符</strong>，<code>unicode-range</code>，要查出你想指定的这些字符的十六进制码位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">font-face</span> &#123;</div><div class="line"> <span class="attribute">font-family</span>: Ampersand;</div><div class="line"> <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">'Baskerville'</span>),</div><div class="line"> <span class="built_in">local</span>(<span class="string">'Goudy Old Style'</span>),</div><div class="line"> <span class="built_in">local</span>(<span class="string">'Palatino'</span>),</div><div class="line"> <span class="built_in">local</span>(<span class="string">'Book Antiqua'</span>);</div><div class="line"> <span class="attribute">unicode-range</span>: U+<span class="number">26</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line"> <span class="attribute">font-family</span>: Ampersand, Helvetica, sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="26-自定义下划线"><a href="#26-自定义下划线" class="headerlink" title="26. 自定义下划线"></a>26. 自定义下划线</h2><blockquote><p>背景知识: CSS 渐变，background-sizetext-shadow，“条纹背景”</p></blockquote><h3 id="难题-2"><a href="#难题-2" class="headerlink" title="难题"></a>难题</h3><p>默认太丑，<code>text-decoration: underline;</code>。</p><p><code>border-bottom</code>，会阻止正常的文本换行行为。<code>box-shadow: 0 -1px gray inset;</code>类似一样的会产生上述问题。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>最佳方案来自于<code>background-image</code> 及其相关属性。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">gray</span>, <span class="selector-tag">gray</span>) <span class="selector-tag">no-repeat</span>;</div><div class="line"><span class="selector-tag">background-size</span>: 100% 1<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">background-position</span>: 0 1<span class="selector-class">.15em</span>;</div></pre></td></tr></table></figure></p><p>新增：</p><ul><li>text-decoration-color 用于自定义下划线或其他装饰效果的颜色。</li><li>text-decoration-style 用于定义装饰效果的风格（比如实线、虚线、波浪线等）。</li><li>text-decoration-skip 用于指定是否避让空格、字母降部或其他对象。</li><li>text-underline-position 用于微调下划线的具体摆放位置。</li></ul><h2 id="27-现实中的文字效果"><a href="#27-现实中的文字效果" class="headerlink" title="27. 现实中的文字效果"></a>27. 现实中的文字效果</h2><blockquote><p>背景知识：基本的 text-shadow</p></blockquote><h3 id="凸版印刷效果"><a href="#凸版印刷效果" class="headerlink" title="凸版印刷效果"></a>凸版印刷效果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">hsl</span>(210, 13%, 40%);</div><div class="line"><span class="selector-tag">color</span>: <span class="selector-tag">hsl</span>(210, 13%, 75%);</div><div class="line"><span class="selector-tag">text-shadow</span>: 0 <span class="selector-tag">-1px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">black</span>;</div></pre></td></tr></table></figure><h3 id="空心字效果"><a href="#空心字效果" class="headerlink" title="空心字效果"></a>空心字效果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">deeppink</span>;</div><div class="line"><span class="selector-tag">color</span>: <span class="selector-tag">white</span>;</div><div class="line"><span class="selector-tag">text-shadow</span>: 1<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">black</span>, <span class="selector-tag">-1px</span> <span class="selector-tag">-1px</span> <span class="selector-tag">black</span>,</div><div class="line"> 1<span class="selector-tag">px</span> <span class="selector-tag">-1px</span> <span class="selector-tag">black</span>, <span class="selector-tag">-1px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">black</span>;</div></pre></td></tr></table></figure><h3 id="文字外发光效果"><a href="#文字外发光效果" class="headerlink" title="文字外发光效果"></a>文字外发光效果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-id">#203</span>;</div><div class="line"><span class="selector-tag">color</span>: <span class="selector-id">#ffc</span>;</div><div class="line"><span class="selector-tag">text-shadow</span>: 0 0 <span class="selector-class">.1em</span>, 0 0 <span class="selector-class">.3em</span>;</div></pre></td></tr></table></figure><h3 id="文字凸起效果"><a href="#文字凸起效果" class="headerlink" title="文字凸起效果"></a>文字凸起效果</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">mixin</span> text-3d(<span class="variable">$color</span>: white, <span class="variable">$depth</span>: 5) &#123;</div><div class="line"> <span class="variable">$shadows</span>: ();</div><div class="line"> <span class="variable">$shadow-color</span>: <span class="variable">$color</span>;</div><div class="line"> @<span class="keyword">for</span> <span class="variable">$i</span> from 1 through <span class="variable">$depth</span> &#123;</div><div class="line"> <span class="variable">$shadow-color</span>: darken(<span class="variable">$shadow-color</span>, <span class="number">10%</span>);</div><div class="line"> <span class="variable">$shadows</span>: append(<span class="variable">$shadows</span>,</div><div class="line"> <span class="number">0</span> (<span class="variable">$i</span> * <span class="number">1px</span>) <span class="variable">$shadow-color</span>, comma);</div><div class="line"> &#125;</div><div class="line"> <span class="attribute">color</span>: <span class="variable">$color</span>;</div><div class="line"> <span class="attribute">text-shadow</span>: append(<span class="variable">$shadows</span>,</div><div class="line"> <span class="number">0</span> (<span class="variable">$depth</span> * <span class="number">1px</span>) <span class="number">10px</span> black, comma);</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123; @<span class="keyword">include</span> text-3d(<span class="number">#eee</span>, 4); &#125;</div></pre></td></tr></table></figure><p>复古风格的排印效果</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@function text-retro(<span class="variable">$color</span>: black, <span class="variable">$depth</span>: 8) &#123;</div><div class="line"> <span class="variable">$shadows</span>: (<span class="number">1px</span> <span class="number">1px</span> <span class="variable">$color</span>,);</div><div class="line"> @<span class="keyword">for</span> <span class="variable">$i</span> from 2 through <span class="variable">$depth</span> &#123;</div><div class="line"> <span class="variable">$shadows</span>: append(<span class="variable">$shadows</span>,</div><div class="line"> (<span class="variable">$i</span>*<span class="number">1px</span>) (<span class="variable">$i</span>*<span class="number">1px</span>) <span class="variable">$color</span>, comma);</div><div class="line">  &#125;</div><div class="line"> @return <span class="variable">$shadows</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line"> <span class="attribute">color</span>: white;</div><div class="line"> <span class="attribute">background</span>: hsl(<span class="number">0</span>,<span class="number">50%</span>,<span class="number">45%</span>);</div><div class="line"> <span class="attribute">text-shadow</span>: text-retro();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="28-环形文字"><a href="#28-环形文字" class="headerlink" title="28. 环形文字"></a>28. 环形文字</h2><blockquote><p>背景知识：基本的 SVG</p></blockquote><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>在 SVG 中，让文本按照路径排列的基本方法就是用一个 <textpath>元 素 来 包 裹 住 这 段 文 本， 再 把 它 们 装 进 一 个 <text> 元 素 中。 这 个<textpath> 元素还需要在它的 ID 属性中引用一个 <path></path> 元素，然后就可以用这个 <path></path> 元素来定义我们想要的路径。</textpath></text></textpath></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$$(<span class="string">'.circular'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> NS = <span class="string">"http://www.w3.org/2000/svg"</span>;</div><div class="line"> <span class="keyword">var</span> xlinkNS = <span class="string">"http://www.w3.org/1999/xlink"</span>;</div><div class="line"> <span class="keyword">var</span> svg = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"svg"</span>);</div><div class="line"> <span class="keyword">var</span> circle = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"path"</span>);</div><div class="line"> <span class="keyword">var</span> text = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"text"</span>);</div><div class="line"> <span class="keyword">var</span> textPath = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"textPath"</span>);</div><div class="line"> svg.setAttribute(<span class="string">"viewBox"</span>, <span class="string">"0 0 100 100"</span>);</div><div class="line"> circle.setAttribute(<span class="string">"d"</span>, <span class="string">"M0,50 a50,50 0 1,1 0,1z"</span>);</div><div class="line"> circle.setAttribute(<span class="string">"id"</span>, <span class="string">"circle"</span>);</div><div class="line"> textPath.textContent = el.textContent;</div><div class="line"> textPath.setAttributeNS(xlinkNS, <span class="string">"xlink:href"</span>, <span class="string">"#circle"</span>);</div><div class="line"> text.appendChild(textPath);</div><div class="line"> svg.appendChild(circle);</div><div class="line"> svg.appendChild(text);</div><div class="line"> el.textContent = <span class="string">''</span>;</div><div class="line"> el.appendChild(svg);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h1 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h1><h2 id="29-选用合适的鼠标光标"><a href="#29-选用合适的鼠标光标" class="headerlink" title="29. 选用合适的鼠标光标"></a>29. 选用合适的鼠标光标</h2><h3 id="难题-3"><a href="#难题-3" class="headerlink" title="难题"></a>难题</h3><p>通过 <code>cursor</code> 属性来指定光标类型，比如 pointer 光标可以提示某个元素是可点击的，而 help 光标用来暗示这里有提示信息。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/cursor.png" alt=""></p><ol><li><p>提示禁用状态</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:disabled</span>, <span class="selector-attr">[disabled]</span>, <span class="selector-attr">[aria-disabled="true"]</span> &#123;</div><div class="line"> <span class="attribute">cursor</span>: not-allowed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>隐藏鼠标光标</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">video</span> &#123;</div><div class="line"> <span class="attribute">cursor</span>: <span class="built_in">url</span>(transparent.gif);</div><div class="line"> <span class="attribute">cursor</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="30-扩大可点击区域"><a href="#30-扩大可点击区域" class="headerlink" title="30. 扩大可点击区域"></a>30. 扩大可点击区域</h2><h3 id="难题-4"><a href="#难题-4" class="headerlink" title="难题"></a>难题</h3><p>其可点击区域（热区）向外扩张往往也可以带来可用性的提升。没有人愿意对一个狭小的按钮尝试点按很多次。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>首先<code>cursor: pointer</code>，然后伪元素。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">button</span> &#123;</div><div class="line"> <span class="attribute">position</span>: relative;</div><div class="line">  <span class="comment">/* [其余样式] */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">top</span>: -<span class="number">10px</span>; <span class="attribute">right</span>: -<span class="number">10px</span>;</div><div class="line"> <span class="attribute">bottom</span>: -<span class="number">10px</span>; <span class="attribute">left</span>: -<span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="31-自定义复选框"><a href="#31-自定义复选框" class="headerlink" title="31. 自定义复选框"></a>31. 自定义复选框</h2><h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>当 <label> 元素与复选框关联之后，也可以起到触发开关的作用。</label></p><p>由于 label 不是复选框那样的替换元素，我们可以为它添加生成性内容（伪元素），并基于复选框的状态来为其设置样式。然后，就可以把真正的复选框隐藏起来（但不能把它从 tab 键切换焦点的队列中完全删除），再把生成性内容美化一番，用来顶替原来的复选框！</p><p>试一试<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"awesome"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"awesome"</span>&gt;</span>Awesome!<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">'\a0'</span>; <span class="comment">/* 不换行空格 */</span></div><div class="line"> <span class="attribute">display</span>: inline-block;</div><div class="line"> <span class="attribute">vertical-align</span>: .<span class="number">2em</span>;</div><div class="line"> <span class="attribute">width</span>: .<span class="number">8em</span>;</div><div class="line"> <span class="attribute">height</span>: .<span class="number">8em</span>;</div><div class="line"> <span class="attribute">margin-right</span>: .<span class="number">2em</span>;</div><div class="line"> <span class="attribute">border-radius</span>: .<span class="number">2em</span>;</div><div class="line"> <span class="attribute">background</span>: silver;</div><div class="line"> <span class="attribute">text-indent</span>: .<span class="number">15em</span>;</div><div class="line"> <span class="attribute">line-height</span>: .<span class="number">65</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">'\2713'</span>;</div><div class="line"> <span class="attribute">background</span>: yellowgreen;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 把原来的复选框以一种不损失可</span></div><div class="line"><span class="comment">访问性的方式隐藏起来  */</span></div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span> &#123;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">clip</span>: <span class="built_in">rect</span>(0,0,0,0);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 聚焦或禁用时改变它的样式 */</span></div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:focus</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> .<span class="number">1em</span> .<span class="number">1em</span> <span class="number">#58a</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:disabled</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">background</span>: gray;</div><div class="line"> <span class="attribute">box-shadow</span>: none;</div><div class="line"> <span class="attribute">color</span>: <span class="number">#555</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/labelinput.png" alt=""></p><h3 id="开关式按钮"><a href="#开关式按钮" class="headerlink" title="开关式按钮"></a>开关式按钮</h3><p>其实只需要把 label 设置为按钮的样式即可，并不需要用到伪元素。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span> &#123;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">clip</span>: <span class="built_in">rect</span>(0,0,0,0);</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span> + <span class="selector-tag">label</span> &#123;</div><div class="line"> <span class="attribute">display</span>: inline-block;</div><div class="line"> <span class="attribute">padding</span>: .<span class="number">3em</span> .<span class="number">5em</span>;</div><div class="line"> <span class="attribute">background</span>: <span class="number">#ccc</span>;</div><div class="line"> <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(#ddd, #bbb);</div><div class="line"> <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(0,0,0,.2);</div><div class="line"> <span class="attribute">border-radius</span>: .<span class="number">3em</span>;</div><div class="line"> <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> white inset;</div><div class="line"> <span class="attribute">text-align</span>: center;</div><div class="line"> <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> white;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span>,</div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:active</span> + <span class="selector-tag">label</span> &#123;</div><div class="line"> <span class="attribute">box-shadow</span>: .<span class="number">05em</span> .<span class="number">1em</span> .<span class="number">2em</span> <span class="built_in">rgba</span>(0,0,0,.6) inset;</div><div class="line"> <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(0,0,0,.3);</div><div class="line"> <span class="attribute">background</span>: <span class="number">#bbb</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="32-通过阴影来弱化背景"><a href="#32-通过阴影来弱化背景" class="headerlink" title="32. 通过阴影来弱化背景"></a>32. 通过阴影来弱化背景</h2><blockquote><p>背景知识：RGBA 颜色</p></blockquote><p>设置一个足够大的<code>box-shadow</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 0 50<span class="selector-tag">vmax</span> <span class="selector-tag">rgba</span>(0,0,0,<span class="selector-class">.8</span>);</div></pre></td></tr></table></figure></p><p>然而没啥用，不能js交互。</p><p>作者推荐有限度地应用这个技巧，比如配合固定定位来使用，或者当页面没有滚动条时再用。</p><h3 id="通过模糊来弱化背景"><a href="#通过模糊来弱化背景" class="headerlink" title="通过模糊来弱化背景"></a>通过模糊来弱化背景</h3><p>mask添加<code>filter</code></p><h2 id="34-滚动提示"><a href="#34-滚动提示" class="headerlink" title="34. 滚动提示"></a>34. 滚动提示</h2><blockquote><p>背景知识：CSS 渐变，background-size</p></blockquote><p>给个网址：</p><p><a href="https://www.w3cplus.com/css3/css-secrets/scrolling-hints.html" target="_blank" rel="noopener">https://www.w3cplus.com/css3/css-secrets/scrolling-hints.html</a></p><h2 id="35-交互式的图片对比控件"><a href="#35-交互式的图片对比控件" class="headerlink" title="35. 交互式的图片对比控件"></a>35. 交互式的图片对比控件</h2><p><a href="https://www.w3cplus.com/css3/css-secrets/interactive-image-comparison.html" target="_blank" rel="noopener">https://www.w3cplus.com/css3/css-secrets/interactive-image-comparison.html</a></p><h1 id="结构与布局"><a href="#结构与布局" class="headerlink" title="结构与布局"></a>结构与布局</h1><h2 id="36-自适应内部元素"><a href="#36-自适应内部元素" class="headerlink" title="36. 自适应内部元素"></a>36. 自适应内部元素</h2><p><code>min-content</code><br>这个关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽的单词、图片或具有固定宽度的盒元素<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">figure</span> &#123;</div><div class="line"> <span class="attribute">max-width</span>: <span class="number">300px</span>;</div><div class="line"> <span class="attribute">max-width</span>: min-content;</div><div class="line"> <span class="attribute">margin</span>: auto;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">figure</span> &gt; <span class="selector-tag">img</span> &#123; <span class="attribute">max-width</span>: inherit; &#125;</div></pre></td></tr></table></figure></p><h2 id="37-精确控制表格列宽"><a href="#37-精确控制表格列宽" class="headerlink" title="37. 精确控制表格列宽"></a>37. 精确控制表格列宽</h2><p>只需：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">table</span> &#123;</div><div class="line"> <span class="attribute">table-layout</span>: fixed;</div><div class="line"> <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="38-根据兄弟元素的数量来设置样式"><a href="#38-根据兄弟元素的数量来设置样式" class="headerlink" title="38. 根据兄弟元素的数量来设置样式"></a>38. 根据兄弟元素的数量来设置样式</h2><h3 id="难题-5"><a href="#难题-5" class="headerlink" title="难题"></a>难题</h3><p>在某些场景下，我们需要根据兄弟元素的总数来为它们设置样式。最常见的场景就是，当一个列表不断延长时，通过隐藏控件或压缩控件等方式来节省屏幕空间，以此提升用户体验。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>利用两次伪类选择。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 定义mixin */</span></div><div class="line">@<span class="keyword">mixin</span> n-items(<span class="variable">$n</span>) &#123;</div><div class="line"> &amp;:first-child:nth-last-child(#&#123;<span class="variable">$n</span>&#125;),</div><div class="line"> &amp;:first-child:nth-last-child(#&#123;<span class="variable">$n</span>&#125;) ~ &amp; &#123;</div><div class="line"> @<span class="keyword">content</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 调用时是这样的： */</span></div><div class="line"><span class="selector-tag">li</span> &#123;</div><div class="line"> @<span class="keyword">include</span> n-items(<span class="number">4</span>) &#123;</div><div class="line"> <span class="comment">/* 属性与值写在这里 */</span></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="根据兄弟元素的数量范围来匹配元素"><a href="#根据兄弟元素的数量范围来匹配元素" class="headerlink" title="根据兄弟元素的数量范围来匹配元素"></a>根据兄弟元素的数量范围来匹配元素</h3><p>变量方式。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:nth-last-child(n+4)</span>,</div><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:nth-last-child(n+4)</span> ~ <span class="selector-tag">li</span> &#123;</div><div class="line"> <span class="comment">/* 当列表至少包含四项时，命中所有列表项 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>假设我们希望在列表包含 2 ～ 6 个列表项时命中所有的列表项，可以<br>这样写：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:nth-last-child(n+2)</span><span class="selector-pseudo">:nth-last-child(-n+6)</span>,</div><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:nth-last-child(n+2)</span><span class="selector-pseudo">:nth-last-child(-n+6)</span> ~ <span class="selector-tag">li</span> &#123;</div><div class="line"> <span class="comment">/* 当列表包含2～6项时，命中所有列表项 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="39-满幅的背景，定宽的内容"><a href="#39-满幅的背景，定宽的内容" class="headerlink" title="39. 满幅的背景，定宽的内容"></a>39. 满幅的背景，定宽的内容</h2><h3 id="难题-6"><a href="#难题-6" class="headerlink" title="难题"></a>难题</h3><p>在过去的几年间，有一种网页设计手法逐渐流行起来，我将它称作背景宽度满幅，内容宽度固定</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>利用算术表达式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line"> <span class="attribute">max-width</span>: <span class="number">900px</span>;</div><div class="line"> <span class="attribute">margin</span>: <span class="number">1em</span> <span class="built_in">calc</span>(50% - 450px);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果我们将长度值应用到父元素的padding上。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">footer</span> &#123;</div><div class="line"> <span class="attribute">max-width</span>: <span class="number">900px</span>;</div><div class="line"> <span class="attribute">padding</span>: <span class="number">1em</span> <span class="built_in">calc</span>(50% - 450px);</div><div class="line"> <span class="attribute">background</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.wrapper</span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 回退机制 */</span></div><div class="line"><span class="selector-tag">footer</span> &#123;</div><div class="line"> <span class="attribute">padding</span>: <span class="number">1em</span>;</div><div class="line"> <span class="attribute">padding</span>: <span class="number">1em</span> <span class="built_in">calc</span>(50% - 450px);</div><div class="line"> <span class="attribute">background</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="40-垂直居中"><a href="#40-垂直居中" class="headerlink" title="40. 垂直居中"></a>40. 垂直居中</h2><h3 id="基于绝对定位的解决方案"><a href="#基于绝对定位的解决方案" class="headerlink" title="基于绝对定位的解决方案"></a>基于绝对定位的解决方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">main</span> &#123;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line"> <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line"> <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于视口单位的解决方案"><a href="#基于视口单位的解决方案" class="headerlink" title="基于视口单位的解决方案"></a>基于视口单位的解决方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">main</span> &#123;</div><div class="line"> <span class="attribute">width</span>: <span class="number">18em</span>;</div><div class="line"> <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">1.5em</span>;</div><div class="line"> <span class="attribute">margin</span>: <span class="number">50vh</span> auto <span class="number">0</span>;</div><div class="line"> <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于-Flexbox-的解决方案"><a href="#基于-Flexbox-的解决方案" class="headerlink" title="基于 Flexbox 的解决方案"></a>基于 Flexbox 的解决方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">main</span> &#123;</div><div class="line"> <span class="attribute">display</span>: flex;</div><div class="line"> <span class="attribute">align-items</span>: center;</div><div class="line"> <span class="attribute">justify-content</span>: center;</div><div class="line"> <span class="attribute">width</span>: <span class="number">18em</span>;</div><div class="line"> <span class="attribute">height</span>: <span class="number">10em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="41-紧贴底部的页脚"><a href="#41-紧贴底部的页脚" class="headerlink" title="41. 紧贴底部的页脚"></a>41. 紧贴底部的页脚</h2><blockquote><p>背景知识：视口相关的长度单位（参见“垂直居中”），calc()</p></blockquote><h3 id="calc-函数"><a href="#calc-函数" class="headerlink" title="calc() 函数"></a>calc() 函数</h3><p>我们可以把 <header> 和 <main> 元素包在一个容器里，然后在算式中就只需要考虑页脚的高度了：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#wrapper</span> &#123;</div><div class="line"> <span class="attribute">min-height</span>: <span class="built_in">calc</span>(100vh - 7em);</div><div class="line">&#125;</div></pre></td></tr></table></figure></main></header></p><h3 id="更灵活的解决方案flex"><a href="#更灵活的解决方案flex" class="headerlink" title="更灵活的解决方案flex"></a>更灵活的解决方案flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line"> <span class="attribute">display</span>: flex;</div><div class="line"> <span class="attribute">flex-flow</span>: column;</div><div class="line"> <span class="attribute">min-height</span>: <span class="number">100vh</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">main</span> &#123; <span class="attribute">flex</span>: <span class="number">1</span>; &#125;</div></pre></td></tr></table></figure><p>这 个 <code>flex</code> 属性实际上是<code>flex-grow</code>、<code>flex-shrink</code> 和<code>flex-basis</code> 的简写语法。 任何元素只要设置了一个大于 0 的<code>flex</code> 值，就将获得可伸缩的特性；<code>flex</code> 的值负责控制多个可伸缩元素之间的尺寸分配比例。举例来说，在我们眼前的这个例子中， 如 果 <code>&lt;main&gt;</code> 是 flex: 2 而<code>&lt;footer&gt;</code> 是 flex: 1，那么内容区块的高度将是页脚高度的两倍。如果把它们的值从 2 和 1 改为 4 和 2，结果也是一样的，因为真正起作用的是它们的数值比例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要总结了书里的字体排版，用户体验，结构与布局。字体排版由于介绍英文比较多，这里就直接跳过了几个段落。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://hddhyq.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://hddhyq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css揭秘总结(二)</title>
    <link href="https://hddhyq.github.io/2018/01/02/css%E6%8F%AD%E7%A7%98%E6%80%BB%E7%BB%93%E4%BA%8C/"/>
    <id>https://hddhyq.github.io/2018/01/02/css揭秘总结二/</id>
    <published>2018-01-02T12:49:13.000Z</published>
    <updated>2018-07-08T04:25:55.514Z</updated>
    
    <content type="html"><![CDATA[<p>主要总结了下CSS３的形状，视觉效果。<br><a id="more"></a></p><h1 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h1><h2 id="9-自适应的椭圆"><a href="#9-自适应的椭圆" class="headerlink" title="9. 自适应的椭圆"></a>9. 自适应的椭圆</h2><blockquote><p>背景知识：<code>border-radius</code>属性的基本用法</p></blockquote><h3 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h3><p>一个圆很容易生成，设置一个足够大的<code>border-radius</code>就可以了,如果我们希望一个自适应的椭圆呢，根据内容自动调整并适应。如果它的宽高相等，就显示为一个圆；如果宽高不等，就显示为一个椭圆。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>border-radius，可以单独指定水平和垂直半径，只要用一个斜杠分开。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">border-radius</span>: 50% 50%;</div><div class="line"><span class="comment">/* 简写 */</span></div><div class="line"><span class="selector-tag">border-radius</span>: 50%;</div></pre></td></tr></table></figure></p><h3 id="其他椭圆"><a href="#其他椭圆" class="headerlink" title="其他椭圆"></a>其他椭圆</h3><p>我们可以为所有四个角提供完全不同的水平和垂直半径，方法是在斜杠前指定 1~4 个值，在斜杠后指定另外 1~4 个值。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 半椭圆 */</span></div><div class="line">border-radius: 50% / 100% 100% 0 0;</div><div class="line"><span class="comment">/* 沿纵轴劈开的半椭圆 */</span></div><div class="line">border-radius: 100% 0 0 100% / 50%;</div><div class="line"><span class="comment">/* 四分之一椭圆 */</span></div><div class="line"><span class="selector-tag">border-radius</span>: 100% 0 0 0;</div></pre></td></tr></table></figure></p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/半椭圆.png" alt=""> <img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/四分之一椭圆.png" alt=""> <img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/纵轴半椭圆.png" alt=""></p><h2 id="10-平行四边形"><a href="#10-平行四边形" class="headerlink" title="10. 平行四边形"></a>10. 平行四边形</h2><blockquote><p>背景知识：基本的CSS 变形</p></blockquote><h3 id="难题-1"><a href="#难题-1" class="headerlink" title="难题"></a>难题</h3><p>平行四边形可以通过<code>skew()</code>的变形属性来对这个矩形进行斜向拉伸，这导致它的内容也发生了斜向变形，这很不好看，而且难读，有没有办法只让容器的形状倾斜，而保持其内容不变呢？</p><h3 id="嵌套元素方案"><a href="#嵌套元素方案" class="headerlink" title="嵌套元素方案"></a>嵌套元素方案</h3><p>我们可以对内容再应用一次反向的 <code>skew()</code> 变形，从而抵消容器的变形效果, 缺点：需要添加一层层额外的 HTML 元素来包裹内容。</p><h3 id="伪元素方案"><a href="#伪元素方案" class="headerlink" title="伪元素方案"></a>伪元素方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.button</span> &#123;</div><div class="line"> <span class="attribute">position</span>: relative;</div><div class="line"> <span class="comment">/* 其他的文字颜色、内边距等样式…… */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.button</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">''</span>; <span class="comment">/* 用伪元素来生成一个矩形 */</span></div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line"> <span class="attribute">z-index</span>: -<span class="number">1</span>;</div><div class="line"> <span class="attribute">background</span>: <span class="number">#58a</span>;</div><div class="line"> <span class="attribute">transform</span>: <span class="built_in">skew</span>(45deg);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>适用于其他任何变形样式，当我们想变形一个元素而不想变形它的内容时就可以用到它</p><h2 id="11-菱形图片"><a href="#11-菱形图片" class="headerlink" title="11. 菱形图片"></a>11. 菱形图片</h2><blockquote><p>背景知识: CSS 变形，“平行四边形”</p></blockquote><h3 id="难题-2"><a href="#难题-2" class="headerlink" title="难题"></a>难题</h3><p>在视觉设计中，把图片裁切为菱形是一种常见的设计手法，但在 <code>CSS</code>中还没有一种简单直观的方法来实现它。事实上，直到最近，这种效果才基本成为可能。当网页设计师想要实现这种设计风格时，他们通常不希望在图像处理软件中预先把图片裁好。显然不用说你也知道，这个方法的可维护性并不好。如果未来有人想修改图片风格，将很难增加其他效果，而且最终往往会搞得一团糟。</p><h3 id="基于变形的方案"><a href="#基于变形的方案" class="headerlink" title="基于变形的方案"></a>基于变形的方案</h3><p>主要的思路与前一篇攻略“平行四边形”中讨论的第一个解决方案一致：需要把图片用一个 <div> 包裹起来，然后对其应用相反的 <code>rotate()</code>变形样式，这个方法不是推荐的方法。</div></p><h3 id="裁切路径方案"><a href="#裁切路径方案" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h3><p>它的主要思路是使用 <code>clip-path</code> 属性。这个特性也是从 <code>SVG</code> 那里借鉴而来，已经可以应用在 <code>HTML</code> 元素上了（至少对于支持的浏览器来说是这样的）。</p><p>我们将会使用 polygon()（多边形）函数来指定一个菱形。实际上，它允许我们用一系列（以逗号分隔的）坐标点来指定任意的多边形。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span> &#123;</div><div class="line"> <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(50% 0, 100% 50%,</div><div class="line"> 50% 100%, 0 50%);</div><div class="line"> <span class="attribute">transition</span>: <span class="number">1s</span> clip-path;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line"> <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(0 0, 100% 0,</div><div class="line"> 100% 100%, 0 100%);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="12-切角效果"><a href="#12-切角效果" class="headerlink" title="12. 切角效果"></a>12. 切角效果</h2><blockquote><p>背景知识: CSS 渐变，background-size，“条纹背景”</p></blockquote><h3 id="难题-3"><a href="#难题-3" class="headerlink" title="难题"></a>难题</h3><p>最常见的形态是把元素的一个或多个角切成 45°的缺口（也称作斜面切角）。</p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/切角.png" alt=""></p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>第一种方案来自于无所不能的 CSS 渐变。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-id">#58a</span>;</div><div class="line"><span class="selector-tag">background</span>:</div><div class="line"> <span class="selector-tag">linear-gradient</span>(135<span class="selector-tag">deg</span>, <span class="selector-tag">transparent</span> 15<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 0)</div><div class="line"> <span class="selector-tag">top</span> <span class="selector-tag">left</span>,</div><div class="line"> <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">-135deg</span>, <span class="selector-tag">transparent</span> 15<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 0)</div><div class="line"> <span class="selector-tag">top</span> <span class="selector-tag">right</span>,</div><div class="line"> <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">-45deg</span>, <span class="selector-tag">transparent</span> 15<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 0)</div><div class="line"> <span class="selector-tag">bottom</span> <span class="selector-tag">right</span>,</div><div class="line"> <span class="selector-tag">linear-gradient</span>(45<span class="selector-tag">deg</span>, <span class="selector-tag">transparent</span> 15<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 0)</div><div class="line"> <span class="selector-tag">bottom</span> <span class="selector-tag">left</span>;</div><div class="line"><span class="selector-tag">background-size</span>: 50% 50%; </div><div class="line"><span class="comment">/* 如果不设置的话，背景会相互覆盖 */</span></div><div class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>;</div><div class="line"><span class="comment">/* 如果不设置，每层渐变图案各自平铺了两次 */</span></div></pre></td></tr></table></figure></p><p>现在我们会得到，切了四个角的div。不过可维护性并不高。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">mixin</span> beveled-corners(<span class="variable">$bg</span>,</div><div class="line"> <span class="variable">$tl</span>:<span class="number">0</span>, <span class="variable">$tr</span>:<span class="variable">$tl</span>, <span class="variable">$br</span>:<span class="variable">$tl</span>, <span class="variable">$bl</span>:<span class="variable">$tr</span>) &#123;</div><div class="line"> <span class="attribute">background</span>: <span class="variable">$bg</span>;</div><div class="line"> <span class="attribute">background</span>:</div><div class="line"> linear-gradient(<span class="number">135deg</span>, transparent <span class="variable">$tl</span>, <span class="variable">$bg</span> <span class="number">0</span>)</div><div class="line"> top left,</div><div class="line"> linear-gradient(<span class="number">225deg</span>, transparent <span class="variable">$tr</span>, <span class="variable">$bg</span> <span class="number">0</span>)</div><div class="line"> top right,</div><div class="line"> linear-gradient(-<span class="number">45deg</span>, transparent <span class="variable">$br</span>, <span class="variable">$bg</span> <span class="number">0</span>)</div><div class="line"> bottom right,</div><div class="line"> linear-gradient(<span class="number">45deg</span>, transparent <span class="variable">$bl</span>, <span class="variable">$bg</span> <span class="number">0</span>)</div><div class="line"> bottom left;</div><div class="line"> <span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">50%</span>;</div><div class="line"> <span class="attribute">background-repeat</span>: no-repeat;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用 传入 2~5 个参数：</span></div><div class="line">@<span class="keyword">include</span> beveled-corners(<span class="number">#58a</span>, 15px, 5px);</div></pre></td></tr></table></figure><h3 id="弧形切角"><a href="#弧形切角" class="headerlink" title="弧形切角"></a>弧形切角</h3><p>很多人也把这种效果称为“内凹圆角”，因为它看起来就像是圆角的反向版本。用径向渐变来替代上述线性渐变：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-id">#58a</span>;</div><div class="line"><span class="selector-tag">background</span>:</div><div class="line"> <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">at</span> <span class="selector-tag">top</span> <span class="selector-tag">left</span>,</div><div class="line"> <span class="selector-tag">transparent</span> 15<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 0) <span class="selector-tag">top</span> <span class="selector-tag">left</span>,</div><div class="line"> <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">at</span> <span class="selector-tag">top</span> <span class="selector-tag">right</span>,</div><div class="line"> <span class="selector-tag">transparent</span> 15<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 0) <span class="selector-tag">top</span> <span class="selector-tag">right</span>,</div><div class="line"> <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">at</span> <span class="selector-tag">bottom</span> <span class="selector-tag">right</span>,</div><div class="line"> <span class="selector-tag">transparent</span> 15<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 0) <span class="selector-tag">bottom</span> <span class="selector-tag">right</span>,</div><div class="line"> <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">at</span> <span class="selector-tag">bottom</span> <span class="selector-tag">left</span>,</div><div class="line"> <span class="selector-tag">transparent</span> 15<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 0) <span class="selector-tag">bottom</span> <span class="selector-tag">left</span>;</div><div class="line"><span class="selector-tag">background-size</span>: 50% 50%;</div><div class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>;</div></pre></td></tr></table></figure></p><h3 id="内联-SVG-与-border-image-方案"><a href="#内联-SVG-与-border-image-方案" class="headerlink" title="内联 SVG 与 border-image 方案"></a>内联 SVG 与 border-image 方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">border</span>: 20<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">transparent</span>;</div><div class="line">border-image: 1 url('data:image/svg+xml,\</div><div class="line"> &lt;svg xmlns="http://www.w3.org/2000/svg"\</div><div class="line"> width="3" height="3" fill="%2358a"&gt;\</div><div class="line"> &lt;polygon points="0,1 1,0 2,0 3,1 3,2 2,3 1,3 0,2"/&gt;\</div><div class="line"> &lt;/svg&gt;');</div><div class="line"><span class="selector-tag">background</span>: <span class="selector-id">#58a</span>;</div><div class="line"><span class="selector-tag">background-clip</span>: <span class="selector-tag">padding-box</span>;</div></pre></td></tr></table></figure><h3 id="裁切路径方案-1"><a href="#裁切路径方案-1" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h3><p>利用<code>clip-path</code>属性。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-id">#58a</span>;</div><div class="line"><span class="selector-tag">clip-path</span>: <span class="selector-tag">polygon</span>(</div><div class="line"> 20<span class="selector-tag">px</span> 0, <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 20<span class="selector-tag">px</span>) 0, 100% 20<span class="selector-tag">px</span>,</div><div class="line"> 100% <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 20<span class="selector-tag">px</span>), <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 20<span class="selector-tag">px</span>) 100%,</div><div class="line"> 20<span class="selector-tag">px</span> 100%, 0 <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 20<span class="selector-tag">px</span>), 0 20<span class="selector-tag">px</span></div><div class="line">);</div></pre></td></tr></table></figure></p><h3 id="补充多边形裁剪"><a href="#补充多边形裁剪" class="headerlink" title="补充多边形裁剪"></a>补充多边形裁剪</h3><p><a href="https://www.w3cplus.com/preprocessor/creat-css-polygon-wiht-border-and-clip-path-property.html" target="_blank" rel="noopener">https://www.w3cplus.com/preprocessor/creat-css-polygon-wiht-border-and-clip-path-property.html</a></p><h2 id="13-梯形标签页"><a href="#13-梯形标签页" class="headerlink" title="13. 梯形标签页"></a>13. 梯形标签页</h2><blockquote><p>背景知识: 基本的 3D 变形，“平行四边形”</p></blockquote><h3 id="难题-4"><a href="#难题-4" class="headerlink" title="难题"></a>难题</h3><p>一直以来，梯形都是众所周知难以用 CSS 生成的形状，尽管它也十分常用，尤其是对于标签页来说。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>利用 CSS 中用 3D 旋转来模拟出这个效果<code>transform: perspective(.5em) rotateX(5deg);</code>。</p><p>对元素使用了 3D变形之后，其内部的变形效应是“不可逆转”的, 这里我们像上一节利用伪类就好了。而给元素应用变形效果会让这个元素以它自身的中心线为轴进行空间上的旋转。所以我们需要设置<code>transform-origin</code>属性。<code>transform-origin:bottom;</code>，当它在 3D 空间中旋转时，可以把它的底边固定住。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">nav</span> &gt; <span class="selector-tag">a</span> &#123;</div><div class="line"> <span class="attribute">position</span>: relative;</div><div class="line"> <span class="attribute">display</span>: inline-block;</div><div class="line"> <span class="attribute">padding</span>: .<span class="number">3em</span> <span class="number">1em</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">nav</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line"> <span class="attribute">z-index</span>: -<span class="number">1</span>;</div><div class="line"> <span class="attribute">background</span>: <span class="number">#ccc</span>;</div><div class="line"> <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(</div><div class="line"> hsla(0,0%,100%,.6),</div><div class="line"> <span class="built_in">hsla</span>(0,0%,100%,0));</div><div class="line"> <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(0,0,0,.4);</div><div class="line"> <span class="attribute">border-bottom</span>: none;</div><div class="line"> <span class="attribute">border-radius</span>: .<span class="number">5em</span> .<span class="number">5em</span> <span class="number">0</span> <span class="number">0</span>;</div><div class="line"> <span class="attribute">box-shadow</span>: <span class="number">0</span> .<span class="number">15em</span> white inset;</div><div class="line"> <span class="attribute">transform</span>: <span class="built_in">perspective</span>(.5em) <span class="built_in">rotateX</span>(5deg);</div><div class="line"> <span class="attribute">transform-origin</span>: bottom;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="14-简单的饼图"><a href="#14-简单的饼图" class="headerlink" title="14. 简单的饼图"></a>14. 简单的饼图</h2><blockquote><p>背景知识: CSS 渐变，基本的 SVG，CSS 动画，“条纹背景”，“自适应的椭圆”</p></blockquote><h3 id="难题-5"><a href="#难题-5" class="headerlink" title="难题"></a>难题</h3><p>饼图在网页中的运用极为普遍，比如简单的统计图表、进度指示器、定时器等。</p><h3 id="基于-transform-的解决方案"><a href="#基于-transform-的解决方案" class="headerlink" title="基于 transform 的解决方案"></a>基于 transform 的解决方案</h3><p>简单来说就是三个遮罩层的互相重叠，这里直接放代码。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.pie</span> &#123;</div><div class="line"> <span class="attribute">position</span>: relative;</div><div class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line"> <span class="attribute">line-height</span>: <span class="number">100px</span>;</div><div class="line"> <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line"> <span class="attribute">background</span>: yellowgreen;</div><div class="line"> <span class="attribute">background-image</span>:</div><div class="line"> <span class="built_in">linear-gradient</span>(to right, transparent 50%, #655 0);</div><div class="line"> <span class="attribute">color</span>: transparent;</div><div class="line"> <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> spin &#123;</div><div class="line"> <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(.5turn); &#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> bg &#123;</div><div class="line"> 50% &#123; <span class="attribute">background</span>: <span class="number">#655</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.pie</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line"> <span class="attribute">width</span>: <span class="number">50%</span>; <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line"> <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">100%</span> <span class="number">100%</span> <span class="number">0</span> / <span class="number">50%</span>;</div><div class="line"> <span class="attribute">background-color</span>: inherit;</div><div class="line"> <span class="attribute">transform-origin</span>: left;</div><div class="line"> <span class="attribute">animation</span>: spin <span class="number">50s</span> linear infinite,</div><div class="line"> bg <span class="number">100s</span> step-end infinite;</div><div class="line"> <span class="attribute">animation-play-state</span>: paused;</div><div class="line"> <span class="attribute">animation-delay</span>: inherit;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="SVG-解决方案"><a href="#SVG-解决方案" class="headerlink" title="SVG 解决方案"></a>SVG 解决方案</h3><p>一个圆形：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">r</span>=<span class="string">"30"</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure></p><p>基本样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">circle</span> &#123;</div><div class="line"> <span class="attribute">fill</span>: yellowgreen;</div><div class="line"> <span class="attribute">stroke</span>: <span class="number">#655</span>; </div><div class="line"> <span class="comment">/* stroke: 描边颜色 */</span></div><div class="line"> <span class="attribute">stroke-width</span>: <span class="number">30</span>;</div><div class="line"> <span class="comment">/* stroke-width：描边宽度 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里我们还需要了解一个属性<code>stroke-dasharray</code>，它是为虚线描边而准备的。<code>stroke-dasharray</code>，第一个参数是线段长度，第二个是间隙长度。当我们把这个虚线描边的线段长度指定为 0，并且把虚线间隙的长度设置为等于或大于整个圆周的长度时，答案就会浮出水面了。（这里做个简单的计算，圆形的周长 C = 2πr，因此在这里C= 2π × 30 ≈ 189。）</p><p>这里直接放出优化版本。</p><p>我们可以给这个圆形指定一个特定的半径，从而让它的周长无限接近 100，这样就可以直接把比率的百分比值指定为 <code>strokedasharray</code>的长度，不需要做任何计算了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">"0 0 32 32"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">circle</span> <span class="attr">r</span>=<span class="string">"16"</span> <span class="attr">cx</span>=<span class="string">"16"</span> <span class="attr">cy</span>=<span class="string">"16"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">svg</span> &#123;</div><div class="line"> <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line"> <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-90deg);</div><div class="line"> <span class="attribute">background</span>: yellowgreen;</div><div class="line"> <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">circle</span> &#123;</div><div class="line"> <span class="attribute">fill</span>: yellowgreen;</div><div class="line"> <span class="attribute">stroke</span>: <span class="number">#655</span>;</div><div class="line"> <span class="attribute">stroke-width</span>: <span class="number">32</span>;</div><div class="line"> <span class="attribute">stroke-dasharray</span>: <span class="number">38</span> <span class="number">100</span>; <span class="comment">/* 可得到比率为38%的扇区 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h1><h2 id="15-单侧投影"><a href="#15-单侧投影" class="headerlink" title="15. 单侧投影"></a>15. 单侧投影</h2><h3 id="难题-6"><a href="#难题-6" class="headerlink" title="难题"></a>难题</h3><p>如何只在元素的一侧（偶尔是两侧）设置投影。</p><h3 id="单侧投影"><a href="#单侧投影" class="headerlink" title="单侧投影"></a>单侧投影</h3><p><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/box_shadow.png" alt=""></p><p>上图演示了投影生成的过程。</p><p>最终的解决方案来自 <code>box-shadow</code> 鲜为人知的第四个长度参数, 这是我们需要了解的。这个参数会根据你指定的值去扩大或（当指定负值时）缩小投影的尺寸。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 5<span class="selector-tag">px</span> 4<span class="selector-tag">px</span> <span class="selector-tag">-4px</span> <span class="selector-tag">black</span>;</div></pre></td></tr></table></figure><h3 id="邻边投影"><a href="#邻边投影" class="headerlink" title="邻边投影"></a>邻边投影</h3><p>一层藏起来，另一侧自然漏出。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 3<span class="selector-tag">px</span> 3<span class="selector-tag">px</span> 6<span class="selector-tag">px</span> <span class="selector-tag">-3px</span> <span class="selector-tag">black</span>;</div></pre></td></tr></table></figure></p><h3 id="双侧投影"><a href="#双侧投影" class="headerlink" title="双侧投影"></a>双侧投影</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 5<span class="selector-tag">px</span> 0 5<span class="selector-tag">px</span> <span class="selector-tag">-5px</span> <span class="selector-tag">black</span>,</div><div class="line">            <span class="selector-tag">-5px</span> 0 5<span class="selector-tag">px</span> <span class="selector-tag">-5px</span> <span class="selector-tag">black</span>;</div></pre></td></tr></table></figure><h2 id="16-不规则投影"><a href="#16-不规则投影" class="headerlink" title="16. 不规则投影"></a>16. 不规则投影</h2><blockquote><p>背景知识: box-shadow</p></blockquote><h3 id="难题-7"><a href="#难题-7" class="headerlink" title="难题"></a>难题</h3><p>当我们想给一个矩形或其他能用 border-radius 生成的形状（在“自适应的椭圆”一节中可以看到一些示例）加投影时，box-shadow 的表现都堪称完美。但是，当元素添加了一些伪元素或半透明的装饰之后，它就有些力不从心了，因为 border-radius 会无耻地忽视透明部分。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>滤镜效果规范（<a href="http://w3.org/TR/filter-effects）为这个问题提供了一个解决方案。`filter`就是我们需要的属性，我们甚至可以用多个滤镜。" target="_blank" rel="noopener">http://w3.org/TR/filter-effects）为这个问题提供了一个解决方案。`filter`就是我们需要的属性，我们甚至可以用多个滤镜。</a></p><p>drop-shadow() 滤镜可接受的参数基本上跟 box-shadow 属性是一样的，不包括 inset 关键字，也不支持逗号分割的多层投影语法。 </p><p>我们需要知道的就是，任何非透明的部分都会被一视同仁地打上投影。小心文本的两层阴影。</p><h2 id="17-染色效果"><a href="#17-染色效果" class="headerlink" title="17. 染色效果"></a>17. 染色效果</h2><blockquote><p>背景知识: HSL 色彩模型，background-size</p></blockquote><h3 id="难题-8"><a href="#难题-8" class="headerlink" title="难题"></a>难题</h3><p>为一幅灰度图片（或是被转换为灰度模式的彩色图片）增加染色效果（color tint），是一种流行且优雅的方式，可以给一系列风格迥异的照片带来视觉上的一致性。</p><p>常见的解决方法就是给图层上面添加一层半透明的实色背景，但减少了图片的对比度。</p><h3 id="基于滤镜的方案"><a href="#基于滤镜的方案" class="headerlink" title="基于滤镜的方案"></a>基于滤镜的方案</h3><p>多种滤镜组合。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter</a></p><h3 id="基于混合模式的方案"><a href="#基于混合模式的方案" class="headerlink" title="基于混合模式的方案"></a>基于混合模式的方案</h3><p>“混合模式”控制了上层元素的颜色与下层颜色进行混合的方式。要对一个元素设置混合模式，有两个属性可以派上用场：<code>mix-blendmode</code>可以为整个元素设置混合模式，<code>background-blend-mode</code> 可以为每层背景单独指定混合模式。</p><p>缺点：</p><ul><li>图片的尺寸需要在 CSS 代码中写死。</li><li>在语义上，这个元素并不是一张图片，因此并不会被读屏器之类的设备读出来。</li></ul><h2 id="18-毛玻璃效果"><a href="#18-毛玻璃效果" class="headerlink" title="18. 毛玻璃效果"></a>18. 毛玻璃效果</h2><blockquote><p>背景知识: RGBA/HSLA 颜色</p></blockquote><h3 id="难题-9"><a href="#难题-9" class="headerlink" title="难题"></a>难题</h3><p>半透明颜色最初的使用场景之一就是作为背景。将其叠放在照片类或其他花哨的背层之上，可以减少对比度，确保文本的可读性。这种效果确实很有视觉冲击力，但仍然可能导致文字很难阅读。</p><p><img src="http://p1aqu3lsq.bkt.clouddn.com//csssercets/transparentPic1.png" alt=""> </p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span>, <span class="selector-tag">main</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"tiger.jpg"</span>) <span class="number">0</span> / cover fixed;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">main</span> &#123;</div><div class="line"> <span class="attribute">position</span>: relative;</div><div class="line"> <span class="attribute">background</span>: <span class="built_in">hsla</span>(0,0%,100%,.3);</div><div class="line"> <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">main</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line"> <span class="attribute">filter</span>: <span class="built_in">blur</span>(20px);</div><div class="line"> <span class="attribute">margin</span>: -<span class="number">30px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>问题：</p><ul><li>伪元素现在就覆盖在内容元素之上。可以用 z-index: -1; 来修正这个问题。</li><li><code>blur</code>模糊效果在中心区域看起来非常完美，但在接近边缘处会逐渐消退。为了补偿这种情况，我们需要让伪元素相对其宿主元素的尺寸再向外扩大至少 20px（即它的模糊半径）。这里取30px。</li><li>上一个解决方法会导致一圈模糊效果超出了容器。只要对 main 元素应用overflow: hidden;，就可以把多余的模糊区域裁切掉了。</li></ul><p>最终得到上述代码。</p><h2 id="19-折角效果"><a href="#19-折角效果" class="headerlink" title="19. 折角效果"></a>19. 折角效果</h2><blockquote><p>背景知识: CSS 变形，CSS 渐变，“切角效果“</p></blockquote><h3 id="难题-10"><a href="#难题-10" class="headerlink" title="难题"></a>难题</h3><p>把元素的一个角（通常是右上角或右下角）处理为类似折角的形状，再配上或多或少的拟物样式。</p><h3 id="45°折角的解决方案"><a href="#45°折角的解决方案" class="headerlink" title="45°折角的解决方案"></a>45°折角的解决方案</h3><p>我们会从一个右上角具有斜面切角的元素开始，这个切角是由“切角效果”一节中的渐变方案实现的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-id">#58a</span>; <span class="comment">/* 回退样式 */</span></div><div class="line"><span class="selector-tag">background</span>:</div><div class="line"> <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">-135deg</span>, <span class="selector-tag">transparent</span> 2<span class="selector-tag">em</span>, <span class="selector-id">#58a</span> 0);</div></pre></td></tr></table></figure></p><p>接下来所需要做的就是增加一个暗色的三角形来实现翻折效果。注意长度斜的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-id">#58a</span>; <span class="comment">/* 回退样式 */</span></div><div class="line"><span class="selector-tag">background</span>:</div><div class="line"> <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">left</span> <span class="selector-tag">bottom</span>,</div><div class="line"> <span class="selector-tag">transparent</span> 50%, <span class="selector-tag">rgba</span>(0,0,0,<span class="selector-class">.4</span>) 0)</div><div class="line"> no-repeat 100% 0 / 2em 2em,</div><div class="line"> <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">-135deg</span>,</div><div class="line"> <span class="selector-tag">transparent</span> 1<span class="selector-class">.5em</span>, <span class="selector-id">#58a</span> 0);</div></pre></td></tr></table></figure></p><h3 id="其他角度的解决方案"><a href="#其他角度的解决方案" class="headerlink" title="其他角度的解决方案"></a>其他角度的解决方案</h3><p>直接放<code>mixin</code><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">mixin</span> folded-corner(<span class="variable">$background</span>, <span class="variable">$size</span>,</div><div class="line"> <span class="variable">$angle</span>: 30deg) &#123;</div><div class="line"><span class="attribute">position</span>: relative;</div><div class="line"><span class="attribute">background</span>: <span class="variable">$background</span>; <span class="comment">/* 回退样式 */</span></div><div class="line"><span class="attribute">background</span>:</div><div class="line"> linear-gradient(<span class="variable">$angle</span> - <span class="number">180deg</span>,</div><div class="line"> transparent <span class="variable">$size</span>, <span class="variable">$background</span> <span class="number">0</span>);</div><div class="line"><span class="attribute">border-radius</span>: .<span class="number">5em</span>;</div><div class="line"><span class="variable">$x</span>: <span class="variable">$size</span> / sin(<span class="variable">$angle</span>);</div><div class="line"><span class="variable">$y</span>: <span class="variable">$size</span> / cos(<span class="variable">$angle</span>);</div><div class="line">&amp;::before &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line"> <span class="attribute">background</span>: linear-gradient(to left bottom,</div><div class="line"> transparent <span class="number">50%</span>, rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>) <span class="number">0</span>,</div><div class="line"> rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">4</span>)) <span class="number">100%</span> <span class="number">0</span> no-repeat;</div><div class="line"> <span class="attribute">width</span>: <span class="variable">$y</span>; <span class="attribute">height</span>: <span class="variable">$x</span>;</div><div class="line"> <span class="attribute">transform</span>: translateY(<span class="variable">$y</span> - <span class="variable">$x</span>)</div><div class="line"> rotate(<span class="number">2</span>*<span class="variable">$angle</span> - <span class="number">90deg</span>);</div><div class="line"> <span class="attribute">transform-origin</span>: bottom right;</div><div class="line"> <span class="attribute">border-bottom-left-radius</span>: inherit;</div><div class="line"> <span class="attribute">box-shadow</span>: -.<span class="number">2em</span> .<span class="number">2em</span> .<span class="number">3em</span> -.<span class="number">1em</span> rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 当调用时... */</span></div><div class="line"><span class="selector-class">.note</span> &#123;</div><div class="line"> @<span class="keyword">include</span> folded-corner(<span class="number">#58a</span>, 2em, 40deg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要总结了下CSS３的形状，视觉效果。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://hddhyq.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://hddhyq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css揭秘总结(－)</title>
    <link href="https://hddhyq.github.io/2017/12/31/css%E6%8F%AD%E7%A7%98%E6%80%BB%E7%BB%93%EF%BC%8D/"/>
    <id>https://hddhyq.github.io/2017/12/31/css揭秘总结－/</id>
    <published>2017-12-31T05:20:41.000Z</published>
    <updated>2018-07-08T04:25:55.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这个总结，基本主要记录作者给的解决方法和主要的code。思路的确很重要。共有47个小难题。<br><a id="more"></a></p><h2 id="CSS3的诸多模块"><a href="#CSS3的诸多模块" class="headerlink" title="CSS3的诸多模块"></a>CSS3的诸多模块</h2><ul><li>CSS2(原有模块)=&gt;CSS3<ul><li>CSS语法(<a href="http://w3.org/TR/css-syntax-3" target="_blank" rel="noopener">http://w3.org/TR/css-syntax-3</a>)</li><li>CSS层叠与继承(<a href="http://w3.org/TR/css-cascade-3" target="_blank" rel="noopener">http://w3.org/TR/css-cascade-3</a>)</li><li>CSS颜色(<a href="http://w3.org/TR/css3-color" target="_blank" rel="noopener">http://w3.org/TR/css3-color</a>)</li><li>选择符(<a href="http://w3.org/TR/selectors" target="_blank" rel="noopener">http://w3.org/TR/selectors</a>)</li><li>CSS背景与边框(<a href="http://w3.org/TR/css3-background" target="_blank" rel="noopener">http://w3.org/TR/css3-background</a>)</li><li>CSS值与单位(<a href="http://w3.org/TR/css-values-3" target="_blank" rel="noopener">http://w3.org/TR/css-values-3</a>)</li><li>CSS文本排版(<a href="http://w3.org/TR/css-text-3" target="_blank" rel="noopener">http://w3.org/TR/css-text-3</a>)</li><li>CSS文本装饰效果(<a href="http://w3.org/TR/css-text-decor-3" target="_blank" rel="noopener">http://w3.org/TR/css-text-decor-3</a>)</li><li>CSS字体(<a href="http://w3.org/TR/css3-fonts" target="_blank" rel="noopener">http://w3.org/TR/css3-fonts</a>)</li><li>CSS基本UI特性(<a href="http://w3.org/TR/css3-ui" target="_blank" rel="noopener">http://w3.org/TR/css3-ui</a>)</li></ul></li><li>CSS3新增<ul><li>CSS变形(<a href="http://w3.org/TR/css-transforms-1" target="_blank" rel="noopener">http://w3.org/TR/css-transforms-1</a>)</li><li>图像混合效果(<a href="http://w3.org/TR/compositing-1" target="_blank" rel="noopener">http://w3.org/TR/compositing-1</a>)</li><li>滤镜效果(<a href="http://w3.org/TR/filter-effects-1" target="_blank" rel="noopener">http://w3.org/TR/filter-effects-1</a>)</li><li>CSS遮罩(<a href="http://w3.org/TR/css-masking-1" target="_blank" rel="noopener">http://w3.org/TR/css-masking-1</a>)</li><li>CSS伸缩盒布局(<a href="http://w3.org/TR/css-flexbox-1" target="_blank" rel="noopener">http://w3.org/TR/css-flexbox-1</a>)</li><li>CSS网格布局(<a href="http://w3.org/TR/css-grid-1" target="_blank" rel="noopener">http://w3.org/TR/css-grid-1</a>)</li></ul></li></ul><h2 id="浏览器前缀的由来"><a href="#浏览器前缀的由来" class="headerlink" title="浏览器前缀的由来"></a>浏览器前缀的由来</h2><p>刚开始学习css的时候，只是看教学的说需要添加前缀，可是前缀的由来记得不是很清楚。其实，在一条规范正式添加到规范中，会有一些实验性的特性。网页开发者可以根据浏览器给的前缀自由的添加相关特性，并将试用结果返还给工作组。结果开发者发现，这些有了前缀的特性能轻易的实现以前需要大费周折所实现的效果，所以，这些特性就被滥用。后来发现只写出当前适用的新特性时，还需要时不时回来打补丁，后来干脆将所有可能的浏览器前缀添加上去变成：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-moz-border-radius</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">-ms-border-radius</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">-o-border-radius</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">-webkit-border-radius</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">border-radius</span>: 10<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure></p><p>后来出现的预处理器成功解决了这些问题，不用写这么丑的代码了。</p><h2 id="CSS编码技巧"><a href="#CSS编码技巧" class="headerlink" title="CSS编码技巧"></a>CSS编码技巧</h2><h3 id="尽量减少代码重复"><a href="#尽量减少代码重复" class="headerlink" title="尽量减少代码重复"></a>尽量减少代码重复</h3><p>在实践中，代码可维护性的最大要素是尽量减少改动时要编辑的地方。最简单的例如字体，用<code>em</code>表示，<code>line-height</code>与字体相关等。所以我们需要审视到底哪些效果是需要动态的变化的，哪一些又是固定不变的。</p><ol><li>代码易维护 vs 代码量少</li></ol><p>有时候，代码易维护和代码量少不可兼得。如下：我们为一个元素添加一道10px宽的边框，但左侧不加边框。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 方法一 */</span></div><div class="line"><span class="selector-tag">border-width</span>: 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 0; </div><div class="line"><span class="comment">/* 方法二 */</span></div><div class="line"><span class="selector-tag">border-width</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">border-left-width</span>: 0;</div></pre></td></tr></table></figure></p><p>方法一的代码只需要一条声明就能完成，可日后我们需要改动变宽的宽度的时候需要同时改动三个地方。如果如方法二，改动起来就容易多了。</p><ol start="2"><li>currentColor</li></ol><p>这个值是CSS中有史以来的第一个变量，很多属性，例如<code>border-color</code>、<code>outline-color</code>等的初始值就是这个，它自动从文本获得颜色。</p><ol start="3"><li>继承<code>inherit</code></li></ol><p>大多数人知道<code>inherit</code>这个关键字，但很容易遗忘。<code>inherit</code>可以用在任何CSS属性中，而且他还总是绑定到父元素的计算值，对于伪元素来说则会取得生成该伪元素的宿主元素。</p><h3 id="相信你的眼睛，而不是数字"><a href="#相信你的眼睛，而不是数字" class="headerlink" title="相信你的眼睛，而不是数字"></a>相信你的眼睛，而不是数字</h3><p>关于，垂直居中稍微往上一点看起来更居中。内边距顶部和底部的内边距需要稍微比左右的小一点，这样看起来更整齐等。主要是视觉上的错觉。</p><h3 id="关于响应式网页设计"><a href="#关于响应式网页设计" class="headerlink" title="关于响应式网页设计"></a>关于响应式网页设计</h3><ol><li>媒体查询的端点不应该由具体的设备来决定。</li><li>使用百分比长度来取代固定长度。或于是口相关的单位（<code>vw</code>、<code>vh</code>、<code>vmin</code>和<code>vmax</code>）。</li><li>需要在较大设备获得固定宽度，使用<code>max-width</code>而不是<code>width</code>,前者可以使用较小的分辨率。</li><li>为替换元素(img、objuct、video、iframe等)设置一个max-width。</li><li>背景图片<code>background-size: cover</code>可以铺满，但大图缩小带宽会消耗。</li><li>图片或其他元素行列式布局时，<code>display: inline-block</code>或<code>flexbox</code>来布局。</li><li>多列文本，指定<code>column-width</code>（列宽）而不是指定<code>column-count</code>（列数）。</li></ol><h3 id="合理使用简写"><a href="#合理使用简写" class="headerlink" title="合理使用简写"></a>合理使用简写</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">rebeccapurple</span>;</div><div class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">rebeccapurple</span></div></pre></td></tr></table></figure><p>前者简写可以确保，你获得rebeccapurple的纯色背景，而后者，可能是一个图案，因为可能有一条<code>background-image</code>在起作用。你也许能将所有的展开式属性全部设置一遍，但你可能会漏几个；又或者，未来CSS工作组会引入更多的展开式属性。所以合理的使用简写是一种良好的防卫性编码方式，可以抵御未来的风险。如果我们需要明确的覆盖某个具体的展开式属性，就需要使用展开式属性，如前面的<code>border-width</code>。</p><p>怪异的简写语法 =&gt; 可能会产生歧义的属性值用<code>&#39;/&#39;</code>分隔。</p><h1 id="背景与边框"><a href="#背景与边框" class="headerlink" title="背景与边框"></a>背景与边框</h1><h2 id="１．半透明边框"><a href="#１．半透明边框" class="headerlink" title="１．半透明边框"></a>１．半透明边框</h2><blockquote><p>背景知识: RGBA/HSLA颜色</p></blockquote><h3 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h3><p>也许我们会写出这样的代码来实现半透明边框：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">border</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">hsla</span>(0,0%,100%,<span class="selector-class">.5</span>);</div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">white</span>;</div></pre></td></tr></table></figure></p><p>然而半透明边框却没有实现半透明边框？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实我们的边框是存在的，然而我们所需要做的是，将body的背景从半透明的白色边框透出来。我们可以通过<code>background-clip</code>来调整上述的特性，这个属性的初始值是<code>border-box</code>,意味着背景会被元素的<code>border-box</code>（即边框的外沿框）裁切掉。我们修改为<code>padding-box</code>就可以用内边距的外沿来把背景裁切掉。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">border</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">hsla</span>(0,0%,100%,<span class="selector-class">.5</span>);</div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">white</span>;</div><div class="line"><span class="selector-tag">bcakground-clip</span>: <span class="selector-tag">padding-box</span>;</div></pre></td></tr></table></figure></p><h2 id="2-多重边框"><a href="#2-多重边框" class="headerlink" title="2. 多重边框"></a>2. 多重边框</h2><blockquote><p>背景知识：box-shadow的基本用法</p></blockquote><h3 id="难题-1"><a href="#难题-1" class="headerlink" title="难题"></a>难题</h3><p>有时我们需要建立多个边框。</p><h3 id="box-shadow-方案"><a href="#box-shadow-方案" class="headerlink" title="box-shadow 方案"></a><code>box-shadow</code> 方案</h3><p>我们需要了解<code>box-shadow</code>的第四个参数，称为”扩张半径”,可以让投影面积变大或者变小。</p><p>优点：它的支持逗号分隔，我们可以创建任意数量的投影。适用于多层边框需求</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">yellowgreen</span>;</div><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#655</span>, 0 0 0 15<span class="selector-tag">px</span> <span class="selector-tag">deeppink</span>;</div></pre></td></tr></table></figure><p><code>box-shadow</code>是层层叠加的，第一层投影位于最顶端，以此类推。</p><p>缺点：</p><ol><li>投影的行为和边框不一致。</li><li>假投影出现在元素外圈，不会影响相关事件。</li></ol><h3 id="outline-方案"><a href="#outline-方案" class="headerlink" title="outline 方案"></a><code>outline</code> 方案</h3><p>当我们只需要两层边框的时候，可以在设置常规的边框后添加<code>outline</code>描边。优点是<code>outline</code>十分灵活，而<code>box-shadow</code>只能模拟实现边框。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">yellowgreen</span>;</div><div class="line"><span class="selector-tag">border</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#655</span>;</div><div class="line"><span class="selector-tag">outline</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">deeppink</span>;</div></pre></td></tr></table></figure></p><p>缺点：</p><ol><li>只适用于双层边框。</li><li>边框不一定贴合<code>border-radius</code>产生的圆角。</li><li>尽管说描边可以不是矩形，但大多数情况需要测试。</li></ol><h2 id="3-灵活的背景定位"><a href="#3-灵活的背景定位" class="headerlink" title="3. 灵活的背景定位"></a>3. 灵活的背景定位</h2><h3 id="难题-2"><a href="#难题-2" class="headerlink" title="难题"></a>难题</h3><p>很多时候，我们想针对容器的某个角对背景图案做偏移定位,例如想要类似内边距的效果怎么做呢。</p><h3 id="background-position的扩展语法方案"><a href="#background-position的扩展语法方案" class="headerlink" title="background-position的扩展语法方案"></a><code>background-position</code>的扩展语法方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">url</span>(...) <span class="selector-tag">no-repeat</span> <span class="selector-id">#58a</span>;</div><div class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">right</span> 20<span class="selector-tag">px</span> <span class="selector-tag">bottom</span> 10<span class="selector-tag">px</span>;</div><div class="line"></div><div class="line"><span class="comment">/* 退回方案 */</span></div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">url</span>(...) <span class="selector-tag">no-repeat</span> <span class="selector-tag">bottom</span> <span class="selector-tag">right</span> <span class="selector-id">#58a</span>;</div><div class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">right</span> 20<span class="selector-tag">px</span> <span class="selector-tag">bottom</span> 10<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure><h3 id="background-origin-方案"><a href="#background-origin-方案" class="headerlink" title="background-origin 方案"></a>background-origin 方案</h3><p>需要图片的偏移量和内边距相同时。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">padding</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">url</span>(...) <span class="selector-tag">no-repeat</span> <span class="selector-id">#58a</span>;</div><div class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">right</span> 10<span class="selector-tag">px</span> <span class="selector-tag">bottom</span> 10<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure></p><p>代码很繁琐，一个改动需要改三处。</p><p>默认情况下<code>background-position</code>是以<code>padding box</code> 为准的，即<code>left</code> <code>top</code>等是以<code>padding box</code>为准的。每个元素有三个矩形框，<code>boeder box</code>, <code>padding box</code>和<code>content box</code>。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">padding</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">url</span>(...) <span class="selector-tag">no-repeat</span> <span class="selector-id">#58a</span> <span class="selector-tag">bottom</span> <span class="selector-tag">right</span>; </div><div class="line"><span class="selector-tag">background-origin</span>: <span class="selector-tag">content-box</span>;</div></pre></td></tr></table></figure></p><h3 id="calc-方案"><a href="#calc-方案" class="headerlink" title="calc 方案"></a><code>calc</code> 方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">url</span>(...) <span class="selector-tag">no-repeat</span>;</div><div class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 20<span class="selector-tag">px</span>) <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 10<span class="selector-tag">px</span>)</div></pre></td></tr></table></figure><h2 id="4-边框内圆角"><a href="#4-边框内圆角" class="headerlink" title="4. 边框内圆角"></a>4. 边框内圆角</h2><blockquote><p>背景知识：box-shadow, outline “多重边框”</p></blockquote><h3 id="难题-3"><a href="#难题-3" class="headerlink" title="难题"></a>难题</h3><p>有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外部依然保持矩形的形状。这里放弃两个<code>div</code>元素的方案。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>两个<code>div</code>的确很优秀，如果我们只是需要纯色的边框，只需要一个元素的方法呢。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">tan</span>;</div><div class="line"><span class="selector-tag">border-radius</span>: <span class="selector-class">.8em</span>;</div><div class="line"><span class="selector-tag">padding</span>: 1<span class="selector-tag">em</span>;</div><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 0 <span class="selector-class">.6em</span> <span class="selector-id">#655</span></div><div class="line"><span class="selector-tag">outline</span>: <span class="selector-class">.6em</span> <span class="selector-tag">solid</span> <span class="selector-id">#655</span></div></pre></td></tr></table></figure></p><p>主要就是利用<code>box-shadow</code>的扩展半径填充元素与<code>outline</code>之间的缝隙。<br>根据勾股定理大约取值为半径的一半。</p><h2 id="5-条纹背景"><a href="#5-条纹背景" class="headerlink" title="5. 条纹背景"></a>5. 条纹背景</h2><blockquote><p>背景知识：CSS线性渐变， background-size</p></blockquote><h3 id="难题-4"><a href="#难题-4" class="headerlink" title="难题"></a>难题</h3><p>简单的条纹背景，我们用CSS自己创建。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>水平条纹<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#fb3</span> 33<span class="selector-class">.3</span>%, <span class="selector-id">#58a</span> 0, <span class="selector-id">#58a</span> 66<span class="selector-class">.6</span>%, <span class="selector-tag">yellowgreen</span> 0);</div><div class="line"><span class="selector-tag">background-size</span>: 100% 45<span class="selector-tag">px</span></div></pre></td></tr></table></figure></li></ol><p>避免每次修改条纹宽度的捷径：</p><blockquote><p>如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。</p></blockquote><ol start="2"><li><p>垂直条纹</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="comment">/* 或 90deg*/</span> <span class="selector-id">#fb3</span> 50%, <span class="selector-id">#58a</span> 0);</div><div class="line"><span class="selector-tag">background-size</span>: 30<span class="selector-tag">px</span> 100%;</div></pre></td></tr></table></figure></li><li><p>斜向条纹</p></li></ol><p>由于贴片问题，我们需要设置四个色块。贴片的面积也需要重新计算相当于1.4倍的需要的半径。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(45<span class="selector-tag">deg</span>, <span class="selector-id">#fb3</span> 25%, <span class="selector-id">#58a</span> 0, <span class="selector-id">#58a</span> 50%, <span class="selector-id">#fb3</span> 0, <span class="selector-id">#fb3</span> 75%, <span class="selector-id">#58a</span> 0);</div><div class="line"><span class="selector-tag">background</span>: 42<span class="selector-tag">px</span> 42<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure></p><ol start="4"><li>更好的斜向条纹</li></ol><p><code>linear-gradient()</code> 和 <code>radial-gradient()</code>还有循环加强版：<code>repeating-linear-gradient()</code> 和 <code>repeating-radial-gradient()</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">repeating-linear-gradient</span>(60<span class="selector-tag">deg</span>, <span class="selector-id">#fb3</span>, <span class="selector-id">#fb3</span> 15<span class="selector-tag">px</span>, <span class="selector-id">#58a</span> 0, <span class="selector-id">#58a</span> 30<span class="selector-tag">px</span>);</div></pre></td></tr></table></figure><ol start="5"><li>灵活的同色系条纹<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">background: #58a;</div><div class="line">background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1), hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px)</div></pre></td></tr></table></figure></li></ol><p>利用transparent实现条纹的深色，直接显示背景。</p><h2 id="6-复杂的背景图案"><a href="#6-复杂的背景图案" class="headerlink" title="6. 复杂的背景图案"></a>6. 复杂的背景图案</h2><blockquote><p>背景知识：CSS渐变，“条纹背景”</p></blockquote><h3 id="难题-5"><a href="#难题-5" class="headerlink" title="难题"></a>难题</h3><p>不仅仅有各种条纹图案，一些稍复杂的几何图案，CSS也能实现。</p><h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">white</span>;</div><div class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(90<span class="selector-tag">deg</span>, <span class="selector-tag">rgba</span>(200,0,0,05) 50%, <span class="selector-tag">transparent</span> 0),<span class="selector-tag">linear-gradient</span>(<span class="selector-tag">rgba</span>(200,0,0,05) 50%, <span class="selector-tag">transparent</span> 0);</div><div class="line"><span class="selector-tag">background-size</span>: 30<span class="selector-tag">px</span> 30<span class="selector-tag">px</span>;</div><div class="line"><span class="comment">/* 长度单位线条 */</span></div><div class="line"><span class="selector-tag">background</span>: <span class="selector-id">#58a</span>;</div><div class="line"><span class="selector-tag">background-image</span>: </div><div class="line">  <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">white</span> 1<span class="selector-tag">px</span>, <span class="selector-tag">transparent</span> 0),</div><div class="line">  <span class="selector-tag">linear-gradient</span>(90<span class="selector-tag">deg</span>, <span class="selector-tag">white</span> 1<span class="selector-tag">px</span>, <span class="selector-tag">transparent</span> 0);</div><div class="line"><span class="selector-tag">background-size</span>: 30<span class="selector-tag">px</span> 30<span class="selector-tag">px</span>;</div><div class="line"><span class="comment">/* 上面会形成网格图案，网格的长度还可以用长度来表示，线条的宽度可以控制 */</span></div></pre></td></tr></table></figure><h3 id="波点"><a href="#波点" class="headerlink" title="波点"></a>波点</h3><p>直接放上波点的<code>mixin</code>, 波点需要两个贴片重叠。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">mixin</span> polka(<span class="variable">$size</span>, <span class="variable">$dot</span>, <span class="variable">$base</span>, <span class="variable">$accent</span>) &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="variable">$base</span>;</div><div class="line">  <span class="attribute">background-image</span>: </div><div class="line">    radial-gradient(<span class="variable">$accent</span> <span class="variable">$dot</span>, transparent <span class="number">0</span>),</div><div class="line">    radial-gradient(<span class="variable">$accent</span> <span class="variable">$dot</span>, transparent <span class="number">0</span>);</div><div class="line">  <span class="attribute">background-size</span>: <span class="variable">$size</span> <span class="variable">$size</span>;</div><div class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>, <span class="variable">$size</span>/<span class="number">2</span> <span class="variable">$size</span>/<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用例子</span></div><div class="line">@<span class="keyword">include</span> polka(<span class="number">30px</span>, 30%, <span class="number">#655</span>, tan)</div></pre></td></tr></table></figure></p><h3 id="棋盘"><a href="#棋盘" class="headerlink" title="棋盘"></a>棋盘</h3><p>这里我们也只放上<code>mixin</code>, 它也需要贴片的重叠。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">mixin</span> checkerboard(<span class="variable">$size</span>, <span class="variable">$base</span>, <span class="variable">$accent</span>: rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">25</span>)) &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="variable">$base</span>;</div><div class="line">  <span class="attribute">background-image</span>: </div><div class="line">    linear-gradient(<span class="number">45deg</span>, </div><div class="line">      <span class="variable">$accent</span> <span class="number">25%</span>, transparent <span class="number">0</span>,</div><div class="line">      transparent <span class="number">75%</span>, <span class="variable">$accent</span> <span class="number">0</span>)</div><div class="line">    linear-gradient(<span class="number">45deg</span>,</div><div class="line">      <span class="variable">$accent</span> <span class="number">25%</span>, transparent <span class="number">0</span>,</div><div class="line">      transparent <span class="number">75%</span>, <span class="variable">$accent</span> <span class="number">0</span>)</div><div class="line">    background-position: <span class="number">0</span> <span class="number">0</span>, <span class="variable">$size</span> <span class="variable">$size</span>,</div><div class="line">    background-size: <span class="number">2</span>*<span class="variable">$size</span> <span class="number">2</span>*<span class="variable">$size</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用</span></div><div class="line">@<span class="keyword">include</span> checkerboard(<span class="number">15px</span>, <span class="number">#58a</span>, tan);</div></pre></td></tr></table></figure></p><h2 id="7-伪随机背景"><a href="#7-伪随机背景" class="headerlink" title="7. 伪随机背景"></a>7. 伪随机背景</h2><blockquote><p>背景知识：CSS渐变，“条纹背景”，“复杂的背景图案”</p></blockquote><h3 id="难题-6"><a href="#难题-6" class="headerlink" title="难题"></a>难题</h3><p>其实自然界的事物都不是以无限平铺的方式存在的。CSS本身没有提供随机功能。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>通过质数来增加随机真实性，多个质数的话，那么只有经过这几个质数相乘才会重复一次。</p><h2 id="8-连续的图像边框"><a href="#8-连续的图像边框" class="headerlink" title="8. 连续的图像边框"></a>8. 连续的图像边框</h2><blockquote><p>背景知识：CSS渐变，基本的<code>border-image</code>，“条纹背景”，基本的CSS动画</p></blockquote><h3 id="难题-7"><a href="#难题-7" class="headerlink" title="难题"></a>难题</h3><p>有时我们想把一副图案或者图片应用为边框，而不是背景。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>也许两个元素，一个做背景一个做内容很容易做到，但我们CSS方案，尽量，每个<code>html</code>元素和内容不重叠, 主要思路：在石雕背景图案之上，再叠加一层纯色的实色背景。给两层背景指定不一样的<code>background-clip</code>值，实色用css渐变来实现。</p><p>方法一：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* background-origin 消除拼接效果。 */</span></div><div class="line"><span class="selector-tag">padding</span>: 1<span class="selector-tag">em</span>;</div><div class="line"><span class="selector-tag">border</span>: 1<span class="selector-tag">em</span> <span class="selector-tag">solid</span> <span class="selector-tag">transparent</span>;</div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">white</span>, <span class="selector-tag">white</span>),</div><div class="line">            <span class="selector-tag">url</span>(...);</div><div class="line"><span class="selector-tag">background-size</span>: <span class="selector-tag">cover</span>;</div><div class="line"><span class="selector-tag">background-clip</span>: <span class="selector-tag">padding-box</span>, <span class="selector-tag">border-box</span>;</div><div class="line"><span class="selector-tag">background-origin</span>: <span class="selector-tag">border-box</span>; </div><div class="line"></div><div class="line"><span class="comment">/* 简写 */</span></div><div class="line"><span class="selector-tag">padding</span>: 1<span class="selector-tag">em</span>;</div><div class="line"><span class="selector-tag">border</span>: 1<span class="selector-tag">em</span> <span class="selector-tag">solid</span> <span class="selector-tag">transparent</span>;</div><div class="line"><span class="selector-tag">background</span>:</div><div class="line">  <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">white</span>, <span class="selector-tag">white</span>) <span class="selector-tag">padding-box</span>,</div><div class="line">  url(...) border-box 0 / cover;</div><div class="line"></div><div class="line"><span class="comment">/* 信封边框图案 */</span></div><div class="line"><span class="selector-tag">padding</span>: 1<span class="selector-tag">em</span>;</div><div class="line"><span class="selector-tag">border</span>: 16<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">transparent</span>;</div><div class="line"><span class="selector-tag">border-image</span>: 16 <span class="selector-tag">repeating-linear-gradient</span>(<span class="selector-tag">-45deg</span>,</div><div class="line">                    <span class="selector-tag">red</span> 0, <span class="selector-tag">red</span> 1<span class="selector-tag">em</span>, </div><div class="line">                    <span class="selector-tag">transparent</span> 0, <span class="selector-tag">transparent</span> 2<span class="selector-tag">em</span>,</div><div class="line">                    <span class="selector-id">#58a</span> 0, <span class="selector-id">#58a</span> 3<span class="selector-tag">em</span>,</div><div class="line">                    <span class="selector-tag">transparent</span> 0, <span class="selector-tag">transparent</span> 4<span class="selector-tag">em</span>);</div></pre></td></tr></table></figure></p><p>如果利用动画还能形成蚂蚁行军效果。即选中不停转动的虚线框。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> ants &#123;<span class="selector-tag">to</span> &#123;<span class="attribute">background-position</span>: <span class="number">100%</span>&#125;&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.marching-ants</span> &#123;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</div><div class="line">  <span class="attribute">background</span>: </div><div class="line">    <span class="built_in">linear-gradient</span>(white, white) padding-box,</div><div class="line">    <span class="built_in">repeating-linear-gradient</span>(-45deg,</div><div class="line">      black 0, black 25%, white 0, white 50%</div><div class="line">      ) <span class="number">0</span> / .<span class="number">6em</span> .<span class="number">6em</span>;</div><div class="line">  <span class="attribute">animation</span>: ants <span class="number">12s</span> linear infinite;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;这个总结，基本主要记录作者给的解决方法和主要的code。思路的确很重要。共有47个小难题。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://hddhyq.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://hddhyq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>wepy开发微信小程序总结</title>
    <link href="https://hddhyq.github.io/2017/12/27/wepy%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://hddhyq.github.io/2017/12/27/wepy开发微信小程序总结/</id>
    <published>2017-12-27T08:44:25.000Z</published>
    <updated>2018-07-08T04:25:55.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目源代码"><a href="#项目源代码" class="headerlink" title="项目源代码"></a>项目源代码</h1><p><a href="https://github.com/hddhyq/One-per-day" target="_blank" rel="noopener">https://github.com/hddhyq/One-per-day</a><br><a id="more"></a></p><h3 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a>项目截图</h3><p><img src="https://github.com/hddhyq/One-per-day/raw/master/screenshot/oneList.gif" alt=""><br><img src="https://github.com/hddhyq/One-per-day/raw/master/screenshot/oneGrap.gif" alt=""><br><img src="https://github.com/hddhyq/One-per-day/raw/master/screenshot/oneEassy.gif" alt=""><br><img src="https://github.com/hddhyq/One-per-day/raw/master/screenshot/oneMovie.gif" alt=""></p><h1 id="认识wepy和微信小程序"><a href="#认识wepy和微信小程序" class="headerlink" title="认识wepy和微信小程序"></a>认识wepy和微信小程序</h1><p>wepy 相对于小程序原生开发框架相比有很多优点，缺点也许也有，这里我们先看看优点，毕竟可以wepy和微信自带的框架混合开发。</p><ul><li><p>开发风格<br>接近于 Vue.js，支持组件 Props 传值，自定义事件、组件分布式复用Mixin、计算属性函数computed、模板内容分发slot等等</p></li><li><p>组件化、第三方npm资源自动处理依赖关系、支持ES2015(Promise/Class/Async)等</p></li><li><p>对小程序本身的优化、支持样式编译器: Less/Sass/Stylus, 模板编译器：wx-ml/Pug，代码编译器：Babel/Typescript。支持插件如：文件压缩和图片压缩</p></li></ul><p>至于细节还是去访问官网比较好。</p><ul><li><a href="https://tencent.github.io/wepy/document.html" target="_blank" rel="noopener">wepy文档</a></li><li><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/" target="_blank" rel="noopener">微信小程序文档</a></li></ul><h2 id="scroll-view-必须指定高度"><a href="#scroll-view-必须指定高度" class="headerlink" title="scroll-view 必须指定高度"></a>scroll-view 必须指定高度</h2><p>开发电影下拉加载的时候，scroll-view 没给高度，拉到页面底部没有触发新的数据请求，解决方法：<br><figure class="highlight styl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.scroll-container</div><div class="line">  <span class="attribute">position</span>: absolute</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span></div><div class="line">  <span class="attribute">right</span>: <span class="number">0</span></div><div class="line">  <span class="attribute">bottom</span>: <span class="number">0</span></div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span></div></pre></td></tr></table></figure></p><h2 id="小程序页面hidden不能用于flex布局"><a href="#小程序页面hidden不能用于flex布局" class="headerlink" title="小程序页面hidden不能用于flex布局"></a>小程序页面hidden不能用于flex布局</h2><p>解决方法：将flex布局的view 重新包裹上一层view</p><h2 id="wepy孙子组件的传值"><a href="#wepy孙子组件的传值" class="headerlink" title="wepy孙子组件的传值"></a>wepy孙子组件的传值</h2><p>wepy的传值给孙子组件，孙子组件没有及时跟新，最后放弃了孙子组件，将本来的孙子组件一起写到了父组件。</p><h2 id="wepy的组件style不能添加scoped"><a href="#wepy的组件style不能添加scoped" class="headerlink" title="wepy的组件style不能添加scoped"></a>wepy的组件style不能添加scoped</h2><p>给组件添加了scoped，不能正确显示相关的style，解决方法是把子组件的scoped去掉了。应该是scoped重复了两次，引用组件的时候应该不让组件scoped生成，或者父组件不对子组件引用添加scoped前缀，个人猜测。</p><h2 id="wepy-props的传值"><a href="#wepy-props的传值" class="headerlink" title="wepy props的传值"></a>wepy props的传值</h2><p>在评星组件中，传入数值的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;rating :score.sync=&quot;score&quot;&gt;&lt;/rating&gt;</div></pre></td></tr></table></figure></p><p>score是数值，结果传递了一个对象的属性，传值失败，结果最后将分数单独设置为一个data中的Number类型的数据，传值成功。</p><h2 id="swiper的高度及跳转"><a href="#swiper的高度及跳转" class="headerlink" title="swiper的高度及跳转"></a>swiper的高度及跳转</h2><p>图文的详情本来是想用swiper来作为项目容器，结果swiper组件的高度，必须固定，而我的图文详情页的高度没有固定，第二点，并没有查阅到swiper的跳转功能，那我在首页点击的图片进入的图片还是第一张，最后放弃了swiper这个想法，不过总的来说，swiper主要还是用来放几张图片在首页轮播的。</p><h2 id="关于图文详情页的跳转"><a href="#关于图文详情页的跳转" class="headerlink" title="关于图文详情页的跳转"></a>关于图文详情页的跳转</h2><p>oneDetail 最后实现的只是数据改变，重新绘制页面，想的是实现swiper图片的切换效果，这里没有实现。不过有一个想法，把页面的宽度设置为300%的宽度，也就是三张图片的宽度，然后进行切换页面的transformＸ轴的计算和页面滑动用js相关联进行计算，上下两张图片再用懒加载，这样就实现了页面的切换。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;项目源代码&quot;&gt;&lt;a href=&quot;#项目源代码&quot; class=&quot;headerlink&quot; title=&quot;项目源代码&quot;&gt;&lt;/a&gt;项目源代码&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/hddhyq/One-per-day&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/hddhyq/One-per-day&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="wepy" scheme="https://hddhyq.github.io/categories/wepy/"/>
    
    
      <category term="wepy" scheme="https://hddhyq.github.io/tags/wepy/"/>
    
      <category term="微信小程序" scheme="https://hddhyq.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>HTTP识别、认证与安全(https)</title>
    <link href="https://hddhyq.github.io/2017/12/10/HTTP%E8%AF%86%E5%88%AB%E3%80%81%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%AE%89%E5%85%A8-https/"/>
    <id>https://hddhyq.github.io/2017/12/10/HTTP识别、认证与安全-https/</id>
    <published>2017-12-10T14:00:56.000Z</published>
    <updated>2018-07-08T04:25:55.511Z</updated>
    
    <content type="html"><![CDATA[<p>阅读的HTTP权威指南<br><a id="more"></a></p><h1 id="客户端识别与cookie机制"><a href="#客户端识别与cookie机制" class="headerlink" title=" 客户端识别与cookie机制"></a><a id="browser-cookie"></a> 客户端识别与cookie机制</h1><p>Web服务器需要和成千上百个服务器通信。服务器通常需要记录下它们与谁交换，而不会认为所有请求都来自匿名的客户端。能使用的方法主要有：</p><ul><li>HTTP首部</li><li>客户端IP地址</li><li>用户登录</li><li>胖URL</li><li>cookie</li></ul><h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title=" HTTP首部"></a><a id="http-header"></a> HTTP首部</h2><p>常见http首部:</p><table><thead><tr><th>首部名称</th><th>首部类型</th><th>描述</th></tr></thead><tbody><tr><td>From</td><td>请求</td><td>用户的Email地址</td></tr><tr><td>User-Agent</td><td>请求</td><td>用户的浏览器软件</td></tr><tr><td>Referer</td><td>请求</td><td>用户是从这个页面跳转过来的</td></tr><tr><td>Authorization</td><td>请求</td><td>用户名和密码</td></tr><tr><td>Client-IP</td><td>拓展(请求)</td><td>客户端的IP地址</td></tr><tr><td>X-Forwarded-For</td><td>拓展(请求)</td><td>客户端的IP地址</td></tr><tr><td>Cookie</td><td>拓展(请求)</td><td>服务器产生的ID标签</td></tr></tbody></table><h2 id="客户端IP地址"><a href="#客户端IP地址" class="headerlink" title=" 客户端IP地址"></a><a id="ip-address"></a> 客户端IP地址</h2><p>早期的Web先锋曾尝试将客户端IP作为一种标示形式使用，如果每一个用户一个IP地址，那这个用法说不定还行，不过。。。</p><h2 id="用户登录"><a href="#用户登录" class="headerlink" title=" 用户登录"></a><a id="user-login"></a> 用户登录</h2><p>Web服务器无需被动的根据用户的IP地址来猜测他的用户，它可以要求用户通过用户名和密码进行认证(登录)来显式地询问用户是谁。下一节基本认证会再讲解，关于Authorization中包涵用户的登录信息。服务器不知道用户的时候(认证没通过)一般会返回401错误码。</p><h2 id="胖URL"><a href="#胖URL" class="headerlink" title=" 胖URL"></a><a id="bigger-url"></a> 胖URL</h2><p>有些Web站点会为每个用户生成特定版本的URL来追踪用户的身份。这个胖URL存在很多问题。</p><ul><li>丑陋的URL</li><li>无法共享URL</li><li>破坏缓存</li><li>额外的服务器负荷</li><li>逃逸口（跳转URL）</li><li>在会话间是非持久的</li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title=" cookie"></a><a id="cookie"></a> cookie</h2><p>cookie是当前识别用户，实现持久会话的最好方式。前面各种技术中存在的问题对他并没有什么影响。</p><p>有两种cookie类型，分别是：会话cookie和持久cookie。会话cookie是一种临时cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话cookie就删除了。持久cookie的生存时间更长一些，它们储存在硬盘上，计算器重启时，它们仍然存在。通常会用持久cookie维护某个用户会周期性访问的站点的配置文件或登录名。</p><p>这里我们需要知道，cookie常见也就是键值对，如：<code>Cookie: name=&quot;Hdd&quot;</code></p><h1 id="基本认证机制"><a href="#基本认证机制" class="headerlink" title=" 基本认证机制"></a><a id="basic-author"></a> 基本认证机制</h1><p>认证就是要给出一些身份证明。证明你是你。基本的：HTTP的质询/响应机制。</p><h2 id="HTTP的质询-响应认证框架"><a href="#HTTP的质询-响应认证框架" class="headerlink" title=" HTTP的质询/响应认证框架"></a><a id="http-ask"></a> HTTP的质询/响应认证框架</h2><p><img src="http://s8.sinaimg.cn/mw690/0020fPEhty6ZiTmP4J9e7" alt=""></p><h2 id="安全域"><a href="#安全域" class="headerlink" title=" 安全域"></a><a id="safe-area"></a> 安全域</h2><p>Web服务器会将受保护的文档组织成一个安全域。每个安全域可以有不同的授权用户集。<br>如下图：<br><img src="http://s3.sinaimg.cn/mw690/0020fPEhty6ZiTpFhkKb2" alt=""><br>下面是一个假想的基本认证质询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HTTP/1.0 401 Unauthorized</div><div class="line">WWW-Authenticate: Basic realm = &quot;Corporate Financials&quot;</div></pre></td></tr></table></figure></p><h2 id="Base-64-用户名-密码编码"><a href="#Base-64-用户名-密码编码" class="headerlink" title=" Base-64 用户名/密码编码"></a><a id="base64-pwd"></a> Base-64 用户名/密码编码</h2><p>密码和账户名用Base-64编码能无需担心字符集，还有能防止管理员无意间看到用户名和密码。</p><h2 id="基本认证的安全缺陷"><a href="#基本认证的安全缺陷" class="headerlink" title=" 基本认证的安全缺陷"></a><a id="base-authentication"></a> 基本认证的安全缺陷</h2><p>基本认证简单便捷，但并不安全。只能用它来防止非恶意用户无意间进行的访问，或将其与SSL这样的加密技术配合使用。<br>缺陷如下：</p><ol><li>基本认证会通过网络发送用户名和密码。这几乎与“明文”传送，容易被拦截破解。</li><li>即使密码没有被破解，但第三方用户仍可以将修改过的捕获的用户名和秘密不断传送给原始服务器来访问。</li><li>即使基本认证用于一些不太重要的应用程序，也要防止有心人用它来“撞库”。</li><li>基本认证没有提供任何针对代理和作为中间人的中间节点的防护措施，它们没有修改认证首部，却修改了报文的其他部分，这样就很严重的改变的事物的本质，所以下一节会介绍摘要认证。</li><li>假冒服务器很容易骗过基本认证，从而伪造钓鱼网站之类的。</li></ol><h1 id="摘要认证"><a href="#摘要认证" class="headerlink" title=" 摘要认证"></a><a id="digest-authentication"></a> 摘要认证</h1><h2 id="摘要认证的改进"><a href="#摘要认证的改进" class="headerlink" title=" 摘要认证的改进"></a><a id="digest"></a> 摘要认证的改进</h2><p>摘要认证是另一种HTTP认证协议，它试图修复基本认证的严重缺陷。如下改进：</p><ul><li><p>永远不会以明文方式在网络发送密码。</p><p>发送的都是密码的摘要，而只有服务端和客户端是知道密码的，那密码第三方就不会知道了。</p></li><li><p>可以防止恶意用户捕获并重放认证的握手过程。</p><p>服务器会生成一个随机数发送给客户端，在进行摘要计算，常见算法为MD5。这时会进行随机数和密码进行摘要处理，随机数和时间戳有关，这样第三方无法得知原始密码，也就无法对新的摘要进行计算。质询握手过程。<br><img src="http://s13.sinaimg.cn/mw690/0020fPEhty6Zjxy92t60c" alt=""></p></li><li><p>可以有选择的防止对报文内容的篡改</p></li></ul><p>我们的内容也经过了摘要计算，所及Authentication-Info中qop(保护质量)的信息就也有内容摘要。</p><ul><li>防范其他几种常见的攻击方式</li></ul><h2 id="预授权"><a href="#预授权" class="headerlink" title=" 预授权"></a><a id="pre-licensing"></a> 预授权</h2><p>在普通认证方式中，事务结束之前，每个请求都有一次请求/质询的循环，而预授权中，客户端知道了随机数就可以取消这一过程，减少报文数量。如图：<br><img src="http://s5.sinaimg.cn/mw690/0020fPEhty6ZjxA7cNe44" alt=""></p><h2 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title=" 安全性考虑"></a><a id="safe-thinking"></a> 安全性考虑</h2><p>要知道，摘要认证对于密码的保护确实厉害了很多，不过对于窃听报文内容等还是保护不够，真正的安全的事物只有通过SSL才能实现。</p><h1 id="安全HTTP"><a href="#安全HTTP" class="headerlink" title=" 安全HTTP"></a><a id="safe-http"></a> 安全HTTP</h1><h2 id="HTTPS前瞻"><a href="#HTTPS前瞻" class="headerlink" title=" HTTPS前瞻"></a><a id="pre-hrrps"></a> HTTPS前瞻</h2><p>功能：</p><ul><li>服务器认证（客户端知道他们是在于真正的服务器而不是伪造的服务器通话）</li><li>客户端认证（服务器知道他们在与真正的客户端而不是伪造的客户端通话）</li><li>完整性（保证数据不被修改）</li><li>加密（通话是私密的，不用担心被窃听）</li><li>效率（足够快）</li><li>普适性（基本上所有的服务器端和客户端都能支持）</li><li>管理的可扩展性（任何地方任何人都可以进行安全通信）</li><li>适应性（能够支持当前最知名的安全方法）</li><li>社会可行性（满足社会的政治文化需求）</li></ul><p>关于HTTPS的传输：</p><p><img src="http://s10.sinaimg.cn/mw690/0020fPEhty6ZmGGRt0J59" alt=""></p><p>大部分困难的编码及解码工作都是在SSL库中完成的，所以Web客户端和服务器在使用安全HTTP时无需过多的修改其协议处理逻辑。在大多数情况下，只需要用SSL的输入输出来取代TCP的调用，再增加其他几个调用来配置和管理安全信息就行。</p><h2 id="数字加密"><a href="#数字加密" class="headerlink" title=" 数字加密"></a><a id="digital-encryption"></a> 数字加密</h2><h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><p>对文本加密，使偷窥者无法识别的算法，明文经过密码编码变成密文，再解码为明文</p><h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>改变密码行为的数字化参数。<br><img src="http://s4.sinaimg.cn/mw690/0020fPEhty6ZmGHSpYDd3" alt=""></p><h3 id="对称密钥加密系统"><a href="#对称密钥加密系统" class="headerlink" title="对称密钥加密系统"></a>对称密钥加密系统</h3><p>在对称密钥加密系统，发送端和接收端要共享相同的密钥才能进行通信。<br>流行的对称密钥加密算法有：DES、Triple-DES、RC2、和RC4</p><p>密钥长度和枚举攻击<br><img src="http://s6.sinaimg.cn/mw690/0020fPEhty6ZmGIAZZX55" alt=""></p><p>对于一台服务器，如果有成千上万的客户端进行加密通话，就需要成千上万的秘钥。<br>为了解决这个问题，可以采用公开密钥加密技术。</p><h3 id="不对称密钥加密系统"><a href="#不对称密钥加密系统" class="headerlink" title="不对称密钥加密系统"></a>不对称密钥加密系统</h3><p>编/解码使用不同密钥的算法。</p><h3 id="公开密钥加密技术"><a href="#公开密钥加密技术" class="headerlink" title="公开密钥加密技术"></a>公开密钥加密技术</h3><p>公开密钥加密技术没有为每台主机使用单独的加密/解密密钥，而是使用了两个非对称密钥：一个用来对主机报文编码，另一个用来对主机报文编码。编码密钥是大家都知道的，而主机密钥只有主机知道，也就是只有服务器才知道。</p><p>即使你有了下列条件，也无法破解：</p><ol><li>公开密钥(市共有的，所有人都可以获得)</li><li>一小片拦截下的报文(可通过对网络的嗅探获取)</li><li>一条报文及与之相关的密文(对任意一段文本加密即可)</li></ol><h3 id="混合加密系统和会话密钥"><a href="#混合加密系统和会话密钥" class="headerlink" title="混合加密系统和会话密钥"></a>混合加密系统和会话密钥</h3><p>RSA加密满足了公开加密的技术，但计算的速度可能会很慢，所以比较常见的两个节点的通信采用了混合使用对称和非对称加密。</p><p>两个节点通过便捷的公开密钥加密结束建立起安全的通信，然后再用那条安全的通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名就是加了密的校验和。</p><p><img src="http://s13.sinaimg.cn/mw690/0020fPEhty6ZmGJK4rOec" alt=""></p><p>数字签名在数字证书发布的用处就比较大了。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p><img src="http://s11.sinaimg.cn/mw690/0020fPEhty6ZmGKFd2y2a" alt=""></p><p>发布了的数字证书是需要相关机构认证的。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title=" HTTPS"></a><a id="https"></a> HTTPS</h2><p>如果 URL是 HTTP，客户端就会打开一条到服务器端口 80 （默认的HTTP端口）的连接，发送 HTTP 命令。</p><p>如果 URL是 HTTPS，客户端就会打开一条到服务器端口443（默认的HTTPS端口）的连接，然后与服务器握手，以二进制的格式与服务器交换一些 SSL 安全参数，握手完成之后 SSL 的初始化就完成了，客户端发送加密的 HTTP 命令。</p><p>如果 HTTPS 使用和HTTP 相同的 80端口，那么当加密的 HTTP 命令到达之后，普通的服务器会认为是普通HTTP 命令无法辨认导致错误关闭连接。</p><p>但是如果服务器的HTTP层包含了安全HTTP的解析，那么也可以重用80端口而不会引起问题。</p><h3 id="SSL握手"><a href="#SSL握手" class="headerlink" title=" SSL握手"></a><a id="ssl-handshake"></a> SSL握手</h3><p>内容：</p><ul><li>交换协议版本号</li><li>选择一个两端都了解的密码</li><li>对两端的身份进行认证</li><li>生成临时的会话密钥，用于加密信道</li></ul><p>简化版SSL握手：</p><p><img src="http://s15.sinaimg.cn/mw690/0020fPEhgy6ZpeFqc5o3e" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读的HTTP权威指南&lt;br&gt;
    
    </summary>
    
      <category term="HTTPS" scheme="https://hddhyq.github.io/categories/HTTPS/"/>
    
    
      <category term="HTTP安全" scheme="https://hddhyq.github.io/tags/HTTP%E5%AE%89%E5%85%A8/"/>
    
      <category term="HTTPS" scheme="https://hddhyq.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>通过爬虫看async/await</title>
    <link href="https://hddhyq.github.io/2017/11/24/%E9%80%9A%E8%BF%87%E7%88%AC%E8%99%AB%E7%9C%8Basync-await/"/>
    <id>https://hddhyq.github.io/2017/11/24/通过爬虫看async-await/</id>
    <published>2017-11-24T07:23:43.000Z</published>
    <updated>2018-07-08T04:25:55.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a><a id="crawler"></a>爬虫</h1><p>先放下小练习地址 <a href="https://github.com/hddhyq/node-spider-test" target="_blank" rel="noopener">小爬虫爬取图片</a>，然后来研究下，爬虫需要注意些什么。爬虫始于种子（所需爬取url列表），通过<code>requset</code>从中爬取所需的页面的每一个帖子数，然后从中获取图片的url,然后下载。<br><a id="more"></a></p><h2 id="Request-amp-amp-Cheerio"><a href="#Request-amp-amp-Cheerio" class="headerlink" title=" Request&amp;&amp;Cheerio"></a><a id="Request-Cheerio"></a> Request&amp;&amp;Cheerio</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单个分页获取包涵图片URL</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPages</span>(<span class="params">url: <span class="built_in">string</span></span>): <span class="title">Promise</span>&lt;<span class="title">string</span>[]&gt; </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      R(url, <span class="function">(<span class="params">err, res, body</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> $ = cheerio.load(body)</div><div class="line">        <span class="keyword">let</span> liDom = $(<span class="string">'body &gt; div.content.clr &gt; div.content_left &gt; div.post_list_block_div &gt; ul &gt; li'</span>)</div><div class="line">        <span class="keyword">const</span> Pages = getPagesFromDom(liDom)</div><div class="line">        resolve(Pages)</div><div class="line">      &#125;)</div><div class="line">    &#125;, <span class="number">1000</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>const $ = cheerio.load(body)</code>就是Cheerio最基本的用法然后看一下<code>getPagesFromDom(liDom)</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPagesFromDom</span>(<span class="params">dom: Cheerio</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(dom).map(<span class="function">(<span class="params">v, k</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> t = v.attribs[<span class="string">'onclick'</span>]</div><div class="line">    <span class="keyword">let</span> url = uri + t.substring(<span class="number">24</span>, t.length - <span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span> url</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>中间我们传入的是一个<code>dom: Cheerio</code>对象，便于下一步的解析，对页面的帖子数相关连接的url进行记录。</p><p>接下来就是对每个帖子的发帖的前面的图片进行下载。</p><h1 id="延时控制"><a href="#延时控制" class="headerlink" title=" 延时控制"></a><a id="delay-control"></a> 延时控制</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getImgPages</span>(<span class="params">pages: <span class="built_in">string</span>[]</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> taskQ = pages.map(<span class="keyword">async</span> (v, k) =&gt; &#123;</div><div class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span> * k)   <span class="comment">// 第二个节流方法</span></div><div class="line">    <span class="keyword">return</span> getPages(v)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">let</span> pageArray = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(taskQ)</div><div class="line">  <span class="keyword">const</span> pagesArray = pageArray.reduce(<span class="function">(<span class="params">prev, current</span>) =&gt;</span> prev.concat(current), [])</div><div class="line">  <span class="keyword">return</span> pagesArray</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPages</span>(<span class="params">url: <span class="built_in">string</span></span>): <span class="title">Promise</span>&lt;<span class="title">string</span>[]&gt; </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      R(url, <span class="function">(<span class="params">err, res, body</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> $ = cheerio.load(body)</div><div class="line">        <span class="keyword">let</span> liDom = $(<span class="string">'body &gt; div.content.clr &gt; div.content_left &gt; div.post_list_block_div &gt; ul &gt; li'</span>)</div><div class="line">        <span class="keyword">const</span> Pages = getPagesFromDom(liDom)</div><div class="line">        resolve(Pages)</div><div class="line">      &#125;)</div><div class="line">    &#125;, <span class="number">1000</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms: <span class="built_in">number</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里我用了一个setTimeout定时和map定时来获取每个页面的时间进行限制。这样的方法并不是很好，也是<strong>不推荐</strong>的方法，具体推荐的方法看下面对于async/await的分析，最要是因为，后面用的<code>Promiseall(taskQ)</code>这样定时的效果其实很差，这里详细看一下后面async异步注意项第三点。</p><p>第二个我为了时间控制的函数是一个递归函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getSingleImg</span>(<span class="params">imgUrls: <span class="built_in">string</span>[], i: <span class="built_in">number</span> = 0</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (i&lt; imgUrls.length) &#123;</div><div class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>)</div><div class="line">    i++</div><div class="line">    <span class="keyword">let</span> urls = <span class="keyword">await</span> getImgUrl(imgUrls[i])</div><div class="line">    <span class="keyword">await</span> urls.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</div><div class="line">      saveImg(item)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'单页面打印成功'</span>)</div><div class="line">    &#125;)</div><div class="line">    imageUrls = <span class="keyword">await</span> imageUrls.concat(urls)</div><div class="line">    <span class="keyword">await</span> getSingleImg(imgUrls, i++)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>依旧利用了async中的顺序调用，感觉实现的方法很怪，不过好在也是实现了。</p><h1 id="async-await"><a href="#async-await" class="headerlink" title=" async/await"></a><a id="async-await"></a> async/await</h1><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。<br>引用<a href="http://es6.ruanyifeng.com/?search=promise.all&amp;x=0&amp;y=0#docs/async" target="_blank" rel="noopener">async 函数</a></p><p>async函数对 Generator 函数的改进，体现在以下四点。</p><ol><li>内置执行器。</li></ol><p>Generator 函数的执行必须靠执行器，所以才有了co模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asyncReadFile();</div></pre></td></tr></table></figure></p><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用co模块，才能真正执行，得到最后结果。</p><ol start="2"><li>更好的语义。</li></ol><p><code>async</code>和<code>await</code>，比起星号和yield，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p><ol start="3"><li>更广的适用性。</li></ol><p>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p><ol start="4"><li>返回值是 Promise。<br>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</li></ol><p>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a><a id="warn-point"></a>使用注意点</h2><p>第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 另一种写法</span></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise()</div><div class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</div><div class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</div></pre></td></tr></table></figure></p><p>上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">let</span> fooPromise = getFoo();</div><div class="line"><span class="keyword">let</span> barPromise = getBar();</div><div class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</div><div class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</div></pre></td></tr></table></figure></p><p>上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。</p><p>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。(也就是我们需要用到的点。)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</div><div class="line"></div><div class="line">  <span class="comment">// 报错</span></div><div class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line">    <span class="keyword">await</span> db.post(doc);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123; <span class="comment">//这里不需要 async</span></div><div class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</div><div class="line"></div><div class="line">  <span class="comment">// 可能得到错误结果</span></div><div class="line">  docs.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line">    <span class="keyword">await</span> db.post(doc);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</div><div class="line">    <span class="keyword">await</span> db.post(doc);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</div><div class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</div><div class="line"></div><div class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</div><div class="line">  <span class="built_in">console</span>.log(results);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 或者使用下面的写法</span></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</div><div class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</div><div class="line"></div><div class="line">  <span class="keyword">let</span> results = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</div><div class="line">    results.push(<span class="keyword">await</span> promise);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(results);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title=" 错误处理"></a><a id="error-handle"></a> 错误处理</h2><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。</p><p>所以防止出错的方法，也是将其放在try…catch代码块之中。</p><p>如果有多个await命令，可以统一放在try…catch结构中。</p><p>也可以使用try…catch结构，实现多次重复尝试。例如在遍历中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;爬虫&quot;&gt;&lt;a href=&quot;#爬虫&quot; class=&quot;headerlink&quot; title=&quot;爬虫&quot;&gt;&lt;/a&gt;&lt;a id=&quot;crawler&quot;&gt;&lt;/a&gt;爬虫&lt;/h1&gt;&lt;p&gt;先放下小练习地址 &lt;a href=&quot;https://github.com/hddhyq/node-spider-test&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小爬虫爬取图片&lt;/a&gt;，然后来研究下，爬虫需要注意些什么。爬虫始于种子（所需爬取url列表），通过&lt;code&gt;requset&lt;/code&gt;从中爬取所需的页面的每一个帖子数，然后从中获取图片的url,然后下载。&lt;br&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://hddhyq.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="node" scheme="https://hddhyq.github.io/tags/node/"/>
    
      <category term="ES6" scheme="https://hddhyq.github.io/tags/ES6/"/>
    
      <category term="爬虫" scheme="https://hddhyq.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>headless chrome Puppeteer 无头or无界面 </title>
    <link href="https://hddhyq.github.io/2017/11/20/headless-chrome-Puppeteer-%E6%97%A0%E5%A4%B4or%E6%97%A0%E7%95%8C%E9%9D%A2/"/>
    <id>https://hddhyq.github.io/2017/11/20/headless-chrome-Puppeteer-无头or无界面/</id>
    <published>2017-11-20T06:21:17.000Z</published>
    <updated>2018-07-08T04:25:55.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述Puppeteer"><a href="#概述Puppeteer" class="headerlink" title=" 概述Puppeteer"></a><a id="instruction-puppeteer"></a> 概述Puppeteer</h1><p>Puppeteer 是一个用来控制无界面Chrome的Node库，它提供了很多高级的api来使我们跟好的控制无界面的Chrome。这个headless可以叫无头，也可以叫无界面吧<br><a id="more"></a></p><h2 id="我们能做什么？"><a href="#我们能做什么？" class="headerlink" title=" 我们能做什么？"></a><a id="what-can-we-do"></a> 我们能做什么？</h2><p>大多数我们能在浏览器上做的都能用Puppeteer来做！</p><ul><li>生成页面的截图和PDF文件。</li><li>抓取spa并生成预渲染内容（即“SSR”）。</li><li>从网页爬取内容。</li><li>自动化表单提交、UI测试、键盘输入等。</li><li>自动化更新表格创建，自动化测试环境。</li><li>捕获站点的时间线跟踪，以帮助诊断性能问题。</li></ul><p>了解这么多，我主要是从爬虫知道的这个工具。</p><p>因为这个工具相关的几个类似的工具(像PhantomJS)也大多停止更新了，谷歌真厉害。。</p><h2 id="shotscreens-和-PDF实例"><a href="#shotscreens-和-PDF实例" class="headerlink" title=" shotscreens 和 PDF实例"></a><a id="shotscreens-pdf"></a> shotscreens 和 PDF实例</h2><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p>page.screenshot([options]) 这个api 可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</div><div class="line"></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</div><div class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</div><div class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://example.com'</span>);</div><div class="line">  <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'example.png'</span>&#125;);</div><div class="line"></div><div class="line">  <span class="keyword">await</span> browser.close();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><h3 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h3><p>page.pdf(options)这个api来打印，也有一些options可以设置<br>比较常用的format：A4 之类的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</div><div class="line"></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</div><div class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</div><div class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://news.ycombinator.com'</span>, &#123;<span class="attr">waitUntil</span>: <span class="string">'networkidle2'</span>&#125;);</div><div class="line">  <span class="keyword">await</span> page.pdf(&#123;<span class="attr">path</span>: <span class="string">'hn.pdf'</span>, <span class="attr">format</span>: <span class="string">'A4'</span>&#125;);</div><div class="line"></div><div class="line">  <span class="keyword">await</span> browser.close();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><h3 id="获取页面上下文"><a href="#获取页面上下文" class="headerlink" title="获取页面上下文"></a>获取页面上下文</h3><p>page.evaluate(pageFunction, …args)， 这个api， 来解析<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</div><div class="line"></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</div><div class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</div><div class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://example.com'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Get the "viewport" of the page, as reported by the page.</span></div><div class="line">  <span class="keyword">const</span> dimensions = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      width: <span class="built_in">document</span>.documentElement.clientWidth,</div><div class="line">      height: <span class="built_in">document</span>.documentElement.clientHeight,</div><div class="line">      deviceScaleFactor: <span class="built_in">window</span>.devicePixelRatio</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Dimensions:'</span>, dimensions);</div><div class="line"></div><div class="line">  <span class="keyword">await</span> browser.close();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p><h1 id="Puppeteer常用api分类"><a href="#Puppeteer常用api分类" class="headerlink" title=" Puppeteer常用api分类"></a><a id="common-api"></a> Puppeteer常用api分类</h1><h2 id="概览"><a href="#概览" class="headerlink" title=" 概览"></a><a id="summary"></a> 概览</h2><p><img src="https://user-images.githubusercontent.com/746130/31592143-089f6f9a-b1db-11e7-9a20-16b7fc754fa1.png" alt=""></p><ul><li>Puppeteer 使用开发者工具和浏览器通信</li><li>Browser 拥有多个界面的实例</li><li>Page 至少有一个框架：主框架。可能还有其他由iframe和frame标签创建的frames</li><li>Frame 至少有一个执行上下文，默认的上下文是JavaScript的执行框架。框架可能有与执行相关联的附加执行上下文。</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title=" 环境变量"></a><a id="environment-variable"></a> 环境变量</h2><p>由<code>npm config</code>设置proxy代理，或关于下载的Url和版本之类的。</p><h2 id="类：Puppeteer"><a href="#类：Puppeteer" class="headerlink" title=" 类：Puppeteer"></a><a id="class-puppeteer"></a> 类：Puppeteer</h2><p>Puppeteer模块提供了一种方法来登录Chromium实例。</p><h2 id="类：Browser"><a href="#类：Browser" class="headerlink" title=" 类：Browser"></a><a id="class-browser"></a> 类：Browser</h2><p>一个Browser 在Puppeteer连接到Chromium实例时被创建,通过<code>puppeteer.launch</code> 或 <code>puppeteer.connect</code>.<br>常用<code>browser.newPage()</code>新界面 ,<code>browser.close()</code>关闭browser和<code>browser.wsEndpoint()</code>断点打开。</p><h2 id="类：Page"><a href="#类：Page" class="headerlink" title=" 类：Page"></a><a id="class-page"></a> 类：Page</h2><p>Page提供了于Chromium单选项交互的方法。一个Browser有多个Page实例<br>基础的方法有：<br>一些原生的事件，还有<code>page.$(selector)</code>，<code>page.$$(selector)</code>来进行页面的元素选择，<code>page.$eval(selector, pageFunction[, ...args])</code>和<code>page.$$eval(selector, pageFunction[, ...args])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> searchValue = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'#search'</span>, el =&gt; el.value);</div><div class="line"><span class="keyword">const</span> preloadHref = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'link[rel=preload]'</span>, el =&gt; el.href);</div><div class="line"><span class="keyword">const</span> html = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'.main-container'</span>, e =&gt; e.outerHTML);</div></pre></td></tr></table></figure><p><code>page.click(selector[, options])</code>鼠标点击，相关的点击事件也可以通过options来设置。</p><p><code>page.content()</code>返回整个HTML的page内容，包括doctype。</p><p><code>page.cookies(...urls)</code>,<br><code>page.deleteCookie(...cookies)</code></p><p>page.emulate(options)媒体设置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</div><div class="line"><span class="keyword">const</span> devices = <span class="built_in">require</span>(<span class="string">'puppeteer/DeviceDescriptors'</span>);</div><div class="line"><span class="keyword">const</span> iPhone = devices[<span class="string">'iPhone 6'</span>];</div><div class="line"></div><div class="line">puppeteer.launch().then(<span class="keyword">async</span> browser =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</div><div class="line">  <span class="keyword">await</span> page.emulate(iPhone);</div><div class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://www.google.com'</span>);</div><div class="line">  <span class="comment">// other actions...</span></div><div class="line">  <span class="keyword">await</span> browser.close();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p><code>page.evaluate(pageFunction, ...args)</code>对页面的上下文进行操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bodyHandle = <span class="keyword">await</span> page.$(<span class="string">'body'</span>);</div><div class="line"><span class="keyword">const</span> html = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">body</span> =&gt;</span> body.innerHTML, bodyHandle);</div><div class="line"><span class="keyword">await</span> bodyHandle.dispose();</div></pre></td></tr></table></figure></p><p><code>page.goto(url, options)</code>,<code>page.goForward(options)</code>和<code>page.goBack(options)</code>。</p><p>还可以对页面的js,css,html进行行管的操作。</p><p><code>page.setUserAgent(userAgent)</code>,<br><code>page.setViewport(viewport)</code>亦可以进行相关操作。</p><h2 id="类：Keyboard"><a href="#类：Keyboard" class="headerlink" title=" 类：Keyboard"></a><a id="class-keyboard"></a> 类：Keyboard</h2><p>键盘相关输入，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">await</span> page.keyboard.type(<span class="string">'Hello World!'</span>);</div><div class="line"><span class="keyword">await</span> page.keyboard.press(<span class="string">'ArrowLeft'</span>);</div><div class="line"></div><div class="line"><span class="keyword">await</span> page.keyboard.down(<span class="string">'Shift'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="string">' World'</span>.length; i++)</div><div class="line">  <span class="keyword">await</span> page.keyboard.press(<span class="string">'ArrowLeft'</span>);</div><div class="line"><span class="keyword">await</span> page.keyboard.up(<span class="string">'Shift'</span>);</div><div class="line"></div><div class="line"><span class="keyword">await</span> page.keyboard.press(<span class="string">'Backspace'</span>);</div><div class="line"><span class="comment">// Result text will end up saying 'Hello!'</span></div></pre></td></tr></table></figure></p><h2 id="类：Mouse"><a href="#类：Mouse" class="headerlink" title=" 类：Mouse"></a><a id="class-mouse"></a> 类：Mouse</h2><p>鼠标点击拖住事件。和键盘事件类似。</p><h2 id="类-Touchscreen"><a href="#类-Touchscreen" class="headerlink" title=" 类: Touchscreen"></a><a id="class-touchscreen"></a> 类: Touchscreen</h2><p>点击屏幕位置。<br><code>touchscreen.tap(x, y)</code></p><h2 id="类：Dialog"><a href="#类：Dialog" class="headerlink" title=" 类：Dialog"></a><a id="class-dialog"></a> 类：Dialog</h2><p>弹出框确认，取消以及相关的信息，输入都客气取得。</p><h2 id="类：ConsoleMessage"><a href="#类：ConsoleMessage" class="headerlink" title=" 类：ConsoleMessage"></a><a id="class-console-message"></a> 类：ConsoleMessage</h2><p>页面的console信息获取。</p><h2 id="类：Frame"><a href="#类：Frame" class="headerlink" title=" 类：Frame"></a><a id="class-frame"></a> 类：Frame</h2><p>大部分page都有Frame的方法，相当于<br><code>page.mainFrame()</code>。</p><p><code>frame.childFrame()</code>，<br><code>frame.name()</code>，<br><code>frame.parentFrame()</code>相关操作。属于frame的。</p><h2 id="类：ExecutionContext"><a href="#类：ExecutionContext" class="headerlink" title=" 类：ExecutionContext"></a><a id="class-execution-context"></a> 类：ExecutionContext</h2><p>类表示JavaScript执行的上下文。</p><h2 id="类：JSHandle"><a href="#类：JSHandle" class="headerlink" title=" 类：JSHandle"></a><a id="class-jshandle"></a> 类：JSHandle</h2><p>JSHandle表示页面中的JavaScript对象。JSHandles可以由page.evaluateHandle方法创建。</p><h2 id="类：ElementHandle"><a href="#类：ElementHandle" class="headerlink" title=" 类：ElementHandle"></a><a id="class-elementhandle"></a> 类：ElementHandle</h2><p>elementhandle代表一个页面的DOM元素。elementhandles可以 <code>page.$</code>由方法。</p><p><code>elementHandle.getProperties()</code><br><code>elementHandle.getProperty(propertyName)</code><br>获取元素的属性值, 爬取页面的url可用。</p><p><code>elementHandle.screenshot([options])</code>，<br>这个会将页面滚动到可以显示元素的地方，来截图。</p><p><code>elementHandle.uploadFile(...filePaths)</code>上出文件。</p><h2 id="类：Request"><a href="#类：Request" class="headerlink" title=" 类：Request"></a><a id="class-request"></a> 类：Request</h2><p>当一个页面发送一个request，puppeteer’s page会派发一下以下几个事件</p><ul><li>‘request’当页面发出请求时发出。</li><li>‘response’ 当响应请求接收到响应时发出。</li><li>‘requestfinished’ 当响应体被下载并请求完成时发出。</li></ul><h2 id="类：-Response"><a href="#类：-Response" class="headerlink" title=" 类： Response"></a><a id="class-response"></a> 类： Response</h2><p>响应类表示由页面接收的响应。</p><h1 id="api详情"><a href="#api详情" class="headerlink" title=" api详情"></a><a id="api-detail"></a> api详情</h1><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#overview" target="_blank" rel="noopener">Overview</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#environment-variables" target="_blank" rel="noopener">Environment Variables</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-puppeteer" target="_blank" rel="noopener">class: Puppeteer</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerconnectoptions" target="_blank" rel="noopener">puppeteer.connect(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerexecutablepath" target="_blank" rel="noopener">puppeteer.executablePath()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions" target="_blank" rel="noopener">puppeteer.launch([options])</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser" target="_blank" rel="noopener">class: Browser</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-disconnected" target="_blank" rel="noopener">event: ‘disconnected’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-targetchanged" target="_blank" rel="noopener">event: ‘targetchanged’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-targetcreated" target="_blank" rel="noopener">event: ‘targetcreated’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-targetdestroyed" target="_blank" rel="noopener">event: ‘targetdestroyed’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#browserclose" target="_blank" rel="noopener">browser.close()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#browserdisconnect" target="_blank" rel="noopener">browser.disconnect()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#browsernewpage" target="_blank" rel="noopener">browser.newPage()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#browserpages" target="_blank" rel="noopener">browser.pages()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#browsertargets" target="_blank" rel="noopener">browser.targets()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#browserversion" target="_blank" rel="noopener">browser.version()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#browserwsendpoint" target="_blank" rel="noopener">browser.wsEndpoint()</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-page" target="_blank" rel="noopener">class: Page</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-console" target="_blank" rel="noopener">event: ‘console’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-dialog" target="_blank" rel="noopener">event: ‘dialog’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-error" target="_blank" rel="noopener">event: ‘error’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-frameattached" target="_blank" rel="noopener">event: ‘frameattached’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-framedetached" target="_blank" rel="noopener">event: ‘framedetached’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-framenavigated" target="_blank" rel="noopener">event: ‘framenavigated’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-load" target="_blank" rel="noopener">event: ‘load’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-metrics" target="_blank" rel="noopener">event: ‘metrics’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-pageerror" target="_blank" rel="noopener">event: ‘pageerror’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-request" target="_blank" rel="noopener">event: ‘request’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-requestfailed" target="_blank" rel="noopener">event: ‘requestfailed’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-requestfinished" target="_blank" rel="noopener">event: ‘requestfinished’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-response" target="_blank" rel="noopener">event: ‘response’</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageselector" target="_blank" rel="noopener">page.$(selector)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageselector" target="_blank" rel="noopener">page.$$(selector)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevalselector-pagefunction-args" target="_blank" rel="noopener">page.$$eval(selector, pageFunction[, …args])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevalselector-pagefunction-args" target="_blank" rel="noopener">page.$eval(selector, pageFunction[, …args])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageaddscripttagoptions" target="_blank" rel="noopener">page.addScriptTag(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageaddstyletagoptions" target="_blank" rel="noopener">page.addStyleTag(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageauthenticatecredentials" target="_blank" rel="noopener">page.authenticate(credentials)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagebringtofront" target="_blank" rel="noopener">page.bringToFront()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageclickselector-options" target="_blank" rel="noopener">page.click(selector[, options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageclose" target="_blank" rel="noopener">page.close()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagecontent" target="_blank" rel="noopener">page.content()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagecookiesurls" target="_blank" rel="noopener">page.cookies(…urls)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagedeletecookiecookies" target="_blank" rel="noopener">page.deleteCookie(…cookies)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageemulateoptions" target="_blank" rel="noopener">page.emulate(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageemulatemediamediatype" target="_blank" rel="noopener">page.emulateMedia(mediaType)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevaluatepagefunction-args" target="_blank" rel="noopener">page.evaluate(pageFunction, …args)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevaluatehandlepagefunction-args" target="_blank" rel="noopener">page.evaluateHandle(pageFunction, …args)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevaluateonnewdocumentpagefunction-args" target="_blank" rel="noopener">page.evaluateOnNewDocument(pageFunction, …args)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageexposefunctionname-puppeteerfunction" target="_blank" rel="noopener">page.exposeFunction(name, puppeteerFunction)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagefocusselector" target="_blank" rel="noopener">page.focus(selector)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageframes" target="_blank" rel="noopener">page.frames()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagegobackoptions" target="_blank" rel="noopener">page.goBack(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagegoforwardoptions" target="_blank" rel="noopener">page.goForward(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagegotourl-options" target="_blank" rel="noopener">page.goto(url, options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagehoverselector" target="_blank" rel="noopener">page.hover(selector)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagekeyboard" target="_blank" rel="noopener">page.keyboard</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagemainframe" target="_blank" rel="noopener">page.mainFrame()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagemetrics" target="_blank" rel="noopener">page.metrics()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagemouse" target="_blank" rel="noopener">page.mouse</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagepdfoptions" target="_blank" rel="noopener">page.pdf(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagequeryobjectsprototypehandle" target="_blank" rel="noopener">page.queryObjects(prototypeHandle)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagereloadoptions" target="_blank" rel="noopener">page.reload(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagescreenshotoptions" target="_blank" rel="noopener">page.screenshot([options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageselectselector-values" target="_blank" rel="noopener">page.select(selector, …values)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetcontenthtml" target="_blank" rel="noopener">page.setContent(html)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetcookiecookies" target="_blank" rel="noopener">page.setCookie(…cookies)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetextrahttpheadersheaders" target="_blank" rel="noopener">page.setExtraHTTPHeaders(headers)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetjavascriptenabledenabled" target="_blank" rel="noopener">page.setJavaScriptEnabled(enabled)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetofflinemodeenabled" target="_blank" rel="noopener">page.setOfflineMode(enabled)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetrequestinterceptionvalue" target="_blank" rel="noopener">page.setRequestInterception(value)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetuseragentuseragent" target="_blank" rel="noopener">page.setUserAgent(userAgent)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetviewportviewport" target="_blank" rel="noopener">page.setViewport(viewport)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagetapselector" target="_blank" rel="noopener">page.tap(selector)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagetitle" target="_blank" rel="noopener">page.title()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagetouchscreen" target="_blank" rel="noopener">page.touchscreen</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagetracing" target="_blank" rel="noopener">page.tracing</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagetypeselector-text-options" target="_blank" rel="noopener">page.type(selector, text[, options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageurl" target="_blank" rel="noopener">page.url()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageviewport" target="_blank" rel="noopener">page.viewport()</a></li><li>[page.waitFor(selectorOrFunctionOrTimeout<a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagewaitforselectororfunctionortimeout-options-args" target="_blank" rel="noopener">, options[, …args]])</a></li><li>[page.waitForFunction(pageFunction<a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagewaitforfunctionpagefunction-options-args" target="_blank" rel="noopener">, options[, …args]])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagewaitfornavigationoptions" target="_blank" rel="noopener">page.waitForNavigation(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagewaitforselectorselector-options" target="_blank" rel="noopener">page.waitForSelector(selector[, options])</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-keyboard" target="_blank" rel="noopener">class: Keyboard</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#keyboarddownkey-options" target="_blank" rel="noopener">keyboard.down(key[, options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#keyboardpresskey-options" target="_blank" rel="noopener">keyboard.press(key[, options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#keyboardsendcharacterchar" target="_blank" rel="noopener">keyboard.sendCharacter(char)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#keyboardtypetext-options" target="_blank" rel="noopener">keyboard.type(text, options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#keyboardupkey" target="_blank" rel="noopener">keyboard.up(key)</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-mouse" target="_blank" rel="noopener">class: Mouse</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#mouseclickx-y-options" target="_blank" rel="noopener">mouse.click(x, y, [options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#mousedownoptions" target="_blank" rel="noopener">mouse.down([options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#mousemovex-y-options" target="_blank" rel="noopener">mouse.move(x, y, [options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#mouseupoptions" target="_blank" rel="noopener">mouse.up([options])</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-touchscreen" target="_blank" rel="noopener">class: Touchscreen</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#touchscreentapx-y" target="_blank" rel="noopener">touchscreen.tap(x, y)</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-tracing" target="_blank" rel="noopener">class: Tracing</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#tracingstartoptions" target="_blank" rel="noopener">tracing.start(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#tracingstop" target="_blank" rel="noopener">tracing.stop()</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-dialog" target="_blank" rel="noopener">class: Dialog</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#dialogacceptprompttext" target="_blank" rel="noopener">dialog.accept([promptText])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#dialogdefaultvalue" target="_blank" rel="noopener">dialog.defaultValue()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#dialogdismiss" target="_blank" rel="noopener">dialog.dismiss()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#dialogmessage" target="_blank" rel="noopener">dialog.message()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#dialogtype" target="_blank" rel="noopener">dialog.type</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-consolemessage" target="_blank" rel="noopener">class: ConsoleMessage</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#consolemessageargs" target="_blank" rel="noopener">consoleMessage.args</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#consolemessagetext" target="_blank" rel="noopener">consoleMessage.text</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#consolemessagetype" target="_blank" rel="noopener">consoleMessage.type</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-frame" target="_blank" rel="noopener">class: Frame</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameselector" target="_blank" rel="noopener">frame.$(selector)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameselector" target="_blank" rel="noopener">frame.$$(selector)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameevalselector-pagefunction-args" target="_blank" rel="noopener">frame.$$eval(selector, pageFunction[, …args])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameevalselector-pagefunction-args" target="_blank" rel="noopener">frame.$eval(selector, pageFunction[, …args])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameaddscripttagoptions" target="_blank" rel="noopener">frame.addScriptTag(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameaddstyletagoptions" target="_blank" rel="noopener">frame.addStyleTag(options)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#framechildframes" target="_blank" rel="noopener">frame.childFrames()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameevaluatepagefunction-args" target="_blank" rel="noopener">frame.evaluate(pageFunction, …args)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameexecutioncontext" target="_blank" rel="noopener">frame.executionContext()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameisdetached" target="_blank" rel="noopener">frame.isDetached()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#framename" target="_blank" rel="noopener">frame.name()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameparentframe" target="_blank" rel="noopener">frame.parentFrame()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameselectselector-values" target="_blank" rel="noopener">frame.select(selector, …values)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frametitle" target="_blank" rel="noopener">frame.title()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#frameurl" target="_blank" rel="noopener">frame.url()</a></li><li>[frame.waitFor(selectorOrFunctionOrTimeout<a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#framewaitforselectororfunctionortimeout-options-args" target="_blank" rel="noopener">, options[, …args]])</a></li><li>[frame.waitForFunction(pageFunction<a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#framewaitforfunctionpagefunction-options-args" target="_blank" rel="noopener">, options[, …args]])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#framewaitforselectorselector-options" target="_blank" rel="noopener">frame.waitForSelector(selector[, options])</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-executioncontext" target="_blank" rel="noopener">class: ExecutionContext</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#executioncontextevaluatepagefunction-args" target="_blank" rel="noopener">executionContext.evaluate(pageFunction, …args)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#executioncontextevaluatehandlepagefunction-args" target="_blank" rel="noopener">executionContext.evaluateHandle(pageFunction, …args)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#executioncontextqueryobjectsprototypehandle" target="_blank" rel="noopener">executionContext.queryObjects(prototypeHandle)</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-jshandle" target="_blank" rel="noopener">class: JSHandle</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#jshandleaselement" target="_blank" rel="noopener">jsHandle.asElement()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#jshandledispose" target="_blank" rel="noopener">jsHandle.dispose()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#jshandleexecutioncontext" target="_blank" rel="noopener">jsHandle.executionContext()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#jshandlegetproperties" target="_blank" rel="noopener">jsHandle.getProperties()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#jshandlegetpropertypropertyname" target="_blank" rel="noopener">jsHandle.getProperty(propertyName)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#jshandlejsonvalue" target="_blank" rel="noopener">jsHandle.jsonValue()</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-elementhandle" target="_blank" rel="noopener">class: ElementHandle</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandleselector" target="_blank" rel="noopener">elementHandle.$(selector)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandleselector" target="_blank" rel="noopener">elementHandle.$$(selector)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandleaselement" target="_blank" rel="noopener">elementHandle.asElement()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandleboundingbox" target="_blank" rel="noopener">elementHandle.boundingBox()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandleclickoptions" target="_blank" rel="noopener">elementHandle.click([options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandledispose" target="_blank" rel="noopener">elementHandle.dispose()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandleexecutioncontext" target="_blank" rel="noopener">elementHandle.executionContext()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandlefocus" target="_blank" rel="noopener">elementHandle.focus()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandlegetproperties" target="_blank" rel="noopener">elementHandle.getProperties()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandlegetpropertypropertyname" target="_blank" rel="noopener">elementHandle.getProperty(propertyName)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandlehover" target="_blank" rel="noopener">elementHandle.hover()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandlejsonvalue" target="_blank" rel="noopener">elementHandle.jsonValue()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandlepresskey-options" target="_blank" rel="noopener">elementHandle.press(key[, options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandlescreenshotoptions" target="_blank" rel="noopener">elementHandle.screenshot([options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandletap" target="_blank" rel="noopener">elementHandle.tap()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandletostring" target="_blank" rel="noopener">elementHandle.toString()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandletypetext-options" target="_blank" rel="noopener">elementHandle.type(text[, options])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#elementhandleuploadfilefilepaths" target="_blank" rel="noopener">elementHandle.uploadFile(…filePaths)</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-request" target="_blank" rel="noopener">class: Request</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#requestaborterrorcode" target="_blank" rel="noopener">request.abort([errorCode])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#requestcontinueoverrides" target="_blank" rel="noopener">request.continue([overrides])</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#requestfailure" target="_blank" rel="noopener">request.failure()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#requestheaders" target="_blank" rel="noopener">request.headers</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#requestmethod" target="_blank" rel="noopener">request.method</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#requestpostdata" target="_blank" rel="noopener">request.postData</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#requestresourcetype" target="_blank" rel="noopener">request.resourceType</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#requestrespondresponse" target="_blank" rel="noopener">request.respond(response)</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#requestresponse" target="_blank" rel="noopener">request.response()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#requesturl" target="_blank" rel="noopener">request.url</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-response" target="_blank" rel="noopener">class: Response</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#responsebuffer" target="_blank" rel="noopener">response.buffer()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#responseheaders" target="_blank" rel="noopener">response.headers</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#responsejson" target="_blank" rel="noopener">response.json()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#responseok" target="_blank" rel="noopener">response.ok</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#responserequest" target="_blank" rel="noopener">response.request()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#responsestatus" target="_blank" rel="noopener">response.status</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#responsetext" target="_blank" rel="noopener">response.text()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#responseurl" target="_blank" rel="noopener">response.url</a></li></ul></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-target" target="_blank" rel="noopener">class: Target</a><ul><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#targetpage" target="_blank" rel="noopener">target.page()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#targettype" target="_blank" rel="noopener">target.type()</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#targeturl" target="_blank" rel="noopener">target.url()</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述Puppeteer&quot;&gt;&lt;a href=&quot;#概述Puppeteer&quot; class=&quot;headerlink&quot; title=&quot; 概述Puppeteer&quot;&gt;&lt;/a&gt;&lt;a id=&quot;instruction-puppeteer&quot;&gt;&lt;/a&gt; 概述Puppeteer&lt;/h1&gt;&lt;p&gt;Puppeteer 是一个用来控制无界面Chrome的Node库，它提供了很多高级的api来使我们跟好的控制无界面的Chrome。这个headless可以叫无头，也可以叫无界面吧&lt;br&gt;
    
    </summary>
    
      <category term="Puppeteer" scheme="https://hddhyq.github.io/categories/Puppeteer/"/>
    
    
      <category term="chrome" scheme="https://hddhyq.github.io/tags/chrome/"/>
    
      <category term="Puppeteer" scheme="https://hddhyq.github.io/tags/Puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>express后续篇</title>
    <link href="https://hddhyq.github.io/2017/11/12/express%E5%90%8E%E7%BB%AD%E7%AF%87/"/>
    <id>https://hddhyq.github.io/2017/11/12/express后续篇/</id>
    <published>2017-11-12T12:27:42.000Z</published>
    <updated>2018-07-08T04:25:55.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h1><h2 id="在-Express-中使用模板引擎"><a href="#在-Express-中使用模板引擎" class="headerlink" title="在 Express 中使用模板引擎"></a>在 Express 中使用模板引擎</h2><p>需要在应用中设置模板文件目录views，设置模板引擎view engine<br><a id="more"></a></p><ul><li>views, 放模板文件的目录，比如： app.set(‘views’, ‘./views’)</li><li>view engine, 模板引擎，比如： app.set(‘view engine’, ‘jade’)</li></ul><p>如上例，我们用了jade模板语言，那么我们对应的需要npm相关的软件包<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install jade --save</div></pre></td></tr></table></figure></p><blockquote><p>和 Express 兼容的模板引擎，比如 Jade，通过 res.render() 调用其导出方法 __express(filePath, options, callback) 渲染模板。</p><p>有一些模板引擎不遵循这种约定，Consolidate.js 能将 Node 中所有流行的模板引擎映射为这种约定，这样就可以和 Express 无缝衔接。</p></blockquote><p>一旦 view engine 设置成功，就不需要显式指定引擎，或者在应用中加载模板引擎模块，Express 已经在内部加载，如下所示。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'jade'</span>);</div></pre></td></tr></table></figure></p><p>现在我们在views目录下创建名字为index.jade的Jade模板文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">html</div><div class="line">  head</div><div class="line">    title!= title</div><div class="line">  body</div><div class="line">    h1!= message</div></pre></td></tr></table></figure></p><p>然后创建一个路由来渲染index.jade文件。如果没有设置 view engine，您需要指明视图文件的后缀，否则就会遗漏它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.render(<span class="string">'index'</span>, &#123; <span class="attr">title</span>: <span class="string">'Hey'</span>, <span class="attr">message</span>: <span class="string">'Hello there!'</span>&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>此时向主页发送请求，“index.jade” 会被渲染为 HTML。</p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>错误处理的函数形式相当于其他的中间件的<code>callback(req, res, next)</code>，它需要四个参数<code>(err, req, res, next)</code>,例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(error.stack)</div><div class="line">  res.status(<span class="number">500</span>).send(<span class="string">'Something broke!'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>它的位置则在<code>app.use()</code>和路由调用后，最后定义错误处理中间件，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</div><div class="line"><span class="keyword">var</span> methodOverride = <span class="built_in">require</span>(<span class="string">'method-override'</span>);</div><div class="line"></div><div class="line">app.use(bodyParser());</div><div class="line">app.use(methodOverride());</div><div class="line"><span class="comment">// ...路由</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</div><div class="line">  <span class="comment">// 业务逻辑</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>中间件返回的响应是随意的，可以响应一个HTML错误页面、一句简单的话、一个JSON字符串、或者其他你想要的任何东西，这也就加强了对于错误的自己定义化的做法。</p><p>为了便于组织，可能会想定义常规中间件一样定制多个错误处理中间件，加强项目的逻辑性。</p><p>比如你想为使用XHR的请求定义一个，还想为没有使用的定义一个，那么：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</div><div class="line"><span class="keyword">var</span> methodOverride = <span class="built_in">require</span>(<span class="string">'method-override'</span>);</div><div class="line"></div><div class="line">app.use(bodyParser());</div><div class="line">app.use(methodOverride());</div><div class="line">app.use(logErrors);</div><div class="line">app.use(clientErrorHandler);</div><div class="line">app.use(errorHndler);</div></pre></td></tr></table></figure></p><p>logErrors会将请求和错误信息写入标准错误输出、日志或类似服务：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logErrors</span>(<span class="params">err, req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(err.stack);</div><div class="line">  next(err);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>clientErrorHandler 的定义如下（注意这里将错误直接传给了 next）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clientErrorHandler</span>(<span class="params">err, req, res, next</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (req.xhr) &#123;</div><div class="line">    res.status(<span class="number">500</span>).send(&#123; <span class="attr">error</span>: <span class="string">'Something blew up!'</span> &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    next(err);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>errorHandler 能捕获所有错误，其定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">err, req, res, next</span>) </span>&#123;</div><div class="line">  res.status(<span class="number">500</span>);</div><div class="line">  res.render(<span class="string">'error'</span>, &#123; <span class="attr">error</span>: err &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>错误处理的next() 传入参数（除了 ‘route’ 字符串），express会认为当前请求有错误的输出，会跳到下一个错误处理的中间件。</p><p>如下节所示。</p><p>如果路由句柄有多个回调函数，可使用 ‘route’ 参数跳到下一个路由句柄。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/a_route_behind_paywall'</span>, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkIfPaidSubscriber</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!req.user.hasPaid) &#123; </div><div class="line">    </div><div class="line">      <span class="comment">// 继续处理该请求</span></div><div class="line">      next(<span class="string">'route'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">getPaidContent</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    PaidContent.find(<span class="function"><span class="keyword">function</span>(<span class="params">err, doc</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span>(err) <span class="keyword">return</span> next(err);</div><div class="line">      res.json(doc);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>在这个例子中，句柄 getPaidContent 会被跳过，但 app 中为 /a_route_behind_paywall 定义的其他句柄则会继续执行。</p><blockquote><p>next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄。</p></blockquote><h2 id="缺省错误处理句柄"><a href="#缺省错误处理句柄" class="headerlink" title="缺省错误处理句柄"></a>缺省错误处理句柄</h2><p>Express 内置了一个错误处理句柄，它可以捕获应用中可能出现的任意错误。这个缺省的错误处理中间件将被添加到中间件堆栈的底部。</p><p>如果你向 next() 传递了一个 error ，而你并没有在错误处理句柄中处理这个 error，Express 内置的缺省错误处理句柄就是最后兜底的。最后错误将被连同堆栈追踪信息一同反馈到客户端。堆栈追踪信息并不会在生产环境中反馈到客户端。</p><blockquote><p>设置环境变量 NODE_ENV 为 “production” 就可以让应用运行在生产环境模式下。</p></blockquote><p>如果你已经开始向 response 输出数据了，这时才调用 next() 并传递了一个 error，比如你在将向客户端输出数据流时遇到一个错误，Express 内置的缺省错误处理句柄将帮你关闭连接并告知 request 请求失败。</p><p>因此，当你添加了一个自定义的错误处理句柄后，如果已经向客户端发送包头信息了，你还可以将错误处理交给 Express 内置的错误处理机制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">err, req, res, next</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (res.headersSent) &#123;</div><div class="line">    <span class="keyword">return</span> next(err);</div><div class="line">  &#125;</div><div class="line">  res.status(<span class="number">500</span>);</div><div class="line">  res.render(<span class="string">'error'</span>, &#123; <span class="attr">error</span>: err &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="调试-Express"><a href="#调试-Express" class="headerlink" title="调试 Express"></a>调试 Express</h1><p>Express 内部使用 debug 模块记录路由匹配、使用到的中间件、应用模式以及请求-响应循环。</p><blockquote><p>debug 有点像改装过的 console.log，不同的是，您不需要在生产代码中注释掉 debug。它会默认关闭，而且使用一个名为 DEBUG 的环境变量还可以打开。</p></blockquote><p>在启动应用时，设置 DEBUG 环境变量为 express:*，可以查看 Express 中用到的所有内部日志。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DEBUG=express:* node index.js</div></pre></td></tr></table></figure></p><p>在由 express 应用生成器 生成的默认应用中执行，会打印出如下信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">test</span>-express@1.0.0 <span class="built_in">test</span> /home/hdd/练习/express</div><div class="line">&gt; node app.js</div><div class="line"></div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"x-powered-by"</span> to <span class="literal">true</span> +0ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"etag"</span> to <span class="string">'weak'</span> +4ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"etag fn"</span> to [Function:generateETag] +1ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"env"</span> to <span class="string">'development'</span> +1ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"query parser"</span> to <span class="string">'extended'</span> +0ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"query parser fn"</span> to [Function: parseExtendedQueryString] +0ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"subdomain offset"</span> to 2+0ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"trust proxy"</span> to <span class="literal">false</span> +0ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"trust proxy fn"</span> to [Function: trustNone] +1ms</div><div class="line">  express:application booting <span class="keyword">in</span> development mode+0ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"view"</span> to [Function: View] +0ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"views"</span> to <span class="string">'/home/hdd/练习/express/views'</span> +0ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"jsonp callback name"</span> to <span class="string">'callback'</span> +0ms</div><div class="line">  express:application <span class="built_in">set</span> <span class="string">"view engine"</span> to <span class="string">'jade'</span>+0ms</div><div class="line">  express:router use <span class="string">'/'</span> query +1ms</div><div class="line">  express:router:layer new <span class="string">'/'</span> +0ms</div><div class="line">  express:router use <span class="string">'/'</span> expressInit +1ms</div><div class="line">  express:router:layer new <span class="string">'/'</span> +0ms</div><div class="line">  express:router:route new <span class="string">'/'</span> +0ms</div><div class="line">  express:router:layer new <span class="string">'/'</span> +0ms</div><div class="line">  express:router:route get <span class="string">'/'</span> +1ms</div><div class="line">  express:router:layer new <span class="string">'/'</span> +0ms</div></pre></td></tr></table></figure></p><p>当应用收到请求时，能看到Express代码中打印出的日志。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">express:router dispatching GET / +5s</div><div class="line">  express:router query  : / +1ms</div><div class="line">  express:router expressInit  : / +1ms</div><div class="line">  express:view require <span class="string">"jade"</span> +2ms</div><div class="line">  express:view lookup <span class="string">"index.jade"</span> +564ms</div><div class="line">  express:view <span class="built_in">stat</span> <span class="string">"/home/hdd/练习/express/views/index.jade"</span> +1ms</div><div class="line">  express:view render <span class="string">"/home/hdd/练习/express/views/index.jade"</span> +0ms</div><div class="line">  express:router dispatching GET /favicon.ico +245ms</div><div class="line">  express:router query  : /favicon.ico +0ms</div><div class="line">  express:router expressInit  : /favicon.ico +1ms</div></pre></td></tr></table></figure></p><p>设置 DEBUG 的值为 express:router，只查看路由部分的日志；设置 DEBUG 的值为 express:application，只查看应用部分的日志，依此类推。</p><h2 id="通过-express-生成应用"><a href="#通过-express-生成应用" class="headerlink" title="通过 express 生成应用"></a>通过 express 生成应用</h2><p>将命名空间限制其中<br>需要添加<code>DEBUG=ITEM-NAME</code><br>详见 <a href="https://github.com/visionmedia/debug" target="_blank" rel="noopener">调试指南</a></p><h1 id="数据库集成"><a href="#数据库集成" class="headerlink" title="数据库集成"></a>数据库集成</h1><p>为 Express 应用添加连接数据库的能力，只需要加载相应数据库的 Node.js 驱动即可。</p><p>介绍下常见数据库驱动</p><ul><li>Cassandra</li><li>CouchDB</li><li>LevelDB</li><li>MySQL</li><li>MongoDB</li><li>Neo4j</li><li>PostgreSQL</li><li>Redis</li><li>SQLite</li><li>ElasticSearch</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模板引擎&quot;&gt;&lt;a href=&quot;#模板引擎&quot; class=&quot;headerlink&quot; title=&quot;模板引擎&quot;&gt;&lt;/a&gt;模板引擎&lt;/h1&gt;&lt;h2 id=&quot;在-Express-中使用模板引擎&quot;&gt;&lt;a href=&quot;#在-Express-中使用模板引擎&quot; class=&quot;headerlink&quot; title=&quot;在 Express 中使用模板引擎&quot;&gt;&lt;/a&gt;在 Express 中使用模板引擎&lt;/h2&gt;&lt;p&gt;需要在应用中设置模板文件目录views，设置模板引擎view engine&lt;br&gt;
    
    </summary>
    
      <category term="express" scheme="https://hddhyq.github.io/categories/express/"/>
    
    
      <category term="node" scheme="https://hddhyq.github.io/tags/node/"/>
    
      <category term="express" scheme="https://hddhyq.github.io/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>了解下Express</title>
    <link href="https://hddhyq.github.io/2017/11/11/%E4%BA%86%E8%A7%A3%E4%B8%8BExpress/"/>
    <id>https://hddhyq.github.io/2017/11/11/了解下Express/</id>
    <published>2017-11-11T12:34:18.000Z</published>
    <updated>2018-07-08T04:25:55.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由"><a href="#路由" class="headerlink" title=" 路由"></a><a id="route"></a> 路由</h1><p>虽说第一项是路由。不过首先，还是应该安装一下express。<br><a id="more"></a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install express --save</div></pre></td></tr></table></figure></p><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title=" 什么是路由"></a><a id="what-is-router"></a> 什么是路由</h2><p>路由是定义应用请求的URLs以及响应客户端的请求。结构如下：<code>app.METHOD(path, [callback...], callback)</code>  其中app是express的一个实例, METHOD是一个HTTP请求方法, callback是当路径匹配时要执行的函数。</p><p>示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</div><div class="line">  res.send(<span class="string">'hello world'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'服务开始在3000端口'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h2 id="路由方法"><a href="#路由方法" class="headerlink" title=" 路由方法"></a><a id="method-router"></a> 路由方法</h2><p>路由方法源自HTTP请求方法。</p><p>Express定义了以下与HTTP对应的方法：get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search和connect。<br>其中JS不合法的需要使用括号记法，比如：<code>app[&#39;m-search&#39;].(&#39;/&#39;, callback...)</code></p><p><code>app.all</code> 也是method,它匹配的任何HTTP请求，句柄都会执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">app.all(<span class="string">'/secret'</span>, (req, res, next) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'handle the secret!'</span>)</div><div class="line">  next() <span class="comment">// 处理写一个句柄，相当于promise中的promise.resolve()</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h2 id="路由路径"><a href="#路由路径" class="headerlink" title=" 路由路径"></a><a id="path-router"></a> 路由路径</h2><p>路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。根据精确度排序匹配率排序 字符串&gt;字符串模式&gt;正则表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 字符串</span></div><div class="line">app.get(<span class="string">'/about'</span>, (req, res) =&gt; &#123;</div><div class="line">  res.send(<span class="string">'about'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 字符串模式</span></div><div class="line">app.get(<span class="string">'/ab*ut'</span>, (req. res) =&gt; &#123;</div><div class="line">  res.send(<span class="string">'ab*ut'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 字符?,+,*和()是正则表达式的子集、在基于字符串的路径按照字面值解释。</span></div><div class="line"></div><div class="line"><span class="comment">// 正则表达式</span></div><div class="line">app.get(<span class="regexp">/ab/</span>, (req, res) =&gt; &#123;</div><div class="line">  res.send(<span class="string">'/ab/'</span>) <span class="comment">// 匹配任何含有ab的路径</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="路由句柄"><a href="#路由句柄" class="headerlink" title=" 路由句柄"></a><a id="next-router"></a> 路由句柄</h2><p>可以为请求处理提供多个回调函数，行为类似中间件。唯一的区别，这些回调函数可能通过<code>next(&#39;route&#39;)</code>方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径继续执行没有意义，则可将控制权交给剩下的路径。</p><p>路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合，如下所示.</p><p>使用多个回调函数处理路由（记得指定 next 对象）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/example/b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'response will be sent by the next function ...'</span>);</div><div class="line">  next();</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'Hello from B!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>使用回调函数数组处理路由：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cb0 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'CB0'</span>);</div><div class="line">  next();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cb1 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'CB1'</span>);</div><div class="line">  next();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cb2 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'Hello from C!'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">app.get(<span class="string">'/example/c'</span>, [cb0, cb1, cb2]);</div></pre></td></tr></table></figure></p><h2 id="响应方法"><a href="#响应方法" class="headerlink" title=" 响应方法"></a><a id="callback-router"></a> 响应方法</h2><p>下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.expressjs.com.cn/4x/api.html#res.download" target="_blank" rel="noopener">res.download()</a></td><td>提示下载文件。</td></tr><tr><td><a href="http://www.expressjs.com.cn/4x/api.html#res.end" target="_blank" rel="noopener">res.end()</a></td><td>终结响应处理流程。</td></tr><tr><td><a href="http://www.expressjs.com.cn/4x/api.html#res.json" target="_blank" rel="noopener">res.json()</a></td><td>发送一个 JSON 格式的响应。</td></tr><tr><td><a href="http://www.expressjs.com.cn/4x/api.html#res.jsonp" target="_blank" rel="noopener">res.jsonp()</a></td><td>发送一个支持 JSONP 的 JSON 格式的响应。</td></tr><tr><td><a href="http://www.expressjs.com.cn/4x/api.html#res.redirect" target="_blank" rel="noopener">res.redirect()</a></td><td>重定向请求。</td></tr><tr><td><a href="http://www.expressjs.com.cn/4x/api.html#res.render" target="_blank" rel="noopener">res.render()</a></td><td>渲染视图模板。</td></tr><tr><td><a href="http://www.expressjs.com.cn/4x/api.html#res.send" target="_blank" rel="noopener">res.send()</a></td><td>发送各种类型的响应。</td></tr><tr><td><a href="http://www.expressjs.com.cn/4x/api.html#res.sendFile" target="_blank" rel="noopener">res.sendFile</a></td><td>以八位字节流的形式发送文件。</td></tr><tr><td><a href="http://www.expressjs.com.cn/4x/api.html#res.sendStatus" target="_blank" rel="noopener">res.sendStatus()</a></td><td>设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</td></tr><tr><td></td></tr></tbody></table><h2 id="app-route"><a href="#app-route" class="headerlink" title=" app.route()"></a><a id="appRoute"></a> app.route()</h2><p>可使用 app.route() 创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。<br>对于同一个路径不同method的链式路由句柄<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">app.route(<span class="string">'/book'</span>)</div><div class="line">  .get(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    res.send(<span class="string">'Get a random book'</span>);</div><div class="line">  &#125;)</div><div class="line">  .post(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    res.send(<span class="string">'Add a book'</span>);</div><div class="line">  &#125;)</div><div class="line">  .put(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    res.send(<span class="string">'Update the book'</span>);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p><h2 id="express-Router"><a href="#express-Router" class="headerlink" title=" express.Router"></a><a id="expressRouter"></a> express.Router</h2><p>可使用 express.Router 类创建模块化、可挂载的路由句柄。Router 实例是一个完整的中间件和路由系统，因此常称其为一个 “mini-app”。</p><p>在 app 目录下创建名为 birds.js 的文件，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> router = express.Router();</div><div class="line"></div><div class="line"><span class="comment">// 该路由使用的中间件</span></div><div class="line">router.use(<span class="function"><span class="keyword">function</span> <span class="title">timeLog</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Time: '</span>, <span class="built_in">Date</span>.now());</div><div class="line">  next();</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 定义网站主页的路由</span></div><div class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'Birds home page'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 定义 about 页面的路由</span></div><div class="line">router.get(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'About birds'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = router;</div></pre></td></tr></table></figure><p>然后在应用中加载路由模块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> birds = <span class="built_in">require</span>(<span class="string">'./birds'</span>);</div><div class="line">...</div><div class="line">app.use(<span class="string">'/birds'</span>, birds);</div></pre></td></tr></table></figure></p><p>应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。</p><h1 id="中间件"><a href="#中间件" class="headerlink" title=" 中间件"></a><a id="middleware"></a> 中间件</h1><p>Express框架实现功能就相当于在调用相关的中间件（Middleware），它可访问request和response<br>它的功能包括：</p><ul><li>执行任何代码。</li><li>修改请求和响应对象。</li><li>终结请求-响应循环。</li><li>调用堆栈中的下一个中间件。</li></ul><p>如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。</p><p>Express 应用可使用如下几种中间件：</p><ul><li>应用级中间件</li><li>路由级中间件</li><li>错误处理中间件</li><li>内置中间件</li><li>第三方中间件</li></ul><h2 id="应用级中间件"><a href="#应用级中间件" class="headerlink" title=" 应用级中间件"></a><a id="app-middleware"></a> 应用级中间件</h2><p>应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求</span></div><div class="line">app.get(<span class="string">'/user/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'USER'</span>);</div><div class="line">&#125;); <span class="comment">// :id 由req.params.id 来获取</span></div></pre></td></tr></table></figure></p><p>调用<code>next(&#39;route&#39;)</code>时，会跳过剩余中间件</p><p>如果需要在中间件栈中跳过剩余中间件，调用 next(‘route’) 方法将控制权交给下一个路由。 <strong>注意：</strong> next(‘route’) 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个中间件栈，处理指向 /user/:id 的 GET 请求</span></div><div class="line">app.get(<span class="string">'/user/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果 user id 为 0, 跳到下一个路由</span></div><div class="line">  <span class="keyword">if</span> (req.params.id == <span class="number">0</span>) next(<span class="string">'route'</span>);</div><div class="line">  <span class="comment">// 否则将控制权交给栈中下一个中间件</span></div><div class="line">  <span class="keyword">else</span> next(); <span class="comment">//</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="comment">// 渲染常规页面</span></div><div class="line">  res.render(<span class="string">'regular'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 处理 /user/:id， 渲染一个特殊页面</span></div><div class="line">app.get(<span class="string">'/user/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  res.render(<span class="string">'special'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="路由级中间件"><a href="#路由级中间件" class="headerlink" title=" 路由级中间件"></a><a id="router-middleware"></a> 路由级中间件</h2><p>路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。</p><h2 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title=" 错误处理中间件"></a><a id="error-handle-middleware"></a> 错误处理中间件</h2><blockquote><p>错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。</p></blockquote><p>错误处理中间件和其他中间件定义类似，只是要使用 4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(err.stack);</div><div class="line">  res.status(<span class="number">500</span>).send(<span class="string">'Something broke!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="内置中间件"><a href="#内置中间件" class="headerlink" title=" 内置中间件"></a><a id="in-middleware"></a> 内置中间件</h2><p>内置中间件只有一个<code>express.static</code> 。负责Express应用中托管静态资源。用法： <code>express.static(root, [options])</code></p><p>可选options：<br>|属性|描述|类型|缺省值|<br>|—-|—|—|—–|<br>|dotfiles|是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore”|String|“ignore”|<br>|etag|是否启用 etag 生成|Boolean|true|<br>|extensions|设置文件扩展名备份选项|Array|[]|<br>|index|发送目录索引文件，设置为 false 禁用目录索引。|Mixed|“index.html”|<br>|lastModified|设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false。|Boolean|true|<br>|maxAge|以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性。|Number|0|<br>|redirect|当路径为目录时，重定向至 “/”。|Boolean|true|<br>|setHeaders|设置 HTTP 头以提供文件的函数。|Function||</p><p>下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  dotfiles: <span class="string">'ignore'</span>,</div><div class="line">  etag: <span class="literal">false</span>,</div><div class="line">  extensions: [<span class="string">'htm'</span>, <span class="string">'html'</span>],</div><div class="line">  index: <span class="literal">false</span>,</div><div class="line">  maxAge: <span class="string">'1d'</span>,</div><div class="line">  redirect: <span class="literal">false</span>,</div><div class="line">  setHeaders: <span class="function"><span class="keyword">function</span> (<span class="params">res, path, stat</span>) </span>&#123;</div><div class="line">    res.set(<span class="string">'x-timestamp'</span>, <span class="built_in">Date</span>.now());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">app.use(express.static(<span class="string">'public'</span>, options));</div></pre></td></tr></table></figure></p><p>每个应用可有多个静态目录。当然也可以分别设置options。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.use(express.static(<span class="string">'public'</span>));</div><div class="line">app.use(express.static(<span class="string">'uploads'</span>));</div><div class="line">app.use(express.static(<span class="string">'files'</span>));</div></pre></td></tr></table></figure><p>更多关于 serve-static 和其参数的信息，请参考 <a href="https://github.com/expressjs/serve-static" target="_blank" rel="noopener">serve-static</a> 文档。</p><h2 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title=" 第三方中间件"></a><a id="out-middleware"></a> 第三方中间件</h2><p>通过使用第三方中间件从而为 Express 应用增加更多功能。</p><p>安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。</p><p>下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install cookie-parser</div></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 加载用于解析 cookie 的中间件</span></div><div class="line">app.use(cookieParser());</div></pre></td></tr></table></figure><p>请参考 <a href="http://www.expressjs.com.cn/resources/middleware.html" target="_blank" rel="noopener">第三方中间件</a> 获取 Express 中经常用到的第三方中间件列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot; title=&quot; 路由&quot;&gt;&lt;/a&gt;&lt;a id=&quot;route&quot;&gt;&lt;/a&gt; 路由&lt;/h1&gt;&lt;p&gt;虽说第一项是路由。不过首先，还是应该安装一下express。&lt;br&gt;
    
    </summary>
    
      <category term="express" scheme="https://hddhyq.github.io/categories/express/"/>
    
    
      <category term="node" scheme="https://hddhyq.github.io/tags/node/"/>
    
      <category term="express" scheme="https://hddhyq.github.io/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>socket.io简易用法</title>
    <link href="https://hddhyq.github.io/2017/11/06/socket.io%E7%AE%80%E6%98%93%E7%94%A8%E6%B3%95/"/>
    <id>https://hddhyq.github.io/2017/11/06/socket.io简易用法/</id>
    <published>2017-11-06T12:12:41.000Z</published>
    <updated>2018-07-08T04:25:55.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍Socket-io"><a href="#介绍Socket-io" class="headerlink" title=" 介绍Socket.io"></a><a id="toc-introduce"></a> 介绍Socket.io</h1><p>Socket.IO 是一个面向实时 web 应用的 JavaScript 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在浏览器中运行的客户端库，和一个面向Node.js的服务端库。两者有着几乎一样的API。像Node.js一样，它也是事件驱动的.<br><a id="more"></a></p><p>Socket.IO主要使用WebSocket协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如Adobe Flash Sockets，JSONP拉取，或是传统的AJAX拉取，[2]并且在同时提供完全相同的接口。尽管它可以被用作WebSocket的包装库，它还是提供了许多其它功能，比如广播至多个套接字，存储与不同客户有关的数据，和异步IO操作。</p><p>可以使用npm（node 软件包）工具来安装。</p><h3 id="优势"><a href="#优势" class="headerlink" title=" 优势"></a><a id="toc-advantage"></a> 优势</h3><p>Socket.IO会自动选择合适双向通信协议，仅仅需要程序员对套接字的概念有所了解。</p><h3 id="劣势"><a href="#劣势" class="headerlink" title=" 劣势"></a><a id="toc-disadvantage"></a> 劣势</h3><p>Socket.io并不是一个基本的、独立的、能够回退到其它实时协议的WebSocket库，它实际上是一个依赖于其它实时传输协议的自定义实时传输协议的实现。该协议的协商部分使得支持标准WebSocket的客户端不能直接连接到Socket.io服务器，并且支持Socket.io的客户端也不能与非Socket.io框架的WebSocket或Comet服务器通信。因而，Socket.io要求客户端与服务器端均须使用该框架。</p><h1 id="使用Socket-io"><a href="#使用Socket-io" class="headerlink" title=" 使用Socket.io"></a><a id="toc-use"></a> 使用Socket.io</h1><h3 id="安装"><a href="#安装" class="headerlink" title=" 安装"></a><a id="toc-install"></a> 安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install socket.io</div></pre></td></tr></table></figure><h3 id="直接node服务中使用"><a href="#直接node服务中使用" class="headerlink" title=" 直接node服务中使用"></a><a id="toc-use-node"></a> 直接node服务中使用</h3><p>Server(app.js)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(handler)</div><div class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(app);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line">app.listen(<span class="number">80</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  fs.readFile(__dirname + <span class="string">'/index.html'</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">      res.writeHead(<span class="number">500</span>);</div><div class="line">      <span class="keyword">return</span> res.end(<span class="string">'Error loading index.html'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(data);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">  socket.emit(<span class="string">'news'</span>, &#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;); <span class="comment">// 派发事件“news”</span></div><div class="line">  socket.on(<span class="string">'my other event'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">  &#125;); <span class="comment">// 接受Client派发的事件</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>Client (index.html)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"/socket.io/socket.io.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script&gt;</div><div class="line">  <span class="keyword">var</span> socket = io(<span class="string">'http://localhost'</span>);</div><div class="line">  socket.on(<span class="string">'news'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">    socket.emit(<span class="string">'my other event'</span>, &#123; <span class="attr">my</span>: <span class="string">'data'</span> &#125;); <span class="comment">// 接受完“new” 事件之后 派发事件"my other event"</span></div><div class="line">  &#125;);</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p><h3 id="使用Express-3-4-和-Express-2-x"><a href="#使用Express-3-4-和-Express-2-x" class="headerlink" title=" 使用Express 3/4 和 Express 2.x"></a><a id="toc-use-express"></a> 使用Express 3/4 和 Express 2.x</h3><p>Server (app.js) 使用Express 3/4<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</div><div class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</div><div class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server);</div><div class="line"></div><div class="line">server.listen(<span class="number">80</span>);</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">  socket.emit(<span class="string">'news'</span>, &#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;);</div><div class="line">  socket.on(<span class="string">'my other event'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>Server (app.js) 使用Express 2.x<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>).createServer();</div><div class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(app);</div><div class="line"></div><div class="line">app.listen(<span class="number">80</span>);</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.sendFile(__dirname + <span class="string">'/index.html'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">  socket.emit(<span class="string">'news'</span>, &#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;);</div><div class="line">  socket.on(<span class="string">'my other event'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>Client 都是一样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"/socket.io/socket.io.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script&gt;</div><div class="line">  <span class="keyword">var</span> socket = io.connect(<span class="string">'http://localhost'</span>);</div><div class="line">  socket.on(<span class="string">'news'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">    socket.emit(<span class="string">'my other event'</span>, &#123; <span class="attr">my</span>: <span class="string">'data'</span> &#125;);</div><div class="line">  &#125;);</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p><h3 id="发送和接受事件"><a href="#发送和接受事件" class="headerlink" title=" 发送和接受事件"></a><a id="toc-emit-on"></a> 发送和接受事件</h3><p>Socket.io允许我们派发和接受自定义事件。除此之外，<code>connect</code>,<code>message</code>和<code>disconnect</code>， 你可一发送自定义事件</p><p>Server<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意io(&lt;port&gt;) 会为你创建一个http服务</span></div><div class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(<span class="number">80</span>);</div><div class="line"></div><div class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">  io.emit(<span class="string">'this'</span>, &#123; <span class="attr">will</span>: <span class="string">'be received by everyone'</span>&#125;);</div><div class="line"></div><div class="line">  socket.on(<span class="string">'private message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">from, msg</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'I received a private message by '</span>, <span class="keyword">from</span>, <span class="string">' saying '</span>, msg);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    io.emit(<span class="string">'user disconnected'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h3 id="限制你自己的命名空间"><a href="#限制你自己的命名空间" class="headerlink" title=" 限制你自己的命名空间"></a><a id="toc-namespace"></a> 限制你自己的命名空间</h3><p>如果您需要控制特定应用程序所以发出的消息和事件，可以使用默认或者命名空间来工作。如果你想用第三方代码或者产生代码来分享给他人使用，socket.io提供了命名一个<code>socket</code>的方法。</p><p>单个连接使用<code>multiplexing</code>是有好处的。一个socket连接来代替使用两个<code>WebSocket</code>连接。</p><p>Server (app.js)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(<span class="number">80</span>);</div><div class="line"><span class="keyword">var</span> chat = io</div><div class="line">  .of(<span class="string">'/chat'</span>)</div><div class="line">  .on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">    socket.emit(<span class="string">'a message'</span>, &#123;</div><div class="line">        that: <span class="string">'only'</span></div><div class="line">      , <span class="string">'/chat'</span>: <span class="string">'will get'</span></div><div class="line">    &#125;);</div><div class="line">    chat.emit(<span class="string">'a message'</span>, &#123;</div><div class="line">        everyone: <span class="string">'in'</span></div><div class="line">      , <span class="string">'/chat'</span>: <span class="string">'will get'</span></div><div class="line">    &#125;);</div><div class="line">  &#125;); <span class="comment">// 空间１</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> news = io</div><div class="line">  .of(<span class="string">'/news'</span>)</div><div class="line">  .on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">    socket.emit(<span class="string">'item'</span>, &#123; <span class="attr">news</span>: <span class="string">'item'</span> &#125;);</div><div class="line">  &#125;); <span class="comment">// 空间２</span></div></pre></td></tr></table></figure></p><p>Client (index.html)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  <span class="keyword">var</span> chat = io.connect(<span class="string">'http://localhost/chat'</span>)</div><div class="line">    , news = io.connect(<span class="string">'http://localhost/news'</span>); <span class="comment">// 分别链接两个命名空间</span></div><div class="line">  </div><div class="line">  chat.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    chat.emit(<span class="string">'hi!'</span>);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  news.on(<span class="string">'news'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    news.emit(<span class="string">'woot'</span>);</div><div class="line">  &#125;);</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p><h3 id="发送不稳定的消息"><a href="#发送不稳定的消息" class="headerlink" title=" 发送不稳定的消息"></a><a id="toc-volatile"></a> 发送不稳定的消息</h3><p>有时，有些消息会被丢失。比如说，你有一个应用程序，显示实时连接的关键字<code>bieber</code></p><p>如果某个客户端没有准备好接收消息（可能是网络缓慢或其他问题， 或者他们处于长轮询连接并且处于请求阶段）。如果他没有收到所有消息，你的程序如何不受影响呢？</p><p>在这种情况下，你也许需要发送一些不稳定信息<br>Server<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(<span class="number">80</span>);</div><div class="line"></div><div class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tweets = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    getBieberTweet(<span class="function"><span class="keyword">function</span> (<span class="params">tweet</span>) </span>&#123;</div><div class="line">      socket.volatile.emit(<span class="string">'bieber tweet'</span>, tweet);</div><div class="line">    &#125;);</div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line"></div><div class="line">  socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    clearInterval(tweets);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 就是一个定时器。。。加上volatila 客户端接收到了的话，肯定会有一个回调like: clearInterval(tweets)</span></div></pre></td></tr></table></figure></p><h3 id="发送和获取数据（确认）"><a href="#发送和获取数据（确认）" class="headerlink" title=" 发送和获取数据（确认）"></a><a id="toc-callback"></a> 发送和获取数据（确认）</h3><p>有时，你也许想要客户端接收到消息发送一个回调来确认小安溪接收到了。OK，可以做到这一点</p><p>只需在<code>.send</code>， <code>.emit</code>后面添加一个回调函数fn<br>Server (app.js)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(<span class="number">80</span>);</div><div class="line"></div><div class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">  socket.on(<span class="string">'ferret'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name, fn</span>) </span>&#123;</div><div class="line">    fn(<span class="string">'woot'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>Client (index.html)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  <span class="keyword">var</span> socket = io(); <span class="comment">// TIP: io() with no args does auto-discovery</span></div><div class="line">  socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// TIP: you can avoid listening on `connect` and listen on events directly too!</span></div><div class="line">    socket.emit(<span class="string">'ferret'</span>, <span class="string">'tobi'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(data); <span class="comment">// data will be 'woot'</span></div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p><h3 id="广播消息"><a href="#广播消息" class="headerlink" title=" 广播消息"></a><a id="toc-broadcast"></a> 广播消息</h3><p>要广播，直接在<code>emit</code>和<code>send</code>前面添加<code>broadcast</code>就可以了。广播意味着除了消息发送者，所有人都将获得这个消息</p><p>Server<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(<span class="number">80</span>);</div><div class="line"></div><div class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">  socket.broadcast.emit(<span class="string">'user connected'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍Socket-io&quot;&gt;&lt;a href=&quot;#介绍Socket-io&quot; class=&quot;headerlink&quot; title=&quot; 介绍Socket.io&quot;&gt;&lt;/a&gt;&lt;a id=&quot;toc-introduce&quot;&gt;&lt;/a&gt; 介绍Socket.io&lt;/h1&gt;&lt;p&gt;Socket.IO 是一个面向实时 web 应用的 JavaScript 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在浏览器中运行的客户端库，和一个面向Node.js的服务端库。两者有着几乎一样的API。像Node.js一样，它也是事件驱动的.&lt;br&gt;
    
    </summary>
    
      <category term="socket.io" scheme="https://hddhyq.github.io/categories/socket-io/"/>
    
    
      <category term="node" scheme="https://hddhyq.github.io/tags/node/"/>
    
      <category term="socket.io" scheme="https://hddhyq.github.io/tags/socket-io/"/>
    
  </entry>
  
</feed>
