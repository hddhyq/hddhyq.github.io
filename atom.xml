<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hddhyq&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hddhyq.github.io/"/>
  <updated>2018-12-09T14:14:41.193Z</updated>
  <id>https://hddhyq.github.io/</id>
  
  <author>
    <name>hddhyq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Levenshtein distance 编辑距离算法</title>
    <link href="https://hddhyq.github.io/2018/12/08/Levenshtein-distance-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/"/>
    <id>https://hddhyq.github.io/2018/12/08/Levenshtein-distance-编辑距离算法/</id>
    <published>2018-12-08T06:53:12.000Z</published>
    <updated>2018-12-09T14:14:41.193Z</updated>
    
    <content type="html"><![CDATA[<p>这几天再看virtrual-dom，关于两个列表的对比，讲到了Levenshtein distance距离，周末抽空做一下总结。<br><a id="more"></a></p><h1 id="Levenshtein-Distance-介绍"><a href="#Levenshtein-Distance-介绍" class="headerlink" title="Levenshtein Distance 介绍"></a>Levenshtein Distance 介绍</h1><p>在信息理论和计算机科学中，Levenshtein距离是用于测量两个序列之间的差异量（即编辑距离）的度量。两个字符串之间的Levenshtein距离定义为将一个字符串转换为另一个字符串所需的最小编辑数，允许的编辑操作是单个字符的插入，删除或替换。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>‘kitten’和’sitten’之间的 Levenshtein 距离是3，因为一下三个编辑将一个更改为另一个，并且没有办法用少于三个编辑来执行操作。</p><ol><li><code>k</code> itten <code>s</code>itten =&gt; 用’s’代替’k’</li><li>sitt <code>e</code> n sitt <code>i</code> =&gt; 用’i’代替’e’</li><li>sittin  sittin <code>g</code> 在结尾插入’g’</li></ol><h1 id="Levenshtein-Distance-编辑距离-算法详解"><a href="#Levenshtein-Distance-编辑距离-算法详解" class="headerlink" title="Levenshtein Distance (编辑距离) 算法详解"></a>Levenshtein Distance (编辑距离) 算法详解</h1><p>为了得到编辑距离，我们用 beauty 和 batyu 为例：<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/algorithm/ld.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天再看virtrual-dom，关于两个列表的对比，讲到了Levenshtein distance距离，周末抽空做一下总结。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hddhyq.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://hddhyq.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="vitrual-dom" scheme="https://hddhyq.github.io/tags/vitrual-dom/"/>
    
  </entry>
  
  <entry>
    <title>css世界之层叠规则</title>
    <link href="https://hddhyq.github.io/2018/10/02/css%E4%B8%96%E7%95%8C%E4%B9%8B%E5%B1%82%E5%8F%A0%E8%A7%84%E5%88%99/"/>
    <id>https://hddhyq.github.io/2018/10/02/css世界之层叠规则/</id>
    <published>2018-10-02T09:06:46.000Z</published>
    <updated>2018-12-09T14:15:17.136Z</updated>
    
    <content type="html"><![CDATA[<p>这是关于css世界我总结的最后一篇。层叠规则<br><a id="more"></a></p><h1 id="z-index只是一小部分"><a href="#z-index只是一小部分" class="headerlink" title="z-index只是一小部分"></a>z-index只是一小部分</h1><p>CSS世界中，z-index属性只有和定位元素（position不为static的元素）在一起的时候才有作用，可以是正数也可以是负数。在CSS3中，flex盒子的子元素也可以设置z-index属性。</p><h2 id="理解层叠上下文和层叠水平"><a href="#理解层叠上下文和层叠水平" class="headerlink" title="理解层叠上下文和层叠水平"></a>理解层叠上下文和层叠水平</h2><p>层叠上下文，英文称作stacking context，是HTML中的一个三维概念。</p><ol><li><p>位于最下面的 background/border 特指层叠上下文元素的边框和背景色。每一个层叠顺序规则仅适用于当前层叠上下文元素的小世界。</p></li><li><p>inline 水平盒子指的是包括 inline/inline-block/inline-table 元素的“层叠顺序”，它们都是同等级别的。</p></li><li><p>单纯从层叠水平上看，实际上 <code>z-index:0</code> 和 <code>z-index:auto</code> 是可以看成是一样的。注意这里的措辞—“单纯从层叠水平上看”，实际上，两者在层叠上下文领域有着根本性的差异。</p></li></ol><h3 id="层叠准则"><a href="#层叠准则" class="headerlink" title="层叠准则"></a>层叠准则</h3><ol><li><p>谁大谁上：当具有明显的层叠水平标识的时候，如生效的 z-index 属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</p></li><li><p>后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。</p></li></ol><h3 id="层叠上下文特性"><a href="#层叠上下文特性" class="headerlink" title="层叠上下文特性"></a>层叠上下文特性</h3><ul><li>层叠上下文的层叠水平要比普通元素高。</li><li>层叠上下文可以阻断元素的混合模式。</li><li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。</li><li>每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。</li><li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ul><h3 id="层叠上下文的创建"><a href="#层叠上下文的创建" class="headerlink" title="层叠上下文的创建"></a>层叠上下文的创建</h3><ol><li><p>天生派: 页面根元素天生具有层叠上下文，称之为根层叠上下文。</p></li><li><p>正统派: z-index值为数值的定位元素的传统“层叠上下文”。</p><p> 对于 position 值为 relative/absolute 以及 Firefox/IE 浏览器（不包括 Chrome 浏览器）下含有 <code>position:fixed</code> 声明的定位元素，当其 z-index 值不是 auto 的时候，会创建层叠上下文。需要注意下，当两个相邻div的z-index为auto，将直接比较里面元素的z-index，当两个相邻div的层级都为相同数值的时候，父级的层级“后来居上”。Chrome 等 WebKit 内核浏览器下，<code>position:fixed</code> 元素天然层叠上下文元素，无须 z-index为数值。</p></li><li><p>扩招派: 其他CSS3属性。</p><ul><li>元素为 <code>flex</code> 布局元素（父元素 display:flex|inline-flex），同时 z-index值不是 auto。</li><li>元素的 <code>opacity</code> 值不是 1。</li><li>元素的 <code>transform</code> 值不是 none。</li><li>元素 <code>mix-blend-mode</code> 值不是 normal。</li><li>元素的 <code>filter</code> 值不是 none。</li><li>元素的 <code>isolation</code> 值是 isolate。</li><li>元素的 <code>will-change</code> 属性值为上面 2～6 的任意一个（如 <code>will-change:opacity</code>、<code>will-chang:transform</code> 等）。</li><li>元素的<code>-webkit-overflow-scrolling</code> 设为 <code>touch</code>。</li></ul></li></ol><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/z_index_stack.png" alt=""></p><h3 id="z-index“不犯2”准则"><a href="#z-index“不犯2”准则" class="headerlink" title="z-index“不犯2”准则"></a>z-index“不犯2”准则</h3><p>对于非浮层元素，避免设置z-index值，z-index值没有任何道理需要超过2。</p><ol><li><p>定位元素一旦设置z-index值，就从普通定位元素变成了层叠上下文元素，相互间的层叠顺序就发生了根本的变化，很容易出现设置了巨大的 z-index 值也无法覆盖其他元素的问题。</p></li><li><p>避免 z-index“一山比一山高”的样式混乱问题。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是关于css世界我总结的最后一篇。层叠规则&lt;br&gt;
    
    </summary>
    
      <category term="css世界" scheme="https://hddhyq.github.io/categories/css%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="css" scheme="https://hddhyq.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css世界之内联元素&amp;&amp;流的破坏</title>
    <link href="https://hddhyq.github.io/2018/10/01/css%E4%B8%96%E7%95%8C%E4%B9%8B%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0-%E6%B5%81%E7%9A%84%E7%A0%B4%E5%9D%8F/"/>
    <id>https://hddhyq.github.io/2018/10/01/css世界之内联元素-流的破坏/</id>
    <published>2018-10-01T05:16:11.000Z</published>
    <updated>2018-12-09T14:15:17.136Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分总结了两处，一处是内联元素，其实内联元素这里主要让我重新认识了下vertical-align和line-height。另一处就是关于流的破坏，主要就是介绍了下float和absolute这些属性一些知识点了。最后国庆节快乐哈哈。<br><a id="more"></a></p><h1 id="内联元素与流"><a href="#内联元素与流" class="headerlink" title="内联元素与流"></a>内联元素与流</h1><p>在内联盒子中，涉及到垂直方向的排版或者对齐，都离不开基线。而字母x的下边缘就是我们的基线（baseline）。</p><p><code>vertical-align: middle</code>对齐为字母x的中心，因为各种字体不同，所以不是绝对的垂直居中。内联元素垂直居中是对文字，而非外部的块级元素。</p><p>ex是CSS一个相对单位，指的是小写字母x的高度，就是指<strong>x-height</strong>。</p><h2 id="内联元素的高度-line-height"><a href="#内联元素的高度-line-height" class="headerlink" title="内联元素的高度 line-height"></a>内联元素的高度 line-height</h2><p>对于非替换元素的纯内联元素，其可视高度完全由line-height决定。</p><p>由于上下半间距的存在，与设计师的文字上下边距的计算一般不同，需要我们重新计算下，文字一般偏下，所以文字下边距向上取整，文字上边距向上取整。在有内联替换元素的时候，line-height不能影响替换元素的高度，内联替换元素和内联元素混排的的时候。line-height只能决定行高的最小高度。</p><h3 id="line-height让内联元素“垂直居中”"><a href="#line-height让内联元素“垂直居中”" class="headerlink" title="line-height让内联元素“垂直居中”"></a>line-height让内联元素“垂直居中”</h3><p>要让单行文字垂直居中，其实不用设置height，只需要设置好line-height的高度就好了。</p><p>多行文字居中的话也有办法，嵌套的div，使用inline-block来表示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">120px</span>;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#f0f3f9</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为什么上面的代码能垂直居中呢，全凭内联盒子前面那个宽度为0的“幽灵空白节点”。</p><h2 id="line-height的属性值"><a href="#line-height的属性值" class="headerlink" title="line-height的属性值"></a>line-height的属性值</h2><p><code>line-height: normal</code>是默认值。不同字体下的<code>line-height</code>的属性值normal计算量都是不一样的：</p><table><thead><tr><th>字体</th><th>Chrome</th><th>Firefox</th><th>IE</th></tr></thead><tbody><tr><td>微软雅黑</td><td>1.32</td><td>1.321</td><td>1.32</td></tr><tr><td>宋体</td><td>1.141</td><td>1.142</td><td>1.141</td></tr></tbody></table><p>line-height有三种计算方式：</p><ol><li><p>数值。如<code>line-height: 1.5</code>，与当前font-size相乘后的值。</p></li><li><p>百分比值。如<code>line-height: 150%</code>，与当前font-size相乘后的值。</p></li><li><p>长度值。如<code>line-height:21px</code>或者<code>者 line-height:1.5em</code>。</p></li></ol><p>使用数值的计算，和其他两种方式在继承方面有所不同。使用数值的话，那么所有的子元素继承的都是这个值；使用百分比值或者长度值作为属性值，所有<br>的子元素继承的是最终的计算值。</p><p>这里推荐的继承设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">input</span>, <span class="selector-tag">button</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: inherit;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="内联元素line-height的“大值特性”"><a href="#内联元素line-height的“大值特性”" class="headerlink" title="内联元素line-height的“大值特性”"></a>内联元素line-height的“大值特性”</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">96px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">span</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 另一个 */</span></div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">span</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">96px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一个子元素的行高是20px，一个是96px，假如一行文字，.box元素的高度是多少。答案是都是96px。</p><p>原因是，里层96px直接撑开，外层96px，“幽灵空白节点”继承96px，最终撑开。设置独立的<code>inline-block</code>避免“幽灵空白节点”影响。</p><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><p>首先要知道，line-height的高度并不是元素的最终高度。</p><p>vertical-align分为下面四大类：</p><ul><li><p>线类，如baseline、top、middle、bottom。</p></li><li><p>文本类，如text-top、text-bottom。</p></li><li><p>上标下标类，如sub、super。</p></li><li><p>数值百分比。如20px、2em、20%等。</p></li></ul><p>默认是baseline，如果设置10px这样，就会往baseline往上偏移10px。负值设置则是往下偏移。</p><h3 id="vertical-align作用的前提"><a href="#vertical-align作用的前提" class="headerlink" title="vertical-align作用的前提"></a>vertical-align作用的前提</h3><p>verticl-align作用的前提是，只能应用于内联元素以及display值为table-cell的元素。</p><p>这里举一个图片的vertical-align没有效果的例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 无效果 */</span></div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">128px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">96px</span>;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 设置line-height */</span></div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">128px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">128px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">96px</span>;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="vertical-align和line-height"><a href="#vertical-align和line-height" class="headerlink" title="vertical-align和line-height"></a>vertical-align和line-height</h3><p>阐述一下容器高度不等于行高的例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">32px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">span</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为“幽灵空白节点”的字体大小不等于span，所以字号不一样的参差位移导致的。如果在父元素设置好字体大小和子元素一样就不会有这样的情况啦。</p><p>图片底部存在间隙也是“幽灵空白节点”、line-height和vertical-align共同导致的。解决方法：</p><ol><li><p>图片块状化。</p></li><li><p>容器line-height足够小。</p></li><li><p>容器font-size足够小。</p></li><li><p>图片设置其他vertical-align属性值。</p></li></ol><p>关于图片的<code>margin-top: -200</code>无效这样的效果，原因是“幽灵空白节点”因为默认的<code>vertical-align: baseline</code>固定死在父级容器内。</p><h3 id="vertical-align线性类属性值"><a href="#vertical-align线性类属性值" class="headerlink" title="vertical-align线性类属性值"></a>vertical-align线性类属性值</h3><h4 id="inline-block与baseline"><a href="#inline-block与baseline" class="headerlink" title="inline-block与baseline"></a>inline-block与baseline</h4><p>vertical-align 属性的默认值 baseline 在文本之类的内联元素那里就是字符 x 的下边缘，对于替换元素则是替换元素的下边缘。但是，如果是 inline-block 元素，则规则要复杂了：一个 inline-block 元素，如果里面没有内联元素，或者 overflow 不是 visible，则该元素的基线就是其 margin 底边缘；否则其基线就是元素里面最后一行内联元素的基线。</p><p>inline-block和baseline的利用，删除icon，<code>&lt;i class=&quot;icon-delete&quot;&gt;删除&lt;/i&gt;</code>和<code>&lt;i class=&quot;icon-delete&quot;&gt;&lt;/i&gt;</code>这里面一个有文字，一个没文字,由于有文字的一般设置为<code>overflow：hidden</code>但是他们的元素基线都是margin底边缘。下面是小技巧，将inline-block和文字对齐。</p><ol><li><p>图标高度和行高一样。一般设定一个固定的宽高。</p></li><li><p>图标标签里面永远有字符。可以借助::before或者::after伪元素生成一个空格字符串。</p></li><li><p>图标CSS不使用<code>overflow: hidden</code>保证基线为里面字符的基线，但是要让里面潜在的字符不可见。</p></li></ol><h1 id="流的破坏与保护"><a href="#流的破坏与保护" class="headerlink" title="流的破坏与保护"></a>流的破坏与保护</h1><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>float的特性：</p><ul><li>包裹性。</li><li>块状化并格式化上下文。</li><li>破坏文档流。</li><li>没有任何margin合并。</li></ul><p>元素设置float，会让父元素坍塌。使用浮动元素的时候，最好采用采用一些手段干净地清除浮动带来的影响。</p><h3 id="float的克星clear"><a href="#float的克星clear" class="headerlink" title="float的克星clear"></a>float的克星clear</h3><p>语法如下：</p><p>clear: none | left | right | both</p><p>clear的官方解释是“元素盒子的边不能和前面的浮动元素相邻”。</p><ul><li>none: 默认值，左右浮动都有。</li><li>left: 左侧康浮动。</li><li>right: 右侧抗浮动。</li><li>both: 两侧抗浮动。</li></ul><p>一般使用，<code>clear: both</code>。<code>clear: both</code>的本质是让自己不和float元素在一行显示，并不是真正意义上的清除浮动。</p><ol><li><p>如果<code>clear: both</code>元素前面的元素就是float元素，则<code>margin-top</code>负值即使设置-9999px也没有效果。</p></li><li><p><code>clear: both</code> 后面的元素一九可能发生文字环绕的现象。</p></li></ol><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC全称<strong>block formatting context</strong>，中文是“块级格式化上下文”。与之对应的还有IFC，“内联格式化上下文”。</p><p>触发BFC的条件：</p><ul><li><code>&lt;html&gt;</code>根元素。</li><li>float的值不为none。</li><li>overflow的值auto、scroll或hidden。</li><li>display的值<code>table-cell</code>、<code>table-caption</code>和<code>inline-block</code>中任何一个。</li><li>position的值不为relative和static。</li></ul><p>BFC特点是及最重要用途是，实现更健壮、更智能的自适应布局。而不仅仅是去margin和清除float影响。</p><p>BFC的表现规则是，具有BFC特性的元素的子元素不会受外部元素影响，也不会影响外部元素。</p><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>最适合产生BFC的属性就是<code>overflow: hidden</code>。当子元素内容超出容器高度限制的时候，剪裁的边界是<code>border box</code>的内边缘，而非<code>padding box</code>的内边缘。</p><p>介绍下overflow属性经典的不兼容问题。在chrome浏览器下，如果浏览器能滚动（假设是垂直滚动），则<code>padding-bottom</code>也算在滚动尺寸内，IE和Firefox浏览器忽略<code>padding-bottom</code>。</p><h3 id="overflow-x和overflow-y"><a href="#overflow-x和overflow-y" class="headerlink" title="overflow-x和overflow-y"></a>overflow-x和overflow-y</h3><ul><li>visible：默认值。</li><li>hidden：剪裁。</li><li>scroll：滚动条区域一直在。</li><li>auto：不足以滚动时没有滚动条，可以滚动时滚动条出现。</li></ul><p>关于overflow-x和overflow-y的设置，如果一个值设置visible而另一个值设置为scroll、auto和hidden，则visible会当成auto来解析。但是scroll、auto和hidden可以共存。</p><p>PC端的默认滚动条来自<code>&lt;html&gt;</code>，而不是<code>&lt;body&gt;</code>标签，移动端就不是这样啦。</p><p>PC端滚动条会占用容器的可用宽度和高度。移动端滚动条一般是悬浮的就不会。</p><h3 id="overflow与锚点定位"><a href="#overflow与锚点定位" class="headerlink" title="overflow与锚点定位"></a>overflow与锚点定位</h3><p>下面两种情况可以触发锚点定位:</p><h3 id="锚点定位行为触发条件"><a href="#锚点定位行为触发条件" class="headerlink" title="锚点定位行为触发条件"></a>锚点定位行为触发条件</h3><ol><li><p>URL地址中的锚链与锚点元素对应并有交互行为。</p></li><li><p>可focus的锚点元素处于focus状态。</p></li></ol><h3 id="锚点定位作用的本质"><a href="#锚点定位作用的本质" class="headerlink" title="锚点定位作用的本质"></a>锚点定位作用的本质</h3><p>锚点定位作用的发生，本质上是通过改变容器滚动高度或者宽度来实现的。</p><p>锚点定位可以发生在普通元素，而且定位行为的发生是由内而外的。“由内而外”指的是，普通元素和窗体同时可滚动的时候，会由内而外触发所有可滚动窗体的锚点定位行为。</p><p>设置<code>overflow: hidden</code>的元素也是可以滚动的，只是没有滚动条，如内部的scrollTop依旧可以使用。</p><h2 id="position-absolute"><a href="#position-absolute" class="headerlink" title="position: absolute"></a>position: absolute</h2><p>当一个元素同时拥有absolute和float的时候，float属性没有任何效果。具有块状话，一旦设置了absolute或者fixed，其元素display就变成block。</p><p>关于元素的宽度的详细计算规则：</p><ol><li><p>根元素（很对场景下可以看成<code>&lt;html&gt;</code>）被称为“初始包含块”，其尺寸等于浏览器可视窗口的大小。</p></li><li><p>对于其它元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box边界形成。</p></li><li><p>如果元素position: fixed，则包含块是“初始包含块”。</p></li><li><p>如果元素的position: absolute，则“包含块”由最近的position不为static的祖先元素建立。</p><p> 如果该祖先元素是纯inline元素，则规则略复杂：</p><ul><li>假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包围盒就是内联元素的“包围块”。</li><li>如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范没有明确定义，浏览器自行发挥。</li></ul></li></ol><p>与常规元素相比，absolute绝对定位元素的“包含块”有以下3个差异</p><ol><li>内联元素也可以作为“包含块”所在的元素。</li><li>“包含块”所在的元素不是父级块元素，而是最近position不为static的祖先元素或者根元素。</li><li>边界是padding box而不是content box。</li></ol><p>内联元素一般不做“包含块”。</p><ol><li><p>一般使用absolute绝对定位都适合布局有关，而内联元素主要是图文展示。</p></li><li><p>理解和学习成本高。内联元素的“包含块”不能按照常规块级元素的“包含块”来理解。</p></li><li><p>兼容性问题。无论内联元素是单行还是跨行都存在兼容性问题。单行的兼容性问题存在于“包含块”是一个空的内联元素的时候。</p></li></ol><p>提示信息一行使用absolute定位的时候，利用<code>white-space: nowrap</code>让信息单行显示。</p><h3 id="具有相对特性的无依赖absolute绝对定位"><a href="#具有相对特性的无依赖absolute绝对定位" class="headerlink" title="具有相对特性的无依赖absolute绝对定位"></a>具有相对特性的无依赖absolute绝对定位</h3><p>absolute是非常独立的CSS属性，其样式和行为表现不依赖其他任何CSS属性就可以完成。</p><p>absolute定位效果完全不需要父元素设置position为relative或者其他属性就能实现。这种情况下，子元素也不要设置left/top/right/bottom的属性值。其实这种“无依赖绝对定位”本质上就是“相对定位”，仅仅是不占据CSS流的尺寸空间而已。</p><p>简单的例子</p><ol><li><p>图标的的定位</p></li><li><p>超越常规布局的排版</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/absoluteLayout.png" alt=""></p></li><li><p>下拉列表的定位</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/absoluteSelect.png" alt=""></p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.datalist</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.search-result</span> &#123;</div><div class="line">  <span class="attribute">display</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-class">.search-result</span> &#123;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虽然“无依赖绝对定位”好处多多，但建议只用在静态交互效果上，比方说，导航二级菜单的显示与定位。如果是动态呈现的列表，建议还是使用 JavaScript 来计算和定位。</p><h3 id="absolute与overflow"><a href="#absolute与overflow" class="headerlink" title="absolute与overflow"></a>absolute与overflow</h3><p>overflow与absolute元素的裁剪规则用一句话表述就是：绝对定位元素不总是被父级 overflow 属性剪裁，尤其当 overflow 在绝对定位元素及其包含块之间的时候。</p><p>转述就是：如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute元素经行剪裁。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不会剪裁 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"overflow: hidden;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span> <span class="attr">style</span>=<span class="string">"position: absolute;"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"overflow: hidden;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span> <span class="attr">style</span>=<span class="string">"position: absolute;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 会剪裁 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"overflow: hidden; position: relative;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span> <span class="attr">style</span>=<span class="string">"position: absolute;"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"overflow: hidden;"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span> <span class="attr">style</span>=<span class="string">"position: absolute;"</span>&gt;</span> <span class="comment">&lt;!-- 剪裁 --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>当元素出现transform属性的时候，近似于添加了“定位元素”。所以需要检查，absolute元素是否会被剪裁，fixed定位失效。</p><h3 id="absolute与clip"><a href="#absolute与clip" class="headerlink" title="absolute与clip"></a>absolute与clip</h3><p>CSS 世界中有些属性或者特性必须和其他属性一起使用才有效，比如clip。</p><p><code>clip: rect(top, right, bottom, left)</code>表示据每个边缘的距离开始剪裁。作用有：</p><ol><li><p>fixed固定定位的剪裁。</p></li><li><p>最佳可访问性隐藏。例如隐藏一些文字之类的。</p></li></ol><p>clip 隐藏仅仅是决定了哪部分是可见的，非可见部分无法响应点击事件等；然后，虽然视觉上隐藏，但是元素的尺寸依然是原本的尺寸，在 IE 浏览器和 Firefox 浏览器下抹掉了不可见区域尺寸对布局的影响，Chrome 浏览器却保留了。</p><h3 id="absolute流体特性"><a href="#absolute流体特性" class="headerlink" title="absolute流体特性"></a>absolute流体特性</h3><p>绝对定位元素在“对立方向同时发生定位的时候”。</p><p>当绝对定位元素处于流体状态的时候，各个盒模型相关属性的解析和普通流体元素都是一模一样的，margin 负值可以让元素的尺寸更大，并且可以使用 margin:auto 让绝对定位元素保持居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.element</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">300px</span>; <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">margin</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="position-relative"><a href="#position-relative" class="headerlink" title="position: relative"></a>position: relative</h2><p>relative的定位有两点值得一提：</p><ul><li>相对定位元素的left/top/right/bottom的百分比计算值是相对包含块计算的，而不是本身。所以如果包含块的高度是auto，那么计算值是0，便宜无效。</li><li>相对元素同时应用对立方向定位值的时候，按照默认文档流，自上而下、从左往右，top<br>、left作用大。</li></ul><h3 id="relative最小化影响原则"><a href="#relative最小化影响原则" class="headerlink" title="relative最小化影响原则"></a>relative最小化影响原则</h3><ol><li>尽量不适用relative，想定位某些元素，首先看能否使用“无依赖的绝对定位”。</li><li>如果场景受限，一定要使用relative，则该relative务必最小化。</li></ol><p>原因有，一个普通元素变成相对定位元素，元素的层叠顺序提高了。“relative 的最小化影响原则”不仅规避了复杂场景可能出现样式问题的隐患，从日后的维护角度讲也更方便。</p><h2 id="position-fixed固定定位"><a href="#position-fixed固定定位" class="headerlink" title="position: fixed固定定位"></a>position: fixed固定定位</h2><p>position:fixed 固定定位元素的“包含块”是根元素，我们可以将其近似看成<code>&lt;html&gt;</code>元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一部分总结了两处，一处是内联元素，其实内联元素这里主要让我重新认识了下vertical-align和line-height。另一处就是关于流的破坏，主要就是介绍了下float和absolute这些属性一些知识点了。最后国庆节快乐哈哈。&lt;br&gt;
    
    </summary>
    
      <category term="css世界" scheme="https://hddhyq.github.io/categories/css%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="css" scheme="https://hddhyq.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css世界之盒子模型</title>
    <link href="https://hddhyq.github.io/2018/09/27/css%E4%B8%96%E7%95%8C%E4%B9%8B%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>https://hddhyq.github.io/2018/09/27/css世界之盒子模型/</id>
    <published>2018-09-27T15:59:15.000Z</published>
    <updated>2018-12-09T15:14:36.537Z</updated>
    
    <content type="html"><![CDATA[<p>这是这个总结系列的第二篇文章，关于content、padding、margin、border的。<br><a id="more"></a></p><h1 id="content"><a href="#content" class="headerlink" title="content"></a>content</h1><h2 id="什么是替换元素"><a href="#什么是替换元素" class="headerlink" title="什么是替换元素"></a>什么是替换元素</h2><p>简单的来说，通过修改某个属性值，呈现的内容就可以被替换的元素就称之为<strong>替换元素</strong>。</p><ol><li><p>内容的外观不受页面的css影响。也就是说样式表现在css作用域之外，如何修改替换元素本身的外观呢。需要利用浏览器提供行的一些样式接口，如：<code>::-ms-check{}</code>，直接修改样式是不起作用的。</p></li><li><p>有自己的尺寸。很多替换元素在没有明确尺寸的时候，其默认尺寸（不包括边框）为300像素×150像素。</p></li><li><p>很多css属性有自己的一套表现方式。比如<code>vertical-align</code>属性，对于非替换内联元素来说，其一般是字符x的下边缘，而对于替换元素来说，一般来说是元素的下边缘。</p></li></ol><h3 id="替换元素的display值"><a href="#替换元素的display值" class="headerlink" title="替换元素的display值"></a>替换元素的display值</h3><p>替换元素都是内联元素，但是它们的display值却是有所不同。</p><table><thead><tr><th>元素</th><th>Chrome</th><th>Firefox</th><th>IE</th></tr></thead><tbody><tr><td><code>&lt;img&gt;</code></td><td>inline</td><td>inline</td><td>inline</td></tr><tr><td><code>&lt;iframe&gt;</code></td><td>inline</td><td>inline</td><td>inline</td></tr><tr><td><code>&lt;video&gt;</code></td><td>inline</td><td>inline</td><td>inline</td></tr><tr><td><code>&lt;select&gt;</code></td><td>inline-block</td><td>inline-block</td><td>inline-block</td></tr><tr><td><code>&lt;input&gt;</code></td><td>inline-block</td><td>inline</td><td>inline-block</td></tr><tr><td><code>range(or)file &lt;input&gt;</code></td><td>inline-block</td><td>inline-block</td><td>inline-block</td></tr><tr><td><code>hidden &lt;input&gt;</code></td><td>none</td><td>none</td><td>none</td></tr><tr><td><code>&lt;button&gt;</code></td><td>inline-block</td><td>inline-block</td><td>inline-block</td></tr><tr><td><code>&lt;video&gt;</code></td><td>inline-block</td><td>inline</td><td>inline-block</td></tr></tbody></table><h3 id="替换元素的尺寸计算规则"><a href="#替换元素的尺寸计算规则" class="headerlink" title="替换元素的尺寸计算规则"></a>替换元素的尺寸计算规则</h3><ol><li><p>固有尺寸。这个固有尺寸指的是替换内容的原本尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。这个宽度和高度的大小就是“固有尺寸”。</p></li><li><p>HTML尺寸。“HTML尺寸”只能通过HTML原生属性改变，这些原生属性包括<code>&lt;img&gt;</code>的width和height属性、<code>&lt;input&gt;</code>的size属性、<code>&lt;textarea&gt;</code>的cols和rows属性等。</p></li><li><p>CSS尺寸特指可以通过CSS的width和height。</p></li></ol><p>css尺寸 &gt; HTML尺寸 &gt; 固有尺寸。即使替换元素设置<code>display: block</code>，尺寸规则仍然和内联状态一样，这也是为什么图片或者其他表单元素设置<code>display:block</code>却没有达到100%容器的原因。</p><p>如果一个图片没有src，那么其将不会有网络请求，这一点可以用在图片懒加载上面。而在Firefox中，这种没有src的img元素将会表现为一个普通的内联元素，所以宽高设置无效，所以需要将其设置为<code>display: inline-block</code>。</p><p>关于图片的width和height设置，影响图片的方式。图片的默认填充方式是fill，也就是说，你说设置的宽度和高度都会被默认填充满，所以尺寸的变化，改变的不是图片的固有尺寸，只是改变了图片填充的外部尺寸。CSS3中，替换元素的适配方式，可以通过<code>object-fit</code>来修改。</p><h3 id="替换元素和非替换元素的区别"><a href="#替换元素和非替换元素的区别" class="headerlink" title="替换元素和非替换元素的区别"></a>替换元素和非替换元素的区别</h3><h4 id="观点1：-替换元素和非替换元素之间只隔了一个src属性。"><a href="#观点1：-替换元素和非替换元素之间只隔了一个src属性。" class="headerlink" title="观点1： 替换元素和非替换元素之间只隔了一个src属性。"></a>观点1： 替换元素和非替换元素之间只隔了一个src属性。</h4><p>这里举了一个小例子，利用到了伪元素的图片生成技术。</p><ul><li><p>不能有src属性（证明观点所在）</p></li><li><p>不能使用content属性生成图片（针对Chrome）</p></li><li><p>需要有alt属性并有值（针对Chrome）</p></li><li><p>Firefox下::before伪元素的content值会被无视，::after不会发生这种问题。</p></li></ul><p>这里有一个展示的链接，<a href="http://demo.cssworld.cn/4/1-2.php" target="_blank" rel="noopener">http://demo.cssworld.cn/4/1-2.php</a> 。这里可以演示图片没加载成功的时候，hover提示图片信息的技术。</p><h4 id="观点2：替换元素和非替换元素之间只隔了一个CSS-content-属性"><a href="#观点2：替换元素和非替换元素之间只隔了一个CSS-content-属性" class="headerlink" title="观点2：替换元素和非替换元素之间只隔了一个CSS content 属性"></a>观点2：替换元素和非替换元素之间只隔了一个CSS content 属性</h4><p>替换元素之可替换的部分是content box，对应css属性是content。所以从理论来说content熟悉决定了是替换元素或者非替换元素。直接添加了content属性的元素我们可以称之为“匿名替换元素”。</p><p>在MDN中对于<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content" target="_blank" rel="noopener">content</a>的介绍中，也直接说明了使用content 属性插入的内容都是匿名的可替换元素。</p><p>关于content的利用，这里放一个<a href="http://demo.cssworld.cn/4/1-9.php" target="_blank" rel="noopener">三个点动态加载</a>以及<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Lists_and_Counters/Using_CSS_counters" target="_blank" rel="noopener">counter()</a>。计数器可以说也主要是生成文档的时候来用一下。最后最后，content能够混合的，也就是像这种形式<code>content: &quot;(&quot; attr(href) &quot;)&quot;</code>。</p><h1 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h1><h2 id="奇怪的首选最小宽度"><a href="#奇怪的首选最小宽度" class="headerlink" title="奇怪的首选最小宽度"></a>奇怪的首选最小宽度</h2><p>关于padding里面有几个点需要注意的，即使设置了<code>box-sizing: border-box</code>，当padding计算值大于width时，width也会无效，最终宽度呈现为padding计算值，内容则表现为“首选最小宽度”。而且加了文字也不会变，一般来说是0吧。</p><h2 id="内联元素的padding"><a href="#内联元素的padding" class="headerlink" title="内联元素的padding"></a>内联元素的padding</h2><p>内联元素的padding，会发生层叠，就是说，对上下元素的原本布局没有任何影响，却发生了层叠。</p><p>css中有很多不影响其他元素布局的层叠现象。如，relative元素的定位、盒阴影box-shadow以及outline等。</p><ol><li><p>纯视觉层叠。不影响外部尺寸，如box-shadow以及outline等。</p></li><li><p>会影响视觉的层叠。inline元素的padding就是这种。</p></li></ol><p>区分的方式也很简单，如果父容器设置为<code>overflow: auto</code>，层叠区域超出父元素的时候，没有滚动条出现，则是纯视觉的；如果有滚动条出现，则会影响尺寸，影响布局。</p><h2 id="内联padding的一点小应用"><a href="#内联padding的一点小应用" class="headerlink" title="内联padding的一点小应用"></a>内联padding的一点小应用</h2><h3 id="利用内联padding实现高度可控的“管道分隔符”"><a href="#利用内联padding实现高度可控的“管道分隔符”" class="headerlink" title="利用内联padding实现高度可控的“管道分隔符”"></a>利用内联padding实现高度可控的“管道分隔符”</h3><p><a href="http://demo.cssworld.cn/4/2-2.php" target="_blank" rel="noopener">查看链接</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> + <span class="selector-tag">a</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">3px</span> <span class="number">1px</span>;</div><div class="line">  <span class="attribute">margin-left</span>: <span class="number">6px</span>;</div><div class="line">  <span class="attribute">border-left</span>: <span class="number">1px</span> solid gray;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/pipe_border.png" alt=""></p><h2 id="padding的百分比值及应用"><a href="#padding的百分比值及应用" class="headerlink" title="padding的百分比值及应用"></a>padding的百分比值及应用</h2><p>块级元素的话，有一个纯css实现宽高5:1的头图， <a href="http://demo.cssworld.cn/4/2-3.php" target="_blank" rel="noopener">效果图</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10%</span> <span class="number">50%</span>;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里在讨论一下内联元素的padding百分比。</p><ul><li>同样的相对宽度计算。</li><li>默认的高度和宽度细节有差异。</li><li>padding会断行。</li></ul><p>内联元素的padding首先计算的是左边，那么左边的长度够了的话，元素就会换行，换行之后，新的padding会形成背景，如果是背景色不是transparent的话，就会根据先来后到的产生层叠现象，而且层叠等级比较高。会产生相应的奇怪的现象，一般的开发过程中，遇到这种情况的概率比较小。</p><p>空白的内联元素的表现也会有不同的表现，因为内联元素前面有一个宽度为0高度自适应的“幽灵空白节点元素”，所以，设置<code>padding: 50%</code>最终的变现为一个长方形，这种现象，在我们知道了“幽灵空白节点元素”的存在就不会显得那么难以理解了。</p><h2 id="padding与图形绘制"><a href="#padding与图形绘制" class="headerlink" title="padding与图形绘制"></a>padding与图形绘制</h2><p>padding属性和background-clip属性配合，可以在有限的标签下实现一些css图形绘制效果。</p><p>不使用伪元素，仅一层标签实现菜单图标。下面是十倍大小模拟。</p><p>双层圆心选中效果也可以直接模拟。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.icon-menu</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">width</span>: <span class="number">140px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">35px</span> <span class="number">0</span>;</div><div class="line">  <span class="attribute">border-top</span>: <span class="number">10px</span> solid;</div><div class="line">  <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid;</div><div class="line">  <span class="attribute">background-color</span>: currentColor;</div><div class="line">  <span class="attribute">background-clip</span>: content-box;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.icon-dot</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">background-color</span>: currentColor;</div><div class="line">  <span class="attribute">background-clip</span>: content-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="http://demo.cssworld.cn/4/2-4.php" target="_blank" rel="noopener">效果图</a></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/menu_dot.png" alt=""></p><h1 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h1><h2 id="元素尺寸的相关概念"><a href="#元素尺寸的相关概念" class="headerlink" title="元素尺寸的相关概念"></a>元素尺寸的相关概念</h2><ul><li><p>元素尺寸：对应jQuery的<code>$().outerWidth()</code>和<code>$().outerHeight()</code>方法，是元素的<strong>border box</strong>尺寸。在原生DOM API中写作offsetWidth和offsetHeight，所以有时也称作“元素偏移尺寸”。</p></li><li><p>元素内部尺寸：对应jQuery的<code>$().innerWidth()</code>和<code>$().innerHeight()</code>，就是元素的<strong>padding box</strong>的尺寸。在原生DOM API中写作clientWidth和clientHeight。</p></li><li><p>元素外部尺寸：对应jQuery的<code>$().outerWidth(true)</code>和<code>$(true).outerHeight(true)</code>，是元素的<strong>margin box</strong>的尺寸。原生DOM API中没有对应的。</p></li></ul><p>当元素的尺寸表现为充分利用可利用空间的时候，margin会影响元素的尺寸。对于普通流体元素，margin只能改变元素水平方向尺寸。对于具有可拉伸的绝对定位元素，则水平和垂直方向都可以。</p><h2 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a>margin合并</h2><p>margin合并的三种场景：</p><ol><li><p>相邻兄弟元素margin合并。</p></li><li><p>父级和第一个、最后一个子元素。</p></li><li><p>空块级元素的margin合并。块级元素为空，上下margin会合并。</p></li></ol><p>margin合并规则，“正正取最大”“正负相加”“负负取最负”。</p><p>margin合并的意义主要是为了文档的展示，即css2的主要内容。<br>v</p><h2 id="margin-auto"><a href="#margin-auto" class="headerlink" title="margin: auto"></a>margin: auto</h2><p>平分规则：</p><ol><li><p>如果一侧定值，一侧为auto，则auto为剩余空间大小。</p></li><li><p>如果两侧均是auto，则平分剩余空间。</p></li></ol><p>这里让某个元素右对齐就可以用，<code>margin-left：auto</code>这个属性啦。</p><p>这里介绍一下水平垂直同时居中的一个方法。容器尺寸固定且，<code>position: relative</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.son</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">margin</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这种格式化的流体布局中，margin的自动分配剩余空间就起作用啦，所以最后会垂直水平居中。</p><h2 id="margin无效情况"><a href="#margin无效情况" class="headerlink" title="margin无效情况"></a>margin无效情况</h2><ol><li><p>display计算值为inline的非替换元素的垂直margin是无效的。对于内联替换元素的垂直margin有效。</p></li><li><p>表格的<tr>和<td>元素设置display值是<code>table-cell</code>或<code>table-row</code>的margin无效。如果计算值是<code>tab-caption</code>、<code>inline-table</code>，可以通过margin控制外边距，甚至::first-letter伪元素也可以解析margin。</td></tr></p></li><li><p>margin合并时候，margin小于合并值设置无效。</p></li><li><p>绝对定位元素非定位方位的margin值“无效”。绝对定位元素无法影响兄弟元素，所以看起来无效。</p></li><li><p>定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。正常流的情况下，margin-top和margin-left有效，而margin-bottom和margin-right则会无效。虽然有，但是影响不到自己，只会影响兄弟元素的定位。</p></li><li><p>float鞭长莫及的margin。<code>float: right</code>和<code>margin-right: 20px</code>这里20px小于元素的宽度的时候，就会无效。</p></li><li><p>内联特性导致的margin无效。</p></li></ol><h1 id="border"><a href="#border" class="headerlink" title="border"></a>border</h1><p>border和padding与margin不同，border-width不支持百分比的数值。border相当于盒子的宽度，包装盒哪里有根据内部容器变大的情况呢。其他诸如outline、box-shadow、text-shadow等都是不支持百分比的数值的。</p><p>border-width还支持若干关键字。thin、medium、thick等。</p><p>border-style有几个点，关于border-style: none为默认值。border-style: double表现规则记录一下：双线宽度永远相等，中间间隔±1。</p><p>借助border也能实现菜单menu啦。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.icon</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">border-top</span>: <span class="number">60px</span> double;</div><div class="line">  <span class="attribute">border-bottom</span>: <span class="number">20px</span> solid;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="border三角形绘制。"><a href="#border三角形绘制。" class="headerlink" title="border三角形绘制。"></a>border三角形绘制。</h2><p>等腰三角形的绘制：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid;</div><div class="line">  <span class="attribute">border-color</span>: <span class="number">#f30</span> transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先我们需要知道border的绘制过程：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">100px</span> solid;</div><div class="line">  <span class="attribute">border-color</span>: <span class="number">#f30</span> <span class="number">#00f</span> <span class="number">#396</span> <span class="number">#0f0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/border_color.png" alt=""> </p><p>所以其他三边透明和宽高为0的等宽三角想也就出来了：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 梯形 */</span></div><div class="line"></div><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">100px</span> solid;</div><div class="line">  <span class="attribute">border-color</span>: <span class="number">#f30</span> transparent transparent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 三角形 */</span></div><div class="line"></div><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">100px</span> solid;</div><div class="line">  <span class="attribute">border-color</span>: <span class="number">#f30</span> transparent transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/border_color_transparent.png" alt=""> <img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/border_single.png" alt=""></p><p>其他一些其他的三角形利用，则是利用两个倾斜度不同的三角形叠加。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是这个总结系列的第二篇文章，关于content、padding、margin、border的。&lt;br&gt;
    
    </summary>
    
      <category term="css世界" scheme="https://hddhyq.github.io/categories/css%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="css" scheme="https://hddhyq.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css世界之流体布局</title>
    <link href="https://hddhyq.github.io/2018/09/23/css%E4%B8%96%E7%95%8C%E4%B9%8B%E6%B5%81%E4%BD%93%E5%B8%83%E5%B1%80/"/>
    <id>https://hddhyq.github.io/2018/09/23/css世界之流体布局/</id>
    <published>2018-09-23T10:23:00.000Z</published>
    <updated>2018-09-24T07:55:41.406Z</updated>
    
    <content type="html"><![CDATA[<p>这将会把看到的css世界里面的知识点提取出来，可能会有5到6篇文章来做总结。</p><p>这是第一篇文章，css世界之流体布局。<br><a id="more"></a></p><h1 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h1><p>想要了解文档流，我们需要关注普通元素默认的布局是怎样的。</p><p>在MDN中<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Normal_Flow" target="_blank" rel="noopener">normal flow</a>章节中有所描述。</p><p>单个元素我们需要关注于它们的盒子模型，首先获取元素的content，然后是它们的padding，最后是border和margin。</p><p>默认来说，块级元素的content是父级元素宽度的100%，高度是元素content的高度。内联元素的高度是content的高度，宽度也是content的宽度。你不能直接设置一个内联元素的高度或者宽度，内联元素的高度仅仅是坐落在块级元素的内容中。如果你想要控制内联元素的高度和宽度，你需要将它们设置为 <code>display: block;</code> 或 <code>display: inline-block;</code></p><p>上面解释了单个元素。如果有多个元素，他们会怎么交互呢？在正常的浏览器布局中，默认来说，块级元素会根据文档的书写方式有关。每一个块级元素将会占据一个新行，他们还会根据所设置的margin值来分离。在英语中，或者其他水平，自上而下的书写的语言中，块级元素会根据垂直布局。</p><p>内联元素的表现方式就有所不同，它们不会在新的一行出现，它们会在同一行一个接一个的排列，直到它们的长度超过父级元素的宽度就会换行。</p><h1 id="width或height作用的具体细节"><a href="#width或height作用的具体细节" class="headerlink" title="width或height作用的具体细节"></a>width或height作用的具体细节</h1><p>由于块级元素的流体特性主要体现在水平上，所以首先讨论的就是宽度。</p><h2 id="width-auto"><a href="#width-auto" class="headerlink" title="width: auto"></a>width: auto</h2><p>width的默认值就是auto。它有以下四种表现：</p><ol><li><p>充分利用可用空间。常见就是<code>&lt;div&gt;&lt;p&gt;</code>元素宽度是100%默认于父级容器的。</p></li><li><p>收缩于包裹。常见于浮动、绝对定位、inline-block元素或table元素。</p></li><li><p>收缩到最小。常见于table-layout为auto的表格中。</p></li><li><p>超出容器限制。上面三种元素都不会使元素超出容器宽度，除非设置了<code>white-space: nowrap</code>。</p></li></ol><p>上述四种宽度情况中，除了第一种是由外部尺寸确定的宽度，其他都是内部尺寸决定的宽度。</p><h3 id="外部尺寸与流体特性"><a href="#外部尺寸与流体特性" class="headerlink" title="外部尺寸与流体特性"></a>外部尺寸与流体特性</h3><ol><li><p>正常流宽度。宽度会自动填充满父级容器。</p></li><li><p>格式化宽度。出现在‘绝对定位模型中’，也就是position为 <strong>absolute</strong> 和 <strong>fixed</strong> 元素中，</p><p> 对于非替换元素，当left/right或者top/bottom对立方位的属性值同时存在的时候，元素的宽度表现为格式化宽度。同样的设置了宽度就会破坏了这种流体性。</p></li></ol><h3 id="内部尺寸与流体特性"><a href="#内部尺寸与流体特性" class="headerlink" title="内部尺寸与流体特性"></a>内部尺寸与流体特性</h3><p>这里我仅仅记录了一个关于包裹性的利用，页面中某个文字内容是动态的，可能是几个字或多很多字，几个字的时候居中显示，多个字的时候居左显示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">text-align</span>: left;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="height-auto"><a href="#height-auto" class="headerlink" title="height: auto"></a>height: auto</h2><p>如果父级元素的高度是100%，那么只要子元素在文档流之中，其百分比值完全被忽略。为什么高度的百分比计算会被忽略呢。在w3c规范中在就给出了答案，如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为 <strong>auto</strong> 。父级容器的高度解释为了auto自然没法与百分比相乘了。</p><p><strong>如何让元素支持height: 100%</strong></p><ol><li><p>设定显式的高度值。给html和body设定100%也是也可以的。</p></li><li><p>使用绝对定位。绝对元素的宽高百分比计算是相对于 <strong>padding box</strong> 计算的，非绝对定位的高度百分比计算则是相对于 <strong>content box</strong> 计算的。</p></li></ol><h1 id="css-min-width-max-width和min-height-max-height"><a href="#css-min-width-max-width和min-height-max-height" class="headerlink" title="css min-width/max-width和min-height/max-height"></a><strong>css</strong> min-width/max-width和min-height/max-height</h1><p>下面简述一下min/max-width/height与width和height的不一样的地方。</p><h2 id="关于初始值"><a href="#关于初始值" class="headerlink" title="关于初始值"></a>关于初始值</h2><p>既然是总结，直接放出来好了，max-*的初始值是none，min-*的初始值是auto。</p><h2 id="覆盖规则"><a href="#覆盖规则" class="headerlink" title="覆盖规则"></a>覆盖规则</h2><p>当max-width小于width设置的时候，即使width加上了<code>!important</code>也没有用，max-width大于width的设置。</p><p>当min-width大于max-width的时候，会以min-width为准则。</p><p>根据覆盖原则，我们可以实现任意高度的展开收起技术。由于设置height为auto无法计算值，过渡和动画效果也无法完成。所以我们可以利用max-height实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.element</span> &#123;</div><div class="line">  <span class="attribute">max-height</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">  <span class="attribute">transition</span>: max-height .<span class="number">25s</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.element</span><span class="selector-class">.active</span> &#123;</div><div class="line">  <span class="attribute">max-height</span>: <span class="number">666px</span>; <span class="comment">/* 一个足够大的最大高度值 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="内联盒模型和幽灵空白节点"><a href="#内联盒模型和幽灵空白节点" class="headerlink" title="内联盒模型和幽灵空白节点"></a>内联盒模型和幽灵空白节点</h1><h2 id="内联盒模型的简易版"><a href="#内联盒模型的简易版" class="headerlink" title="内联盒模型的简易版"></a>内联盒模型的简易版</h2><ol><li><p>内容区域。内容区域指一种围绕文字看不见的盒子，可以理解为em盒。</p></li><li><p>内联盒子。“内联盒子”不会让内容成块显示，而是排成一行。需要注意的是一段单独的文本不一定是“匿名内联盒子”，还有可能是“匿名块级盒子”，主要是看其前后标签是内联还是块级。</p></li><li><p>行框盒子。每一行就是一个行框盒子，每个行框盒子又是一个一个“内联盒子”组成的。</p></li><li><p>包含盒子。又称包含块，包括父级标签。</p></li></ol><h2 id="幽灵空白节点"><a href="#幽灵空白节点" class="headerlink" title="幽灵空白节点"></a>幽灵空白节点</h2><p>“幽灵空白节点”是内联盒子模型的一个非常重要的概念。具体指，在HTML5的文档声明中，内联元素的所有解析盒渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个节点永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但是又确确实实存在。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这将会把看到的css世界里面的知识点提取出来，可能会有5到6篇文章来做总结。&lt;/p&gt;
&lt;p&gt;这是第一篇文章，css世界之流体布局。&lt;br&gt;
    
    </summary>
    
      <category term="css世界" scheme="https://hddhyq.github.io/categories/css%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="css" scheme="https://hddhyq.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>移动端虚拟键盘和滚动穿透小结</title>
    <link href="https://hddhyq.github.io/2018/07/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98%E5%92%8C%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E5%B0%8F%E7%BB%93/"/>
    <id>https://hddhyq.github.io/2018/07/31/移动端虚拟键盘和滚动穿透小结/</id>
    <published>2018-07-31T02:34:12.000Z</published>
    <updated>2018-12-09T14:14:41.198Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下最近遇到的两个小bug，也不算小bug，可能在不同的移动端浏览器表现不同吧。一个是虚拟键盘顶起，一个是滚动穿透问题。<br><a id="more"></a></p><h1 id="虚拟键盘"><a href="#虚拟键盘" class="headerlink" title="虚拟键盘"></a>虚拟键盘</h1><p>首先需要明确的一点是，虚拟键盘的顶起在IOS端和Android端有很大的不同变现。</p><h2 id="监听移动端软键盘弹起和收起"><a href="#监听移动端软键盘弹起和收起" class="headerlink" title="监听移动端软键盘弹起和收起"></a>监听移动端软键盘弹起和收起</h2><h3 id="1-Android端-监听resize"><a href="#1-Android端-监听resize" class="headerlink" title="1. Android端 监听resize"></a>1. <strong>Android端</strong> 监听resize</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> winHeight = $(<span class="built_in">window</span>).height();</div><div class="line"></div><div class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> thisHeight = $(<span class="keyword">this</span>).height();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>( winHeight - thisHeight &gt; <span class="number">140</span>) &#123;</div><div class="line">    <span class="comment">// 键盘弹起，140px是一个预估值，可更改</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 键盘收起</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="2-IOS端-监听input失焦blur"><a href="#2-IOS端-监听input失焦blur" class="headerlink" title="2. IOS端 监听input失焦blur"></a>2. <strong>IOS端</strong> 监听input失焦blur</h3><p>ios中的键盘或者第三方键盘并不会监听到<code>window resize</code>事件，所以不能用<code>resize</code>监听，所以需要通过输入框是否获取焦点来判断。</p><p>在Android中，有一些机型，键盘收起了，输入框仍处于焦点状态，并没有触发<code>focusout</code>事件。</p><p>因为<code>focusin</code>和<code>focusout</code>支持冒泡，对应focus和blur，所以根据需求，我们可以选择相应的事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'focusin'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">　　<span class="comment">//软键盘弹出的事件处理</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'focusout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">　　<span class="comment">//软键盘收起的事件处理</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="input-textarea-contenteditable-quot-true-quot-置底问题"><a href="#input-textarea-contenteditable-quot-true-quot-置底问题" class="headerlink" title="input textarea contenteditable=&quot;true&quot; 置底问题"></a><code>input</code> <code>textarea</code> <code>contenteditable=&quot;true&quot;</code> 置底问题</h2><p>这里也需要了解一下，IOS和Android关于<code>fixed</code>属性的支持是不一样的。</p><h3 id="1-IOS端"><a href="#1-IOS端" class="headerlink" title="1. IOS端"></a>1. IOS端</h3><p>ios中，虚拟键盘顶起来之后，整个页面都会被键盘部分压缩。也就是说页面的高度会变小，并且所有的<code>fixed</code>都会变成<code>absolute</code>。</p><p>也就是说，之前在ios端fixed到底部的<code>input</code>框等可focus元素，会变成<code>absolute</code>定位，并且随着页面能够滑动。</p><h3 id="2-Android端"><a href="#2-Android端" class="headerlink" title="2. Android端"></a>2. Android端</h3><p>android端中，虚拟键盘顶起来之后，<code>fixed</code>属性不会失效，唤起的键盘是覆盖在页面上的，不会压缩页面。</p><h2 id="项目中的bug及一些思考"><a href="#项目中的bug及一些思考" class="headerlink" title="项目中的bug及一些思考"></a>项目中的bug及一些思考</h2><p>在最近的一个项目中，移动端页面布局，因为现在手机的高度不同，简单的背景图并不能放文字了，文字会拉伸，我需要设置一个<code>footer</code>放到底部，这里我最开始考虑的就是用<code>fixed</code>布局到最底部，结果当键盘顶起来的时候，文字也就跟着一起顶上去了，整个页面使用的是<code>overflow: hidden</code>。</p><p>这里就需要监听键盘顶起事件，并执行相应的给元素添加相关css的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oHeight = $(<span class="built_in">document</span>).height();</div><div class="line"><span class="comment">// 监听键盘事件</span></div><div class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> ($(<span class="built_in">document</span>).height() &lt; oHeight) &#123;</div><div class="line">    $(<span class="string">'footer'</span>).addClass(<span class="string">'hide'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    $(<span class="string">'footer'</span>).removeClass(<span class="string">'hide'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>另外，关于底部的输入框顶起的问题，我看了一下手机版微博的解决方案，在Android端，虚拟键盘顶起，应该直接是fixed在底部，在IOS端则是整个添加了一个评论的浮层，总来来说也是一个不错的方案。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/ios_input.jpg" alt=""></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/android_input.jpg" alt=""></p><p>最后介绍一个神奇的东西<code>Element.scrollIntoView()</code>，这个东西能把底部的输入框提高到可视区域，不过经过测试，键盘顶起是需要时间的，我们需要确保，在键盘调起之后，确保元素调用<code>scrollIntoView()</code>。</p><p>下面是我写的一段代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#el'</span>).on(<span class="string">'focus'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#el'</span>).scrollIntoView();</div><div class="line">  &#125;, <span class="number">300</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h1 id="滚动穿透"><a href="#滚动穿透" class="headerlink" title="滚动穿透"></a>滚动穿透</h1><p>在移动端中，滚动穿透问题很常见，处理起来也比较繁琐。下面我还是按照不同的方法进行分类：</p><h2 id="touchmove事件中调用preventDefault"><a href="#touchmove事件中调用preventDefault" class="headerlink" title="touchmove事件中调用preventDefault()"></a>touchmove事件中调用<code>preventDefault()</code></h2><p>这个方法适用于，弹出框内容无需滚动。如果弹出层内部有滚动事件，将会导致，弹出层的滚动事件也无法滚动。</p><h2 id="添加相关的类"><a href="#添加相关的类" class="headerlink" title="添加相关的类"></a>添加相关的类</h2><p>给html上添加一个noscroll的类<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.noscroll</span>,</div><div class="line"><span class="selector-class">.noscroll</span> body</div><div class="line">  <span class="attribute">overflow</span>: hidden</div><div class="line"><span class="selector-class">.noscroll</span> body</div><div class="line">  poition: relative</div></pre></td></tr></table></figure></p><p>缺点：</p><ol><li>html和body的滚动都禁止了，弹出层关闭后，会丢失原有的滚动位置，需要用JS来还原</li><li>有些页面的北京还有能滚的动的效果</li></ol><h2 id="fixed加上js恢复记录位置"><a href="#fixed加上js恢复记录位置" class="headerlink" title="fixed加上js恢复记录位置"></a>fixed加上js恢复记录位置</h2><p>css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span><span class="selector-class">.mask-open</span> &#123;</div><div class="line">  <span class="attribute">position</span>: fixed;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scrollTop = <span class="number">0</span>;</div><div class="line"></div><div class="line">open.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</div><div class="line"></div><div class="line">  <span class="built_in">document</span>.body.classList.add(<span class="string">'mask-open'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">document</span>.body.style.top = -scrollTop + <span class="string">'px'</span>; <span class="comment">// 脱离文档流后回到当前位置</span></div><div class="line"></div><div class="line">  mask.style.display = <span class="string">'block'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">close.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  mask.style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line">  <span class="built_in">document</span>.body.classList.remove(<span class="string">'mask-open'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">document</span>.body.scrollTop = <span class="built_in">document</span>.documentElement.scrollTop = scrollTop <span class="comment">// 滚动到相应位置，确保兼容性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p> 参考</p><ul><li>虚拟键盘<ul><li><a href="https://cloud.tencent.com/developer/article/1004930" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1004930</a></li><li><a href="http://www.cnblogs.com/wangyihong/p/7514304.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangyihong/p/7514304.html</a></li></ul></li><li>滚动穿透<ul><li><a href="https://segmentfault.com/q/1010000002942948" target="_blank" rel="noopener">https://segmentfault.com/q/1010000002942948</a></li><li><a href="https://github.com/pod4g/tool/wiki/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">https://github.com/pod4g/tool/wiki/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98</a> </li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下最近遇到的两个小bug，也不算小bug，可能在不同的移动端浏览器表现不同吧。一个是虚拟键盘顶起，一个是滚动穿透问题。&lt;br&gt;
    
    </summary>
    
      <category term="移动端bug" scheme="https://hddhyq.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AFbug/"/>
    
    
      <category term="移动端" scheme="https://hddhyq.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="bug" scheme="https://hddhyq.github.io/tags/bug/"/>
    
      <category term="兼容性" scheme="https://hddhyq.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>svg简介及svg与canvas对比</title>
    <link href="https://hddhyq.github.io/2018/07/30/svg%E7%AE%80%E4%BB%8B%E5%8F%8Asvg%E4%B8%8Ecanvas%E5%AF%B9%E6%AF%94/"/>
    <id>https://hddhyq.github.io/2018/07/30/svg简介及svg与canvas对比/</id>
    <published>2018-07-30T02:07:05.000Z</published>
    <updated>2018-12-09T14:14:41.196Z</updated>
    
    <content type="html"><![CDATA[<p>SVG(scalable、vector、graphics)是XML语言的一种形式，有点类似XHTML，它可以用来绘制矢量图形。<br><a id="more"></a></p><h1 id="SVG的基本应用"><a href="#SVG的基本应用" class="headerlink" title="SVG的基本应用"></a>SVG的基本应用</h1><p>首先需要记住的是，svg在HTML中的写法是用的XML的语法，所以：</p><ol><li>SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同）</li><li>SVG里的属性值必须用引号引起来，就算是数值也必须这样做。</li></ol><h1 id="svg文件的基本属性"><a href="#svg文件的基本属性" class="headerlink" title="svg文件的基本属性"></a>svg文件的基本属性</h1><h2 id="svg渲染及压缩"><a href="#svg渲染及压缩" class="headerlink" title="svg渲染及压缩"></a>svg渲染及压缩</h2><ul><li>元素的渲染顺序，SVG文件全局有效的规则是“后来居上”，越后面的元素越可见。</li><li>web上的svg文件可以直接展示，或者通过以下几种方法嵌入到HTML文件：<ul><li>HTML是XHTML，并且声明类型为application/xhtml+xml</li><li>HTML是HTML5，并且浏览器支持HTML5，可以直接嵌入SVG</li><li>通过<code>object</code>引入SVG文件。<code>&lt;object data=&quot;image.svg&quot; type=&quot;image/svg+xml&quot; /&gt;</code></li><li>通过<code>iframe</code>引入SVG文件。<code>&lt;iframe src=&quot;image.svg&quot;&gt;&lt;/iframe&gt;</code></li><li>可以使用img元素，但是在低于4.0版本的Firefox中不起作用</li><li>最后SVG可以通过JavaScript动态创建并注入到HTML DOM中</li></ul></li></ul><p>svg有两种文件类型，一个是”.svg”，一个是压缩的”.svgz”。”.svgz”在Firefox不能通过本地的机器加载，微软的IIS服务器对于gzip压缩的SVG文件，在用户代理上也不是很可靠。”.svgz”多用于地图应用等需要大型SVG文件的应用。</p><h2 id="SVG的坐标定位及窗口"><a href="#SVG的坐标定位及窗口" class="headerlink" title="SVG的坐标定位及窗口"></a>SVG的坐标定位及窗口</h2><p>svg的网格布局和canvas是一样的，都是以一个左上角为原点，向下和向右延申的。</p><p>正常情况下，svg的一个像素对应显示屏的一个像素，不过这种情况是可以改变的，我们需要定义<code>viewBox</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span>&gt;</span></div></pre></td></tr></table></figure><p>上面的画板尺寸是<code>200px*200px</code>，画板展示区域是<code>100px*100px</code>，所以<code>100*100</code>的区域会在<code>200*200</code>的画布上展示。</p><h1 id="svg基本形状"><a href="#svg基本形状" class="headerlink" title="svg基本形状"></a>svg基本形状</h1><h2 id="矩形-rect"><a href="#矩形-rect" class="headerlink" title="矩形 rect"></a>矩形 rect</h2><ul><li>x 矩形左上角的x位置</li><li>y 矩形左上角的y位置</li><li>width 矩形的宽度</li><li>height 矩形的高度</li><li>rx 圆角的x方位的半径</li><li>ry 圆角的y方位的半径</li></ul><h2 id="圆形-circle"><a href="#圆形-circle" class="headerlink" title="圆形 circle"></a>圆形 circle</h2><ul><li>r 圆的半径</li><li>cx 圆心的x位置</li><li>cy 圆心的y位置</li></ul><h2 id="椭圆-ellipse"><a href="#椭圆-ellipse" class="headerlink" title="椭圆 ellipse"></a>椭圆 ellipse</h2><ul><li>rx 椭圆的x半径</li><li>ry 椭圆的y半径</li><li>cx 椭圆中心的x位置</li><li>cy 椭圆中心的y位置</li></ul><h2 id="线条-line"><a href="#线条-line" class="headerlink" title="线条 line"></a>线条 line</h2><ul><li>x1 起点的x位置</li><li>y1 起点的y位置</li><li>x2 终点的x位置</li><li>y2 终点的y位置</li></ul><h2 id="折线-polyline"><a href="#折线-polyline" class="headerlink" title="折线 polyline"></a>折线 polyline</h2><p>Polyline是一组连接在一起的直线。因为它可以有很多的点，折线的的所有点位置都放在一个points属性中：</p><p><code>points</code> 点集数列。每个数字用空白、逗号、终止命令符或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。</p><h2 id="多边形-polygon"><a href="#多边形-polygon" class="headerlink" title="多边形 polygon"></a>多边形 polygon</h2><p>polygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。</p><p><code>points</code> 点集数列。每个数字用空白符、逗号、终止命令或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。</p><h1 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h1><p><code>&lt;path&gt;</code>元素是SVG基本形状中最强大的一个，path只需要少量的点就能创建和规划流畅的曲线</p><p>path的形状通过属性<code>&#39;d&#39;</code>定义，属性d的值是一个“命令+参数”的序列。</p><p>每一个命令都用一个关键字母来表示，每一个命令有两种形式。一种是<strong>大写字母</strong>，表示采用绝对定位。另一种是<strong>小写字母</strong>，表示采用相对定位。</p><p>属性<code>d</code>采用的是用户坐标系统，所以不需标明单位。</p><h2 id="直线命令"><a href="#直线命令" class="headerlink" title="直线命令"></a>直线命令</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>M x y (or m dx dy)</td><td>移动画笔坐标</td></tr><tr><td>L x y (or l dx dy)</td><td>L命令将会在当前位置和新位置（L前面画笔所在的点）之间画一条线段</td></tr><tr><td>H x (or h dx)</td><td>标明在x轴移动到的位置</td></tr><tr><td>V y (or v dy)</td><td>标明在y轴移动到的位置</td></tr><tr><td>Z (or z)</td><td>从当前点画一条直线到路径的起点</td></tr></tbody></table><h2 id="曲线命令"><a href="#曲线命令" class="headerlink" title="曲线命令"></a>曲线命令</h2><p>有三个命令：</p><ul><li>三次贝塞尔曲线</li><li>二次贝塞尔曲线</li><li>圆的一部分</li></ul><h3 id="三次贝塞尔曲线"><a href="#三次贝塞尔曲线" class="headerlink" title="三次贝塞尔曲线"></a>三次贝塞尔曲线</h3><p>三次贝塞尔曲线需要定义一个点和两个控制点，所以用C命令创建三次贝塞尔曲线，需要设置三组坐标参数：</p><p><code>C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)</code></p><p>最后一个坐标(x, y)表示的是曲线的终点，另外两个坐标是控制点，(x1, y1)是起点的控制点，(x2, y2)是终点的控制点。</p><p>如何创建平滑的曲线呢？通常情况下，一个点是另一个点的控制点的堆成。这样，你就可以使用一个简写的贝塞尔曲线S:</p><p><code>S x2 y2, x y (or s dx2 dy2, dx dy)</code></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/ShortCut_Cubic_Bezier.png" alt=""></p><h3 id="二次贝塞尔曲线"><a href="#二次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线"></a>二次贝塞尔曲线</h3><p>二次贝塞尔曲线只需要一个控制点。</p><p><code>Q x1 y1, x y (or q dx1 dy1, dx dy)</code></p><p>二次贝塞尔曲线简写<code>T x y (or t dx dy)</code>。</p><h3 id="弧形"><a href="#弧形" class="headerlink" title="弧形"></a>弧形</h3><p><code>A rx ry x-axis-rotation large-arc-flag sweep-flag x y</code></p><p><code>a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy</code></p><p>x轴旋转角度（x轴旋转角度）, large-arc-flag（角度大小） 和sweep-flag（弧线方向）</p><h2 id="Fill和Stroke属性"><a href="#Fill和Stroke属性" class="headerlink" title="Fill和Stroke属性"></a>Fill和Stroke属性</h2><p>这两个属性，可以用直接的css颜色，还有一个就是直接添加颜色的透明度。属性fill-opacity控制填充色的不透明度，属性stroke-opacity控制描边的不透明度。</p><h3 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h3><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/SVG_Stroke_Linecap_Example.png" alt=""></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/SVG_Stroke_Linejoin_Example.png" alt=""></p><h3 id="stroke-dasharray"><a href="#stroke-dasharray" class="headerlink" title="stroke-dasharray"></a>stroke-dasharray</h3><p>是一组用逗号分割的数字组成的数列</p><ol><li>第一个用来表示填色区域的长度</li><li>第二个用来表示非填色区域的长度</li><li>继续定义增加长度</li></ol><h3 id="使用css"><a href="#使用css" class="headerlink" title="使用css"></a>使用css</h3><p>除了定义对象的属性外，你也可以通过CSS来样式化填充和描边。语法和在html里使用CSS一样，只不过你要把background-color、border改成fill和stroke。注意，不是所有的属性都能用CSS来设置。上色和填充的部分一般是可以用CSS来设置的，比如fill，stroke，stroke-dasharray等，但是不包括下面会提到的渐变和图案等功能。另外，width、height，以及路径的命令等等，都不能用css设置。判断它们能不能用CSS设置还是比较容易的。</p><p>可以利用<code>:hover</code>伪类完成触发效果。</p><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>线性渐变沿着直线改变颜色，要插入一个线性渐变，你需要在SVG文件的defs元素内部，创建一个<code>&lt;linearGradient&gt;</code> 节点。</p><p>还有径向渐变也类似，创建径向渐变需要在文档的defs中添加一个<code>&lt;radialGradient&gt;</code>元素。</p><h2 id="图案"><a href="#图案" class="headerlink" title="图案"></a>图案</h2><p>patterns（图案）是SVG中用到最让人混淆的填充类型。</p><h2 id="剪切和遮罩"><a href="#剪切和遮罩" class="headerlink" title="剪切和遮罩"></a>剪切和遮罩</h2><p>Clipping用来移除在别处定义的元素的部分内容。在这里，任何半透明效果都是不行的。它只能要么显示要么不显示。</p><p>Masking允许使用透明度和灰度值遮罩计算得的软边缘。</p><p>Web开发工具箱中有一个很有用的工具是display:none。它虽然几无悬念，但是依然可以在SVG上使用该CSS属性，连同CSS2定义的visibility和clip属性。为了恢复以前设置的display:none，知道这一点很重要：所有的SVG元素的初始display值都是inline。</p><h2 id="其它SVG内容"><a href="#其它SVG内容" class="headerlink" title="其它SVG内容"></a>其它SVG内容</h2><h3 id="嵌入光栅图像"><a href="#嵌入光栅图像" class="headerlink" title="嵌入光栅图像"></a>嵌入光栅图像</h3><pre><code>很像在HTML中的img元素，SVG有一个image元素，用于同样的目的。你可以利用它嵌入任意光栅（以及矢量）图像。它的规格要求应用至少支持PNG、JPG和SVG格式文件。嵌入的图像变成一个普通的SVG元素。这意味着，你可以在其内容上用剪切、遮罩、滤镜、旋转以及其它SVG工具：</code></pre><h3 id="嵌入任意XML"><a href="#嵌入任意XML" class="headerlink" title="嵌入任意XML"></a>嵌入任意XML</h3><p>因为SVG是一个XML应用，所以你总是可以在SVG文档的任何位置嵌入任意XML。但是你没有必要定义周围的SVG需要怎样反作用于这个内容。</p><h2 id="滤镜效果"><a href="#滤镜效果" class="headerlink" title="滤镜效果"></a>滤镜效果</h2><p>有一种情况，基本形状不能提供你想要达到的效果的灵活性。投阴影、提供一个十分流行的示例，利用一个小变组合无法合理地创建它。滤镜是SVG的机制，允许创建精密的效果。</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>字体中需要了解的就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/textPath" target="_blank" rel="noopener">text-path</a>,即tref样式化。</p><h1 id="svg和canvas对比"><a href="#svg和canvas对比" class="headerlink" title="svg和canvas对比"></a>svg和canvas对比</h1><p>这部分参考W3school</p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><blockquote><p>参考</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Introduction" target="_blank" rel="noopener">MDN的svg教程</a></li><li><a href="http://www.w3school.com.cn/svg/svg_intro.asp" target="_blank" rel="noopener">W3school的svg教程</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SVG(scalable、vector、graphics)是XML语言的一种形式，有点类似XHTML，它可以用来绘制矢量图形。&lt;br&gt;
    
    </summary>
    
      <category term="svg" scheme="https://hddhyq.github.io/categories/svg/"/>
    
    
      <category term="html5" scheme="https://hddhyq.github.io/tags/html5/"/>
    
      <category term="svg" scheme="https://hddhyq.github.io/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>canvas的简单了解及应用</title>
    <link href="https://hddhyq.github.io/2018/07/28/canvas%E4%B8%8Esvg%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://hddhyq.github.io/2018/07/28/canvas与svg的简单了解及应用/</id>
    <published>2018-07-28T07:22:33.000Z</published>
    <updated>2018-12-09T14:14:41.195Z</updated>
    
    <content type="html"><![CDATA[<p>这个星期抽空看了下canvas，之前一直就对这两个东西望而却步，连简单的api和应用都没有了解。</p><p>工作中看到了<a href="https://html2canvas.hertzen.com/" target="_blank" rel="noopener">html2canvas</a>这个简单的工具可以根据DOM生成截图，于是抽空将MDN上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial" target="_blank" rel="noopener">canvas</a>教程撸了一遍。<br><a id="more"></a></p><h1 id="canvas基本概念"><a href="#canvas基本概念" class="headerlink" title="canvas基本概念"></a>canvas基本概念</h1><p><code>&lt;canvas&gt;</code>是HTML5新增的元素，可以通过JavaScript中的脚本来绘制图形。例如，它可以绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或渲染。时间太短，没有看canvas的3d部分，下面的介绍都是关于canvas的2d部分的。</p><p>首先需要知道的是canvas的绘图栅格，canvas和svg一样，坐标都是一样的，坐标都是从左上角起始：</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/Canvas_default_grid.png" alt=""></p><h1 id="绘制相关"><a href="#绘制相关" class="headerlink" title="绘制相关"></a>绘制相关</h1><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>fillRect(x, y, width, height)</td><td>绘制一个填充的矩形</td></tr><tr><td>strokeRect(x, y, width, height)</td><td>绘制一个矩形的边框</td></tr><tr><td>clearRect(x, y, width, height)</td><td>清除指定矩形区域，让清除部分完全透明</td></tr><tr><td>beginPath()</td><td>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径</td></tr><tr><td>closePath()</td><td>闭合路径之后图形绘制命令又重新指向到上下文中</td></tr><tr><td>stroke()</td><td>通过线条来绘制图形轮廓</td></tr><tr><td>moveTo(x, y)</td><td>将笔触移动到指定的坐标x以及y上</td></tr><tr><td>lineTo(x, y)</td><td>绘制一条从当前位置到指定x以及y位置的直线</td></tr><tr><td>arc(x, y, radius, startAngle, endAngle, anticlockwise)</td><td>画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成</td></tr><tr><td>arcTo(x1, y1, x2, y2, radius)</td><td>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点</td></tr><tr><td>quadraticCurveTo(cp1x, cp1y, x, y)</td><td>绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点</td></tr><tr><td>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</td><td>绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点</td></tr><tr><td>rect(x, y, width, height)</td><td>绘制一个左上角坐标为（x,y），宽高为width以及height的矩形</td></tr><tr><td>Path2D.addPath(path [, transform])​</td><td>添加了一条路径到当前路径（可能添加了一个变换矩阵）</td></tr><tr><td>fillStyle = color</td><td>设置图形的填充颜色</td></tr><tr><td>strokeStyle = color</td><td>设置图形轮廓的颜色</td></tr><tr><td>globalAlpha = transparencyValue</td><td>这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0</td></tr><tr><td>lineWidth = value</td><td>设置线条宽度</td></tr><tr><td>lineCap = type</td><td>设置线条末端样式(butt，round和square)</td></tr><tr><td>lineJoin = type</td><td>设定线条与线条间接合处的样式(round，bevel和miter)</td></tr><tr><td>miterLimit = value</td><td>限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度</td></tr><tr><td>getLineDash()</td><td>返回一个包含当前虚线样式，长度为非负偶数的数组</td></tr><tr><td>setLineDash(segments)</td><td>设置当前虚线样式</td></tr><tr><td>lineDashOffset = value</td><td>设置虚线样式的起始偏移量</td></tr><tr><td>createLinearGradient(x1, y1, x2, y2)</td><td>createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)</td></tr><tr><td>createRadialGradient(x1, y1, r1, x2, y2, r2)</td><td>createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆</td></tr><tr><td>gradient.addColorStop(position, color)</td><td>addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）</td></tr><tr><td>createPattern(image, type)</td><td>该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat</td></tr><tr><td>shadowOffsetX/Y = float</td><td>shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0</td></tr><tr><td>shadowBlur = float</td><td>shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0</td></tr><tr><td>shadowColor = color</td><td>shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色</td></tr><tr><td>fillText(text, x, y [, maxWidth])</td><td>在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的</td></tr><tr><td>strokeText(text, x, y [, maxWidth])</td><td>在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的</td></tr><tr><td>font = value</td><td>当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif</td></tr><tr><td>textAlign = value</td><td>文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start</td></tr><tr><td>textBaseline = value</td><td>基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic</td></tr><tr><td>direction = value</td><td>文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit</td></tr></tbody></table><h1 id="绘制和使用图片"><a href="#绘制和使用图片" class="headerlink" title="绘制和使用图片"></a>绘制和使用图片</h1><p>canvas具有图像操作能力，可以用于动态的图像合成或者作为图像的背景，已经游戏界面等等。</p><p>引入图像到canvas需要下面两个操作</p><ol><li>获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片</li><li>使用drawImage()函数将图片绘制到画布上</li></ol><h2 id="可获取图片类型"><a href="#可获取图片类型" class="headerlink" title="可获取图片类型"></a>可获取图片类型</h2><ul><li><p><strong>HTMLImageElement</strong></p><p>这些图片是由Image()函数构造出来的，或者任何的 <code>&lt;img&gt;</code> 元素</p></li><li><p><strong>HTMLVideoElement</strong></p><p>用一个HTML的 <code>&lt;video&gt;</code> 元素作为你的图片源，可以从视频中抓取当前帧作为一个图像</p></li><li><p><strong>HTMLCanvasElement</strong></p><p>可以使用另一个 <code>&lt;canvas&gt;</code> 元素作为你的图片源</p></li><li><p><strong>ImageBitmap</strong></p><p>这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成</p></li></ul><h2 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h2><p>我们可以创建一个新的<code>HTMLImageElement</code>元素，或者直接使用相同页面的图片。如果是其他域的图片，图片需要使用<code>crossOrigin</code>属性，需要图片的服务器允许跨域访问这个图片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();   <span class="comment">// 创建img元素</span></div><div class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 执行drawImage语句</span></div><div class="line">&#125;</div><div class="line">img.src = <span class="string">'myImage.png'</span>; <span class="comment">// 设置图片源地址</span></div></pre></td></tr></table></figure><p>新建的图片中，如果图片还没有加载，我们调用<code>drawImage()</code>什么都不会发生，所以我们的drawImage需要在<code>img.onload</code>里面执行，确保图片加载完毕。</p><p>还有一种方法就是通过<code>data:url</code>方式嵌入图片，可以使用base64格式。</p><h2 id="使用视频帧"><a href="#使用视频帧" class="headerlink" title="使用视频帧"></a>使用视频帧</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMyVideo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</div><div class="line">  <span class="keyword">if</span> (canvas.getContext) &#123;</div><div class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">'myvideo'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2><p>我们获取了源图对象，可以使用<code>drawImage</code>方法将它渲染到canvas里。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>drawImage(image, x, y)</td><td>其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标</td></tr><tr><td>drawImage(image, x, y, width, height)</td><td>这个方法多了2个参数：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小</td></tr><tr><td>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</td><td>第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数最好是参照右边的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。</td></tr></tbody></table><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/Canvas_drawimage.jpg" alt=""></p><h1 id="canvas变形"><a href="#canvas变形" class="headerlink" title="canvas变形"></a>canvas变形</h1><p>变形之前，了解两个状态的保存和恢复<code>save()</code>和<code>restore()</code>。</p><p>save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。</p><p>每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。在做变形之前先保存状态是一个良好的习惯，变形也是相对于整个画板的。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>translate(x, y)</td><td>translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量</td></tr><tr><td>rotate(angle)</td><td>这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值</td></tr><tr><td>scale(x, y)</td><td>scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有</td></tr><tr><td>transform(m11, m12, m21, m22, dx, dy)</td><td>这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵</td></tr><tr><td>setTransform(m11, m12, m21, m22, dx, dy)</td><td>这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。如果任意一个参数是无限大，那么变形矩阵也必须被标记为无限大，否则会抛出异常。从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。</td></tr><tr><td>resetTransform()</td><td>重置当前变形为单位矩阵</td></tr></tbody></table><h1 id="合成和裁切"><a href="#合成和裁切" class="headerlink" title="合成和裁切"></a>合成和裁切</h1><p>globalCompositeOperation 属性设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上。</p><p>源图像 = 您打算放置到画布上的绘图。</p><p>目标图像 = 您已经放置在画布上的绘图。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>source-over</td><td>默认。在目标图像上显示源图像。</td></tr><tr><td>source-atop</td><td>在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。</td></tr><tr><td>source-in</td><td>在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。</td></tr><tr><td>source-out</td><td>在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。</td></tr><tr><td>destination-over</td><td>在源图像上方显示目标图像。</td></tr><tr><td>destination-atop</td><td>在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。</td></tr><tr><td>destination-in</td><td>在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。</td></tr><tr><td>destination-out</td><td>在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。</td></tr><tr><td>lighter</td><td>显示源图像 + 目标图像。</td></tr><tr><td>copy</td><td>显示源图像。忽略目标图像。</td></tr><tr><td>xor</td><td>使用异或操作对源图像与目标图像进行组合。</td></tr></tbody></table><h2 id="裁切路径"><a href="#裁切路径" class="headerlink" title="裁切路径"></a>裁切路径</h2><p><code>clip()</code>裁切路径和普通的 <code>canvas</code> 图形差不多，不同的是它的作用是遮罩，用来隐藏不需要的部分。如右图所示。红边五角星就是裁切路径，所有在路径以外的部分都不会在 <code>canvas</code> 上绘制出来。</p><h1 id="canvas动画"><a href="#canvas动画" class="headerlink" title="canvas动画"></a>canvas动画</h1><p>首先了解一下，canvas动画的基本步骤：</p><ol><li><p>清空canvas</p><p>除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。</p></li><li><p>保存canvas状态</p><p>如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。</p></li><li><p>绘制动画图形</p><p>这一步是重画动画帧。</p></li><li><p>回复canvas状态</p><p>如果已经保存了canvas的状态，可以先恢复它，然会重绘下一帧。</p></li></ol><h2 id="操作动画"><a href="#操作动画" class="headerlink" title="操作动画"></a>操作动画</h2><p>实现动画，我们需要一些定时重绘的方法。简单的有两个方法<code>setInterval</code>和<code>setTimeout</code>方法来控制在设定的时间点上执行重绘。</p><p>可以用<code>window.setInterval()</code>, <code>window.setTimeout()</code>,和<code>window.requestAnimationFrame()</code>来设定定期执行一个指定函数</p><ul><li><code>setInterval(function, delay)</code> 当设定好间隔时间后，function会定期执行。</li><li><code>setTimeout(function, delay)</code> 在设定好的事件之后执行函数。</li><li><code>requestAnimationFrame(callback)</code> 告诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。</li></ul><p>如果不需要和用户互动，可以使用<code>setInterval()</code>方法，它可以定期的执行指定代码。如果我们需要做一个游戏，我们可以使用键盘或者鼠标事件配合<code>setTimeout()</code>方法来实现。通过设置事件监听，我们可以捕捉用户的交互，并执行相应的动作。</p><p><code>window.requestAnimationFrame()</code>实现动画效果。这个方法提供了更加平滑更加有效率的方式来执行动画，当系统准备好了重绘条件的时候，才调用绘制动画帧。一般每秒钟回调函数执行60次，也有可能会被降低。</p><p>还有一个<code>window.cancelAnimationFrame()</code>用于取消动画。</p><h1 id="像素操作"><a href="#像素操作" class="headerlink" title="像素操作"></a>像素操作</h1><p>执行像素操作，我们需要了解一下ImageData对象。</p><p>ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：</p><ul><li><strong>width</strong> 图片宽度，单位是像素</li><li><strong>height</strong> 图片高度，单位是像素</li><li><strong>data</strong> <code>Uint8ClampedArray</code>类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）</li></ul><p>data属性返回一个<code>Uint8ClampedArray</code>,它可以被使用作为查看初始像素数据。每个像素用四个1bytes值（按照red，green，blue和alpha），rgba的顺序来排列。</p><p>每个部分的颜色值部分用0至255来表示，每个部分被分配到一个数组内连续的索引，左上角像素的红色部分在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。</p><p>如要读取，第50行，第200列的像素的蓝色部分，你会写以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blueComponent = imageData.data[((<span class="number">50</span>*(imageData.width*<span class="number">4</span>)) + (<span class="number">200</span>*<span class="number">4</span>)) + <span class="number">2</span>];</div></pre></td></tr></table></figure><h2 id="创建一个ImageData对象"><a href="#创建一个ImageData对象" class="headerlink" title="创建一个ImageData对象"></a>创建一个ImageData对象</h2><p>去创建一个新的，空白的ImageData对象，你应该会使用<code>createImageData()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myImageData = ctx.createImageData(width, height);</div><div class="line"><span class="comment">// 创建了一个新的具体特定尺寸的ImageData对象。所有像素被预设为透明黑</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> myImageData = ctx.createImageData(anotherImageData)</div><div class="line"><span class="comment">// 尺寸相同，依旧是透明黑</span></div></pre></td></tr></table></figure><h2 id="得到场景像素数据"><a href="#得到场景像素数据" class="headerlink" title="得到场景像素数据"></a>得到场景像素数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取指定区域的画布对象</span></div><div class="line"><span class="keyword">var</span> myImageData = ctx.getImageData(left, top, width, height)</div></pre></td></tr></table></figure><p>下面看一个颜色选择器的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">img.src = <span class="string">'./cat.jpg'</span>;</div><div class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</div><div class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">  img.style.display = <span class="string">'none'</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> color = <span class="built_in">document</span>.getElementById(<span class="string">'color'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> x = event.layerX;</div><div class="line">  <span class="keyword">var</span> y = event.layerY;</div><div class="line">  <span class="keyword">var</span> pixel = ctx.getImageData(x, y, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">  <span class="keyword">var</span> data = pixel.data;</div><div class="line">  <span class="keyword">var</span> rgba = <span class="string">'rgba('</span> + data[<span class="number">0</span>] + <span class="string">','</span> + data[<span class="number">1</span>] + <span class="string">','</span> + data[<span class="number">2</span>] + <span class="string">','</span> + (data[<span class="number">3</span>] / <span class="number">255</span>) + <span class="string">')'</span>;</div><div class="line">  color.style.background =  rgba;</div><div class="line">  color.textContent = rgba;</div><div class="line">&#125;</div><div class="line">canvas.addEventListener(<span class="string">'mousemove'</span>, pick);</div></pre></td></tr></table></figure><h2 id="在场景中写入数据"><a href="#在场景中写入数据" class="headerlink" title="在场景中写入数据"></a>在场景中写入数据</h2><p>可以利用putImageData()方法对场景进行像素数据的写入。</p><p><code>ctx.putImageData(myImageData, dx, dy);</code></p><p>dx和dy参数表示你希望在场景内左上角绘制的像素数据得到的设备坐标。</p><h2 id="缩放和反锯齿"><a href="#缩放和反锯齿" class="headerlink" title="缩放和反锯齿"></a>缩放和反锯齿</h2><p><code>imageSmoothingEnabled</code>默认是启用的，想要关闭需要添加不同的浏览器前缀来手动关闭。</p><h1 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h1><p><code>HTMLCanvasElement</code>提供一个toDataURL()方法，此方法在保存图片的时候有用。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>canvas.toDataURL(‘image/png’)</td><td>默认设定。创建一个PNG图片。</td></tr><tr><td>canvas.toDataURL(‘image/jpeg’, quality)</td><td>创建一个JPG图片。你可以有选择地提供从0到1的品质量，1表示最好品质，0基本不被辨析但有比较小的文件大小。</td></tr><tr><td>canvas.toBlob(callback, type, encoderOptions)</td><td>这个创建了一个在画布中的代表图片的Blob对象</td></tr></tbody></table><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ul><li>在离屏canvas上预渲染相似的图形或重复的对象</li><li>避免浮点数的坐标点，用整数取而代之</li><li>不要在用drawImage时缩放图像</li><li>使用多层画布去画一个复杂的场景</li><li>用CSS设置大的背景图</li><li>用CSS transforms特性缩放画布</li><li>使用moz-opaque属性(仅限Gecko)</li></ul><h2 id="更多贴士"><a href="#更多贴士" class="headerlink" title="更多贴士"></a>更多贴士</h2><ul><li>将画布的函数调用集合到一起（例如，画一条折线，而不要画多条分开的直线）</li><li>避免不必要的画布状态改变</li><li>渲染画布中的不同点，而非整个新状态</li><li>尽可能避免 shadowBlur特性</li><li>尽可能避免text rendering</li><li>使用不同的办法去清除画布(clearRect() vs. fillRect() vs. 调整canvas大小)</li><li>有动画，请使用window.requestAnimationFrame() 而非window.setInterval()</li><li>请谨慎使用大型物理库</li><li>用<a href="https://jsperf.com/" target="_blank" rel="noopener">JSPerf</a>测试性能</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个星期抽空看了下canvas，之前一直就对这两个东西望而却步，连简单的api和应用都没有了解。&lt;/p&gt;
&lt;p&gt;工作中看到了&lt;a href=&quot;https://html2canvas.hertzen.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;html2canvas&lt;/a&gt;这个简单的工具可以根据DOM生成截图，于是抽空将MDN上的&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;canvas&lt;/a&gt;教程撸了一遍。&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="https://hddhyq.github.io/categories/canvas/"/>
    
    
      <category term="html5" scheme="https://hddhyq.github.io/tags/html5/"/>
    
      <category term="canvas" scheme="https://hddhyq.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>touch事件&amp;&amp;mouse事件&amp;&amp;PC端&amp;&amp;移动端总结</title>
    <link href="https://hddhyq.github.io/2018/07/12/touch%E4%BA%8B%E4%BB%B6-mouse%E4%BA%8B%E4%BB%B6-PC%E7%AB%AF-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://hddhyq.github.io/2018/07/12/touch事件-mouse事件-PC端-移动端总结/</id>
    <published>2018-07-12T09:04:01.000Z</published>
    <updated>2018-12-09T14:14:41.198Z</updated>
    
    <content type="html"><![CDATA[<p>最近几天看的东西比较杂，抽空做下小总结。本来想研究下PC端的mousedown，mousemove，mouseup在移动端的浏览器的表现，如何用touch来替代，结果不知不觉，重新看了下JS高程的事件处理章节，关于各种浏览器的clinetX,pageX也看了不少，接下来就做下总结了。<br><a id="more"></a></p><h1 id="touches对象的各种参数"><a href="#touches对象的各种参数" class="headerlink" title="touches对象的各种参数"></a>touches对象的各种参数</h1><h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><ul><li><code>touchstart</code>: 手指放在屏幕上的时候出发：即使已经有一个手指放在屏幕上也会触发。</li><li><code>touchmove</code>：当手指在屏幕上连续地出发。期间调用<code>preventDefault()</code>会阻止默认滚动。</li><li><code>touchend</code>：当手指从屏幕上移开时出发。</li><li><code>touchcancel</code>：当系统停止跟踪触摸时出发。</li></ul><p>这几个事件都会冒泡，也都能取消。</p><p>下面放一下移动端跟踪触摸的时候三个event事件属性。</p><ul><li><code>touches</code>：表示当前跟踪的触摸操作的<code>Touch</code>对象的数组。</li><li><code>targetTouches</code>：特定于事件目标的<code>Touch</code>对象的数组。</li><li><code>changedTouches</code>：表示自上次触摸以来发生改变的<code>Touch</code>对象的数组。</li></ul><h3 id="touches"><a href="#touches" class="headerlink" title="touches"></a>touches</h3><p>下面是touches属性介绍：</p><table><thead><tr><th>属性</th><th>属性含义</th></tr></thead><tbody><tr><td>clientX, Y</td><td>触摸目标在视口中的x, y坐标，不包括任何滚动偏移</td></tr><tr><td>force</td><td>触摸手指挤压触摸平面的压力大小0.0-1.0之间</td></tr><tr><td>identifier</td><td>表示触摸的唯一ID</td></tr><tr><td>pageX, Y</td><td>触摸目标在页面中的x, y坐标</td></tr><tr><td>radiusX, Y</td><td>能够包围用户和触摸平面的接触面的最小椭圆的水平轴(X轴),垂直轴(Y轴)半径</td></tr><tr><td>rotationAngle</td><td>上述椭圆的能精准覆盖用户与触摸平面的接触面的角度，取值0-90之间</td></tr><tr><td>screenX, Y</td><td>返回触点相对于屏幕左边沿的的X, y坐标. 不包含页面滚动的偏移量</td></tr><tr><td>target</td><td>触摸touchstart触摸在屏幕上返回的element</td></tr></tbody></table><h1 id="mouse事件的各种参数"><a href="#mouse事件的各种参数" class="headerlink" title="mouse事件的各种参数"></a>mouse事件的各种参数</h1><p>DOM3级事件中有九个鼠标事件，顺便放一下<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener">事件速查表</a>.</p><table><thead><tr><th>事件名</th><th>触发条件</th></tr></thead><tbody><tr><td>click</td><td>用户点击主鼠标按钮或者按下回车键触发</td></tr><tr><td>dbclick</td><td>用户双击主鼠标按钮触发</td></tr><tr><td>mousemove</td><td>鼠标指针在元素内部移动时重复触发</td></tr><tr><td>mouseup</td><td>用户释放鼠标shi</td></tr><tr><td>mousedown</td><td>用户按下任意鼠标按钮触发，不能通过键盘触发这个事件</td></tr><tr><td>mouseenter</td><td>指针移到有事件监听的元素内（不冒泡）</td></tr><tr><td>mouseleave</td><td>指针移出元素范围外（不冒泡）</td></tr><tr><td>mouseover</td><td>指针移到有事件监听的元素或者它的子元素内</td></tr><tr><td>mouseout</td><td>指针移出元素，或者移到它的子元素上</td></tr></tbody></table><p>这里了解一下click的顺序，<code>mousedown</code> -&gt; <code>mouseup</code> -&gt; <code>click</code>。这里click是依赖先行事件mousedown，mouseup运行的。也就是说，假如我们的拖动的div上绑定有一个click事件，拖动的过程中，就会在mouseup后面触发click事件。所以我们可以将click事件绑定到mouseup上面，判断是否有mousemove来考虑触发click上绑定的事件的时机。</p><h1 id="事件处理，事件监听，事件委托"><a href="#事件处理，事件监听，事件委托" class="headerlink" title="事件处理，事件监听，事件委托"></a>事件处理，事件监听，事件委托</h1><p>DOM事件流规定中，事件流包含三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。在DOM事件流中，实际的元素在捕获阶段不会接收到事件。这意味着事件处理会被当做冒泡阶段的一部分。</p><h2 id="事件处理的几种常见方法"><a href="#事件处理的几种常见方法" class="headerlink" title="事件处理的几种常见方法"></a>事件处理的几种常见方法</h2><h3 id="1-HTML事件处理程序"><a href="#1-HTML事件处理程序" class="headerlink" title="1. HTML事件处理程序"></a>1. HTML事件处理程序</h3><p>直接在html上绑定一个事件，事件处理程序一般以<code>&#39;on&#39;</code>开头。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 绑定执行语句 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">onclick</span>=<span class="string">"alert('clicked')"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!-- 绑定函数 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">    alert(<span class="string">'clickclickclicked!'</span>)</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><p>上述事件处理程序会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象。</p><p>通过event变量，可以直接访问到事件对象，你不用从函数的参数列表读取。在函数内部，this等于事件的目标元素。那么这里需要注意了，事件处理函数中的this指向的问题。所以在需要添加到this的函数中，我们有时会用词法作用域context来保存需要调用的上下文。像上一篇文章中<a href="https://hddhyq.github.io/2018/07/08/%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96debounce%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81throttle%E7%9A%84%E5%BA%94%E7%94%A8/#more">函数节流</a>，就用到了相关保存运行时this的方法。</p><h3 id="2-DOM-0级事件处理"><a href="#2-DOM-0级事件处理" class="headerlink" title="2. DOM 0级事件处理"></a>2. DOM 0级事件处理</h3><p>使用传统的JavaScript指定事件处理方式，先获取到相关的需要操作对象的引用。</p><p>每个元素都有自己的事件处理程序属性，这些属性通常全部小写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</div><div class="line"></div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'this.id'</span>);  <span class="comment">// 'myBtn'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 清空事件绑定</span></div><div class="line">btn.onclick = <span class="literal">null</span>;</div></pre></td></tr></table></figure><p>这种形式添加的事件处理程序会在事件流的冒泡阶段被处理。</p><h3 id="3-DOM-2级事件处理程序"><a href="#3-DOM-2级事件处理程序" class="headerlink" title="3. DOM 2级事件处理程序"></a>3. DOM 2级事件处理程序</h3><p>所有的DOM节点都包含两个方法，<code>addEventListener()</code>和<code>removeEventListener()</code>，并接受三个参数：事件名，作为事件处理程序的函数和一个布尔值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'hello hdd'</span>);</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line"></div><div class="line">btn.removeEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 没有用</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'hello hdd'</span>);</div><div class="line">&#125;, <span class="literal">false</span>); </div><div class="line"><span class="comment">// 上述代码无法删除相关的事件处理函数，因为两个匿名函数不是同一个函数了。</span></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> handler =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'hello hdd'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">btn.addEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>);</div><div class="line">btn.removeEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>);</div></pre></td></tr></table></figure><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>event对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过所有事件都会有下表列出的成员。下表的属性都是只读的。</p><table><thead><tr><th>属性/方法</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>bubbles</td><td>Boolean</td><td>表明事件是否冒泡</td></tr><tr><td>cancelable</td><td>Boolean</td><td>表明是否可以取消事件的默认行为</td></tr><tr><td>currentTarget</td><td>Element</td><td>其事件处理程序当前正在处理的那个元素</td></tr><tr><td>defaultPrevented</td><td>Boolean</td><td>是否调用preventDefault()</td></tr><tr><td>detail</td><td>Integer</td><td>与事件相关的细节信息</td></tr><tr><td>eventPhase</td><td>Interger</td><td>调用事件处理程序的阶段：1.捕获阶段2.处于目标3.冒泡阶段</td></tr><tr><td>preventDefault()</td><td>Function</td><td>取消事件的默认行为。如果cancelable是true，则可以使用这个方法</td></tr><tr><td>stopImmediatePropagation()</td><td>Function</td><td>取消事件的进一步捕获或冒泡，同时阻止任何使劲按处理程序被调用</td></tr><tr><td>stopPropagation</td><td>Function</td><td>取消使劲按的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法</td></tr><tr><td>target</td><td>Element</td><td>事件的目标</td></tr><tr><td>trusted</td><td>Boolean</td><td>true表示浏览器生成的，false表示开发者通过JavaScript创建的</td></tr><tr><td>type</td><td>String</td><td>被触发的事件类型</td></tr><tr><td>view</td><td>AbstractView</td><td>与事件关联的抽象试图。等同于发生对象的window对象</td></tr></tbody></table><p>在事件处理程序的内部，this始终等于<code>currentTarget</code>的值，而<code>target</code>则只包含事件的实际目标。下面点击子元素：</p><ol><li>子元素绑定事件处理程序，父元素绑定事件处理函数。<code>currentTarget</code>等于父元素，<code>target</code>等于子元素</li><li>子元素不绑定事件处理程序，父元素绑定事件处理函数。<code>currentTarget</code>等于父元素，<code>target</code>等于子元素</li><li>子元素绑定事件处理程序，父元素不绑定事件处理函数。<code>currentTarget</code>等于子元素，<code>target</code>等于子元素</li></ol><p>下面看几种常见的事件处理的冒泡次序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</div><div class="line"></div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  alert(event.eventPhase);   <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  alert(event.eventPhase);   <span class="comment">// 1</span></div><div class="line">&#125;, <span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  alert(event.eventPhase);   <span class="comment">// 3</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>最后，事件处理程序执行期间，event对象一直存在，一旦事件处理程序执行完成，event对象就会销毁。</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>想页面添加大量的事件处理程序会占用大量的内存，内存中的对象越多，性能也就越差。而且，必须事先指定所有事件处理程序而导致的DOM访问次数会延迟整个页面的交互就绪时间。</p><p>要理解事件委托，事件冒泡和捕获必须梳理一下。</p><p>当一个事件发生在具有父元素的元素导航，现代浏览器运行两个不同的阶段-捕获阶段和冒泡阶段。</p><p>在现代浏览器中，默认情况下，多有时间处理程序都在冒泡阶段注册，因此当我们点击子元素的时候。会沿着这个事件冒泡线路：</p><ul><li>发现了子元素的事件处理程序，并运行了它。</li><li>往外冒泡发现父元素的事件处理程序，并运行它。</li></ul><p>避免这个问题的方法就是使用<code>stopPropagation()</code>修复问题。</p><p>利用了事件冒泡会发现父元素的事件处理程序。我们就可以利用事件委托。</p><p>如果我们有大量子元素，想要点击任何一个都可以运行一段代码，可以将事件监听器设置在父节点元素，而且对于新添加的元素，事件委托很好的能为动态添加的元素动态的绑定事件处理函数。下面是例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"lists"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"list1"</span>&gt;</span>列表第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"list2"</span>&gt;</span>列表第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"list3"</span>&gt;</span>列表第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'lists'</span>);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  <span class="comment">// 也可以绑定lists元素</span></div><div class="line">  <span class="keyword">var</span> target = event.target;</div><div class="line"></div><div class="line">  <span class="keyword">switch</span>(target.id) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'list1'</span>:</div><div class="line">      <span class="built_in">console</span>.log(target.innerHTML);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'list2'</span>:</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'我是第二项'</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'list3'</span>:</div><div class="line">      alert(<span class="string">'hello world'</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h1 id="浏览器中事件相关的常见几种位置坐标"><a href="#浏览器中事件相关的常见几种位置坐标" class="headerlink" title="浏览器中事件相关的常见几种位置坐标"></a>浏览器中事件相关的常见几种位置坐标</h1><h2 id="clientX-Y"><a href="#clientX-Y" class="headerlink" title="clientX/Y"></a>clientX/Y</h2><p>获取到的是触发点相对浏览器可视区域左上角距离，不随页面滚动而改变。</p><h2 id="pageX-Y"><a href="#pageX-Y" class="headerlink" title="pageX/Y"></a>pageX/Y</h2><p>pageX/Y获取到的是触发点相对文档区域左上角距离，会随着页面滚动而改变。</p><h2 id="offsetX-Y"><a href="#offsetX-Y" class="headerlink" title="offsetX/Y"></a>offsetX/Y</h2><p>offsetX/Y获取到是触发点相对被触发dom的左上角距离，不过左上角基准点在不同浏览器中有区别，其中在IE中以内容区左上角为基准点不包括边框，如果触发点在边框上会返回负值，而chrome中以边框左上角为基准点。</p><h2 id="layerX-Y"><a href="#layerX-Y" class="headerlink" title="layerX/Y"></a>layerX/Y</h2><p>layerX/Y获取到的是触发点相对被触发dom左上角的距离，数值与offsetX/Y相同，这个变量就是firefox用来替代offsetX/Y的，基准点为边框左上角，但是有个条件就是，被触发的dom需要设置为<code>position:relative</code>或者<code>position:absolute</code>，否则会返回相对html文档区域左上角的距离。</p><h2 id="screenX-Y"><a href="#screenX-Y" class="headerlink" title="screenX/Y"></a>screenX/Y</h2><p>screenX/Y获取到的是触发点相对显示器屏幕左上角的距离，不随页面滚动而改变。</p><p>一个图解释：</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/little_tricks/screenX_Y.jpg" alt=""></p><h1 id="简单的移动端-PC端拖动代码"><a href="#简单的移动端-PC端拖动代码" class="headerlink" title="简单的移动端/PC端拖动代码"></a>简单的移动端/PC端拖动代码</h1><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/brokenbonesdd/jabtn2g6/embedded/js,html,css,result/dark" frameborder="0" allowfullscreen></iframe><p>上面的代码中，我将事件的type做了一下判断，进而绑定相关的。</p><h1 id="关于拖拽事件的常见bug及处理方式"><a href="#关于拖拽事件的常见bug及处理方式" class="headerlink" title="关于拖拽事件的常见bug及处理方式"></a>关于拖拽事件的常见bug及处理方式</h1><p>介绍下常见的，拖拽小问题。</p><h2 id="1-鼠标移动过快，离开拖拽物体"><a href="#1-鼠标移动过快，离开拖拽物体" class="headerlink" title="1. 鼠标移动过快，离开拖拽物体"></a>1. 鼠标移动过快，离开拖拽物体</h2><p>由于拖拽的div太小了，拖拽物体不在随着鼠标移动，前面介绍事件的时候也提到了，鼠标移动元素，<code>mousemove</code>事件不再触发，这时我们可以将拖拽物体上的<code>mousemve</code>事件放到<code>document</code>上面，同时将<code>mouseup</code>也改为<code>document</code>上面的事件</p><h2 id="2-会出现将div脱出浏览器窗口"><a href="#2-会出现将div脱出浏览器窗口" class="headerlink" title="2. 会出现将div脱出浏览器窗口"></a>2. 会出现将div脱出浏览器窗口</h2><p>限制div的拖动距离</p><p>还有一些常见bug，一般阻止默认事件都可以解决。</p><h1 id="部分参考"><a href="#部分参考" class="headerlink" title="部分参考"></a>部分参考</h1><ul><li><a href="http://www.cnblogs.com/moqiutao/p/5050225.html" target="_blank" rel="noopener">http://www.cnblogs.com/moqiutao/p/5050225.html</a></li><li><a href="http://www.cnblogs.com/yufann/p/JS-Summary9.html" target="_blank" rel="noopener">http://www.cnblogs.com/yufann/p/JS-Summary9.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几天看的东西比较杂，抽空做下小总结。本来想研究下PC端的mousedown，mousemove，mouseup在移动端的浏览器的表现，如何用touch来替代，结果不知不觉，重新看了下JS高程的事件处理章节，关于各种浏览器的clinetX,pageX也看了不少，接下来就做下总结了。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS基础事件" scheme="https://hddhyq.github.io/tags/JS%E5%9F%BA%E7%A1%80%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="触摸" scheme="https://hddhyq.github.io/tags/%E8%A7%A6%E6%91%B8/"/>
    
  </entry>
  
  <entry>
    <title>函数去抖debounce和函数节流throttle的应用</title>
    <link href="https://hddhyq.github.io/2018/07/08/%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96debounce%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81throttle%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://hddhyq.github.io/2018/07/08/函数去抖debounce和函数节流throttle的应用/</id>
    <published>2018-07-08T04:43:09.000Z</published>
    <updated>2018-07-08T06:42:10.158Z</updated>
    
    <content type="html"><![CDATA[<p>开始以为只有节流函数，原来还有去抖函数啊。两个概念第一次听的话肯定比较容易混淆，接下来就来研究一下它们吧。<br><a id="more"></a></p><h1 id="函数去抖debounce"><a href="#函数去抖debounce" class="headerlink" title="函数去抖debounce"></a>函数去抖debounce</h1><p>在一段时间内执行该动作，在单位时间内重新调用该动作，会重新计算时间。</p><p>我的理解就是，只要触发的够快，函数就追不上我，哈哈哈。</p><p>当我停下来的时候，函数会触发最后一次。所以其中肯定有一个定时器哈，下面展示一下简单实现的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</div><div class="line">    <span class="comment">// 定义一个定时器</span></div><div class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 绑定函数调用时上下文及参数</span></div><div class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</div><div class="line">        args = <span class="built_in">arguments</span>;</div><div class="line">        clearTimeout(timer);</div><div class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'debounce被触发了'</span>);</div><div class="line">            fn.apply(context, args);</div><div class="line">        &#125;, delay);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义一个btn，然后去点它来测试</span></div><div class="line">$(<span class="string">'.btn-click-debounce'</span>).on(<span class="string">'click'</span>, debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'200ms一次'</span>)</div><div class="line">&#125;, <span class="number">200</span>))</div></pre></td></tr></table></figure><h1 id="函数节流throttle"><a href="#函数节流throttle" class="headerlink" title="函数节流throttle"></a>函数节流throttle</h1><p>将倾斜而出的水流，一点一点的流出，这就是节流。放在函数触发中，就是本来快速l连续触发的事件以单位时间为间隔来触发。简单实现的源码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, threshhold</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> last = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</div><div class="line">    threshhold || (threshhold = <span class="number">200</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// Date.now();</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(last &amp;&amp; ((now &lt; last + threshhold)) &#123;</div><div class="line">            <span class="comment">// 判断时间间隔，以及是否第一次触发</span></div><div class="line">            clearTimeout(timer);</div><div class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                last = now;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'throttle被触发了'</span>);</div><div class="line">                fn.apply(context, args);</div><div class="line">            &#125;, threshhold)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            last = now;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'throttle被触发了'</span>);</div><div class="line">            fn.apply(context, args);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$(<span class="string">'.btn-click-throttle'</span>).on(<span class="string">'click'</span>, throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'200ms一次'</span>)</div><div class="line">&#125;, <span class="number">200</span>))</div></pre></td></tr></table></figure></p><h1 id="使用的场景"><a href="#使用的场景" class="headerlink" title="使用的场景"></a>使用的场景</h1><h2 id="throttle函数节流"><a href="#throttle函数节流" class="headerlink" title="throttle函数节流"></a>throttle函数节流</h2><ul><li>Dom元素的拖拽实现（mousemove）</li><li>射击游戏的mousedown/keydown事件（单位时间只能发射一颗子弹）</li><li>计算鼠标移动的距离（mousemove）</li><li>Canvas模拟画板功能</li><li>搜索联想（keyup）</li><li>监听滚动事件是否到底部自动加载更多（<br>监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次）</li></ul><h2 id="debounce应用场景"><a href="#debounce应用场景" class="headerlink" title="debounce应用场景"></a>debounce应用场景</h2><ul><li>每次resize/scroll触发统计</li><li>文本输入的验证（连续输入文字后发送ajax进行验证，验证一次就好）</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/zichi/p/5948936.html" target="_blank" rel="noopener">http://www.cnblogs.com/zichi/p/5948936.html</a></p><p><a href="https://www.cnblogs.com/fsjohnhuang/p/4147810.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsjohnhuang/p/4147810.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始以为只有节流函数，原来还有去抖函数啊。两个概念第一次听的话肯定比较容易混淆，接下来就来研究一下它们吧。&lt;br&gt;
    
    </summary>
    
      <category term="JStricks" scheme="https://hddhyq.github.io/categories/JStricks/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="优化" scheme="https://hddhyq.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于之前看看的一些css</title>
    <link href="https://hddhyq.github.io/2018/06/12/%E5%85%B3%E4%BA%8E%E4%B9%8B%E5%89%8D%E7%9C%8B%E7%9C%8B%E7%9A%84%E4%B8%80%E4%BA%9Bcss/"/>
    <id>https://hddhyq.github.io/2018/06/12/关于之前看看的一些css/</id>
    <published>2018-06-12T06:44:28.000Z</published>
    <updated>2018-07-08T04:25:55.520Z</updated>
    
    <content type="html"><![CDATA[<p>记一下上个月看的图解CSS的一些简单的知识点哈。<br><a id="more"></a></p><h1 id="元素百分比的相对计算"><a href="#元素百分比的相对计算" class="headerlink" title="元素百分比的相对计算"></a>元素百分比的相对计算</h1><table><thead><tr><th>相对的元素计算</th><th>属性</th></tr></thead><tbody><tr><td>父元素宽度</td><td><code>width</code>, <code>left</code>, <code>right</code>, <code>text-indent</code>, <code>padding</code>, <code>margin</code>等</td></tr><tr><td>父元素高度</td><td><code>height</code>, <code>top</code>, <code>bottom</code>等</td></tr><tr><td>主轴长度</td><td><code>flex-basis</code></td></tr><tr><td>继承字号</td><td><code>flex-size</code></td></tr><tr><td>自身字号</td><td><code>line-height</code></td></tr><tr><td>自身宽高</td><td><code>vertical-align</code></td></tr><tr><td>自身设置</td><td><code>background-position</code>; <code>border-image-slice</code></td></tr><tr><td>特殊算法</td><td><code>position: absolute</code>，相对于父元素最近的<code>position</code>不为<code>static</code>的祖先元素。如果没有这样的元素，则相对于视口。</td></tr></tbody></table><h1 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h1><table><thead><tr><th>选择器</th><th>功能描述</th></tr></thead><tbody><tr><td>E:first-child</td><td>作为父元素的第一个子元素E</td></tr><tr><td>E:last-child</td><td>作为父元素的最后一个子元素的元素E</td></tr><tr><td>E:root</td><td>选择匹配元素E所在文档的根元素</td></tr><tr><td>E F:nth-child(n)</td><td>选择父元素的第n个子元素F</td></tr><tr><td>E F:nth-last-child(n)</td><td>选择元素E的倒数第n个子元素F</td></tr><tr><td>E:nth-of-type(n)</td><td>选择父元素内具有指定类型的第n个E元素</td></tr><tr><td>E:nth-last-of-type(n)</td><td>选择父元素内具有指定类型的倒数第n个E元素</td></tr><tr><td>E:first-of-type</td><td>选择父元素内具有指定类型的的第一个E元素，与E:nth-of-type(1)相同</td></tr><tr><td>E:last-of-type</td><td>选择父元素内具有指定类型的的最后一个E元素，与E:nth-last-of-type(1)相同</td></tr><tr><td>E:only-child</td><td>选择父元素只包含一个字元素，且该子元素匹配E元素</td></tr><tr><td>E:only-of-type</td><td>选择父元素只包含一个同类型的子元素，且该子元素匹配E元素</td></tr><tr><td>E:empty</td><td>选择没有子类型的元素，而且该元素也不包含任何文本节点</td></tr></tbody></table><p>关于，伪类元素选择器中n的用法，也就是n取0到+∞，在子元素的个数范围内，取相对应的子元素。</p><h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><p>伪类一般反映无法在CSS中轻松或可靠地检测到的某个元素的属性或状态；伪元素则表示DOM外部的某种元素。</p><table><thead><tr><th>伪元素</th><th>功能描述</th></tr></thead><tbody><tr><td>::first-letter</td><td>选择文本块的第一个字母，除非在同一行中包含一些其他元素</td></tr><tr><td>::first-line</td><td>匹配元素的第一行文本</td></tr><tr><td>::before和::after</td><td>生成的内容不会成为DOM的一部分，但是可以设置样式</td></tr><tr><td>::selection</td><td>匹配突出显示的文本，可设置background和color</td></tr></tbody></table><h1 id="border相关"><a href="#border相关" class="headerlink" title="border相关"></a>border相关</h1><h2 id="border-shadow"><a href="#border-shadow" class="headerlink" title="border-shadow"></a>border-shadow</h2><table><thead><tr><th>属性</th><th>功能描述</th></tr></thead><tbody><tr><td>none</td><td>默认值，元素没有任何阴影效果</td></tr><tr><td>inset</td><td>阴影类型，可选值。默认外投影</td></tr><tr><td>x-offset</td><td>阴影水平偏移量，其值可以是正负值。正值在元素右边</td></tr><tr><td>y-offset</td><td>阴影垂直偏移量，其值可以是正负值。正值在元素底部</td></tr><tr><td>blur-radius</td><td>阴影模糊半径，可选参数。取值为0，表示阴影不具有模糊效果，取值越大，阴影的边缘越模糊</td></tr><tr><td>spread-radius</td><td>阴影扩展半径，可选参数。正值整个阴影都延展扩大，负值，整个阴影缩小</td></tr><tr><td>color</td><td>阴影颜色，不取值则是默认色，各个浏览器的默认色不一样的。</td></tr></tbody></table><h1 id="css3背景"><a href="#css3背景" class="headerlink" title="css3背景"></a>css3背景</h1><p>主要有</p><ul><li>background-color 背景颜色</li><li>background-image 背景图片</li><li>background-repeat 背景图片展示方式</li><li>background-attachment 背景图片是固定还是滚动</li><li>background-position 背景图片位置</li></ul><p>CSS3新增属性</p><ul><li>background-origin 指定绘制背景图片的起点（padding-box||border-box||content-box）</li><li>background-clip 指定背景图片的显示范围（padding-box||border-box||content-box）</li><li>background-size 指定背景图片的尺寸大小（auto||percentage||cover||contain）</li><li>background-break 指定内联元素的背景图片进行平铺时的循环方式</li></ul><h1 id="css文本类型"><a href="#css文本类型" class="headerlink" title="css文本类型"></a>css文本类型</h1><table><thead><tr><th>属性</th><th>功能描述</th><th>取值</th></tr></thead><tbody><tr><td>word-spacing</td><td>定义词与词之间的间距</td><td>normal，length（设置词与词之间间距，可以是负数）</td></tr><tr><td>letter-spacing</td><td>定义字符之间的间距</td><td>normal，length（设置词与词之间间距，可以是负数）</td></tr><tr><td>vertiacl-align</td><td>定义文本的垂直对齐方式</td><td>baseline、sub（上标对齐）、super（下标对齐）、bottom（行框底端对齐）、text-bottom（行内文本底端对齐）、top（顶端对齐）、middle（居中对齐）、百分比数字、长度</td></tr><tr><td>text-decoration</td><td>定义文本的修饰线</td><td>none、underline、overline、line-through、blink</td></tr><tr><td>text-indent</td><td>定义文本首行缩进</td><td>length（长度单位）和百分比</td></tr><tr><td>text-align</td><td>定义文本水平对齐方式</td><td>left（左对齐）、center（水平对齐）、right（右对齐）、justify（两端对齐）</td></tr><tr><td>line-height</td><td>定义文本行高</td><td>normal、长度值、百分比值、数字</td></tr><tr><td>text-transform</td><td>定义文本大小写</td><td>none、uppercase、lowercase、capitalize（首字母大写）</td></tr><tr><td>text-shadow</td><td>定义文本阴影效果</td><td></td></tr><tr><td>white-space</td><td>定义文字之间和文本之间的空白符间距</td><td>normal、nowrap（空白符合并，换行符忽略）、pre（空白符，换行符保留）、pre-wrap（空白符，换行符保留）、pre-line（空白符合，换行符保留）</td></tr><tr><td>direction</td><td>控制文本流入的方向</td><td>ltr、rtl（文本从右到左流入）、inhert（文本流入方向有继承获得）</td></tr></tbody></table><p><code>text-overflow</code>：实现文本溢行处理，<code>word-break: break-all</code>来实现浏览器文本的换行</p><p>多行文本怎么实现文本溢出…,在webkit内核<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">display: -webkit-box</div><div class="line">-webkit-line-clamp: 2</div><div class="line">-webkit-box-orient: vertical</div></pre></td></tr></table></figure></p><h1 id="指定过渡属性transition-property"><a href="#指定过渡属性transition-property" class="headerlink" title="指定过渡属性transition-property"></a>指定过渡属性transition-property</h1><ul><li>none： 没有指定任何样式。</li><li>all：默认值，表示指定元素所有支持transition-property属性的样式。</li><li><code>&lt;single-transition-property&gt;</code>：指定样式，其等于all或者<ident>。</ident></li><li>颜色属性</li><li>具有长度值</li><li>integer（离散步骤，整个数字，在真实的数字空间，以及使用floor()转换为整数时发生，如outline-offset，z-index）</li><li>number</li><li>变形系列属性</li><li>rectangle（通过x，y，width，height（转为数值）变换，如crop属性）</li><li>visibility（离散步骤，在0~1范围内。0表示隐藏，1表示完全显示）</li><li>阴影（shadow，如text-shadow）</li><li>渐变（gradient）：通过每次停止时的位置和颜色进行变化。</li><li>paint server(SVG)</li><li>space-separated list of above</li><li>缩写属性</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记一下上个月看的图解CSS的一些简单的知识点哈。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://hddhyq.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://hddhyq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JS-this和原型对象</title>
    <link href="https://hddhyq.github.io/2018/05/14/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-this%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>https://hddhyq.github.io/2018/05/14/你不知道的JS-this和原型对象/</id>
    <published>2018-05-14T07:11:34.000Z</published>
    <updated>2018-07-08T04:25:55.519Z</updated>
    
    <content type="html"><![CDATA[<p>这里我总结了下，《你不知道的javaScript上卷》第二部分的内容，总结的可能比较简短，相关的知识点，与设计模式中间有重合，设计模式中的相关设计模式，后期也会补上。<br><a id="more"></a></p><h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h1><h2 id="为什么要用this呢？"><a href="#为什么要用this呢？" class="headerlink" title="为什么要用this呢？"></a>为什么要用this呢？</h2><p>如果没有this，我们需要调用变量名，才能在函数或者方法中调用相关它自己，如果有了this，我们就能用一种更优雅的方式“传递”一个对象的引用。因此可以将API设计的更加简洁并且易于复用。</p><p>随着你使用的模式越来越复杂，显示传递上下文对象会使代码变得越来越混乱，使用this则不会这样。</p><h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><p>关于两种常见的对于this的解释，但是他们都是错误的。</p><h3 id="指向自身"><a href="#指向自身" class="headerlink" title="指向自身"></a>指向自身</h3><p>很多人很容易吧this联想到它的英文意思，指向函数本身，但是this的绑定是动态的！</p><p>看一个例子吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</div><div class="line">  <span class="comment">// 记录 foo 被调用的次数</span></div><div class="line">  <span class="keyword">this</span>.count++;</div><div class="line">&#125;</div><div class="line">foo.count = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> i;</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</div><div class="line">    foo( i );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// foo: 6</span></div><div class="line"><span class="comment">// foo: 7</span></div><div class="line"><span class="comment">// foo: 8</span></div><div class="line"><span class="comment">// foo: 9</span></div><div class="line"><span class="comment">// foo 被调用了多少次？</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 0 -- WTF?</span></div></pre></td></tr></table></figure><p>上面的this绑定到哪里了呢？答案是全局。</p><h3 id="它的作用域"><a href="#它的作用域" class="headerlink" title="它的作用域"></a>它的作用域</h3><p>第二种常见的误解是，this指向函数的作用域。</p><p>再看一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="keyword">this</span>.bar();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(); <span class="comment">// ReferenceError: a is not defined</span></div></pre></td></tr></table></figure><p>这里我们既想用词法作用域，又想调用this来引入我们想用的函数体的变量。</p><p>这里稍微解析一下， <code>this.bar()</code> 引用的是外部的全局的 <code>bar()</code> 函数，这样里面的语句， <code>console.log(this.a)</code> 查找的也是全局的 <code>a</code> 变量。我们知道函数定义的 <code>a</code> 变量是影响不了全局的 <code>a</code> 变量的。所以这里我们会抛出一个引用错误。</p><h3 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h3><p>排除了错误的理解后，我们看看this到底是什么样的机制。</p><p>之前我们说过this是在运行时进行绑定的，并不是在编写时绑定，他的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置灭有任何关系，只取决于函数的调用方式。</p><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等消息。this就是记录的其中一个属性，会在函数执行的过程中用到。</p><p>下一章我们会学习如何寻找函数的滴啊用位置，从而判断函数在执行的过程中会如何绑定this。</p><h1 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h1><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>就像前面说的，调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个this到底引用的是什么？</p><p>通常来说，寻找滴啊用位置就是寻找“函数被调用的位置”，但是做起来没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。</p><p>最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当前调用栈是：baz</span></div><div class="line">  <span class="comment">// 因此，当前调用位置是全局作用域</span></div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"baz"</span> );</div><div class="line">  bar(); <span class="comment">// &lt;-- bar 的调用位置</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当前调用栈是 baz -&gt; bar</span></div><div class="line">  <span class="comment">// 因此，当前调用位置在 baz 中</span></div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"bar"</span> );</div><div class="line">  foo(); <span class="comment">// &lt;-- foo 的调用位置</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></div><div class="line">  <span class="comment">// 因此，当前调用位置在 bar 中 // 这里放一个断点可以查看当前调用栈，倒数第二个就是真正的调用位置。</span></div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"foo"</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line">baz(); <span class="comment">// &lt;-- baz 的调用位置</span></div></pre></td></tr></table></figure><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><p>这里也简要的解释四种规则：</p><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h3><p>最常用的函数调用类型：独立函数调用。可以把这条规则看做是无法应用其他规则时的默认规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">foo(); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>怎么知道应用了默认绑定呢？可以通过调用位置来看看 <code>foo()</code> 是如何调用的。在代码中，<code>foo()</code>是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。如果使用严格模式，将默认无法使用默认绑定的，因为this会绑定为undefined。</p><h3 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h3><p>另一种需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。</p><p>常见的对象的方法，就是隐式绑定。对象属性引用链只有最顶层或者说最后一层会影响调用位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  a: <span class="number">42</span>,</div><div class="line">  foo: foo</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  obj2: obj2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj1.obj2.foo(); <span class="comment">// 42</span></div></pre></td></tr></table></figure><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>因为this的绑定会根据runtime，所以，思考下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = obj.foo;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">"全局对象a"</span>;</div><div class="line"></div><div class="line">bar(); <span class="comment">// 全局对象a</span></div></pre></td></tr></table></figure><p>还有一种是常见的回调函数中的this隐式丢失，看下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a 是全局对象的属性</span></div><div class="line"></div><div class="line">setTimeout( obj.foo, <span class="number">100</span> ); <span class="comment">// "oops, global"</span></div><div class="line"></div><div class="line"><span class="comment">// JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn,delay</span>) </span>&#123;</div><div class="line">  <span class="comment">// 等待 delay 毫秒</span></div><div class="line">  fn(); <span class="comment">// &lt;-- 调用位置！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来，我们会介绍相关的通过固定this来fix,this所指向的对象或者说上下文context。</p><h3 id="3-显示绑定"><a href="#3-显示绑定" class="headerlink" title="3. 显示绑定"></a>3. 显示绑定</h3><p>分析隐式绑定时，我们必须在一个对象的内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上。</p><p>我们可以通过call(..)和apply(..)方法，来在某个函数中强制指定到this的上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.call( obj ); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p><h4 id="1-硬绑定"><a href="#1-硬绑定" class="headerlink" title="1. 硬绑定"></a>1. 硬绑定</h4><p>思考下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  foo.call(obj);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  foo.call(obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这里，我们在 <code>bar</code> 内部实现了一个 <code>foo.call(obj)</code>，因此强制把 <code>foo</code> 的 <code>this</code> 绑定到了 <code>obj</code> 。无论之后如何调用函数 <code>bar</code> ，它总会在 <code>obj</code> 上调用 <code>foo</code> 。这种绑定是一种显式的强制绑定，因此我们称之为 <strong>硬绑定</strong>。</p><p>ES5中提供了内置的方法，<strong>Function.prototype.bind</strong></p><h4 id="2-API调用的“上下文”"><a href="#2-API调用的“上下文”" class="headerlink" title="2. API调用的“上下文”"></a>2. API调用的“上下文”</h4><p>第三方库的许多函数，以及 <strong>JavaScript</strong> 语言和宿主环境中许多新的内置函数，都提供了一<br>个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调<br>函数使用指定的 <code>this</code>。</p><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( el, <span class="keyword">this</span>.id );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  id: <span class="string">"awesome"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 调用 foo(..) 时把 this 绑定到 obj</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj );</div><div class="line"><span class="comment">// 1 awesome 2 awesome 3 awesome</span></div></pre></td></tr></table></figure></p><p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些<br>代码。</p><h3 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4. new绑定"></a>4. new绑定</h3><p>在JavaScript中，构造函数只是一些使用 <code>new</code> 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至不能说是一种特殊的函数类型，它们只是被 <code>new</code> 操作符调用的普通函数。</p><p>使用 <code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li>创建（或者说构造）一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的 <code>this</code> 。</li><li>如果函数没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象。</li></ol><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ol><li>函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。</li><li>函数是否通过call、apply（显示绑定）或者硬绑定调用？如果是的话，this绑定的是制定的对象。</li><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。</li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。</li></ol><h2 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h2><p>在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用<br>的可能是默认绑定规则。</p><h3 id="1-被忽略的this"><a href="#1-被忽略的this" class="headerlink" title="1. 被忽略的this"></a>1. 被忽略的this</h3><p>如果你把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用的时候会被忽略，实际应用的是默认绑定规则。</p><p>如果函数并不关心this的话，你仍然需要传入一个占位符，常见的就是用null，可是这里用null来忽略this绑定可能会产生一些副作用。如果这个函数中确实使用了this，那默认绑定规则会把this绑定到全局对象，在浏览器这个对象是window，这将产生不可预计的后果。</p><p><strong>更安全的this</strong></p><p>一种“更安全”的做法是，闯入一个特殊的对象，常见方法，<code>Object.create(null)</code>。如果引入的是这个空对象，这样就比较安全了，这样很明确的表示this是空，即使函数中调用了this，也不会更改全局对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = <span class="number">200</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line"></div><div class="line">foo.call(ø)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a)</div><div class="line"><span class="comment">// 200 2</span></div></pre></td></tr></table></figure><h3 id="2-间接引用"><a href="#2-间接引用" class="headerlink" title="2. 间接引用"></a>2. 间接引用</h3><p>另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这<br>种情况下，调用这个函数会应用默认绑定规则。</p><p>常见的就是赋值的时候发生。</p><p>注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则this 会被绑定到全局对象。</p><h3 id="3-软绑定"><a href="#3-软绑定" class="headerlink" title="3. 软绑定"></a>3. 软绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">// 捕获所有 curried 参数</span></div><div class="line">    <span class="keyword">var</span> curried = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> fn.apply(</div><div class="line">          (!<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global)) ?</div><div class="line">            obj : <span class="keyword">this</span></div><div class="line">          curried.concat.apply( curried, <span class="built_in">arguments</span> )</div><div class="line">      );</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    bound.prototype = <span class="built_in">Object</span>.create( fn.prototype );</div><div class="line">    <span class="keyword">return</span> bound;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>softBind(..)</code>的其他原理和ES5内置的bind(..)类似。它会对制定函数进行封装，首先会检查调用时的this，如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this，否则不会修改this。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"name: "</span> + <span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"obj"</span> &#125;,</div><div class="line">    obj2 = &#123; <span class="attr">name</span>: <span class="string">"obj2"</span> &#125;,</div><div class="line">    obj3 = &#123; <span class="attr">name</span>: <span class="string">"obj3"</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fooOBJ = foo.softBind( obj );</div><div class="line"></div><div class="line">fooOBJ(); <span class="comment">// name: obj</span></div><div class="line"></div><div class="line">obj2.foo = foo.softBind(obj);</div><div class="line"></div><div class="line">obj2.foo(); <span class="comment">// name: obj2 &lt;---- 看！！！</span></div><div class="line"></div><div class="line">fooOBJ.call( obj3 ); <span class="comment">// name: obj3 &lt;---- 看！</span></div><div class="line"></div><div class="line">setTimeout( obj2.foo, <span class="number">10</span> );</div><div class="line"><span class="comment">// name: obj &lt;---- 应用了软绑定</span></div></pre></td></tr></table></figure></p><h2 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h2><p>这里介绍一下箭头函数: <code>() =&gt; {}</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  a: <span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  a: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = foo.call(obj1);</div><div class="line">bar.call(obj2);</div></pre></td></tr></table></figure></p><p><code>foo()</code> 内部创建的箭头函数会捕获调用时<code>foo()</code>的this。由于 <code>foo()</code> 的this绑定到obj1，bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。（new也不行！）</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>两种形式的定义：声明（文字）形式和构造形式。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>了解一下，简单基本类型：<code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>和<code>undefined</code>。null有时会被当做一种对象类型，但是这其实只是语言本身的一个bug。</p><p>JS中有很多复杂基本类型。这些是一些特殊的对象子类型。函数就是对象的一个子类型（从技术角度来说就是“可调用的对象”）</p><p>Javascript中的函数是“一等公民”，因为它们本质上和普通的对象一样（只是可以调用），所以可以像操作其他对象一样操作函数（比如当做另一个函数的参数）。</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>内置对象有：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Object</code>、<code>Function</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code>和<code>Error</code>。</p><p>关于字面量的基本类型调用 <code>Object.prototype.toString()</code> 都会转化成对应的包装类型。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>内容听名字似乎存储在对象内部，其实在语言中，这些值的储存方式是多种多样的，一般不会存在对象容器的内部。存储在对象容器的内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置。</p><p><code>.a</code>通常指的是属性访问，[“a”] 语法通常被称为“键访问”。在 <code>[&quot;..&quot;]</code> 语法使用字符串来访问属性，所以可以在程序中构造这个字符串。</p><h3 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> prefix = <span class="string">"foo"</span>;</div><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">  [prefix + <span class="string">"bar"</span>]: <span class="string">"hello"</span>,</div><div class="line">  [prefix + <span class="string">"baz"</span>]: <span class="string">"world"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject[<span class="string">"foobar"</span>]; <span class="comment">// hello</span></div><div class="line">myObject[<span class="string">"foobaz"</span>]; <span class="comment">// world</span></div></pre></td></tr></table></figure><h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><p>如果访问的对象是一个函数，在JS中，我们喜欢称之为 “方法”，实际上呢，这个所谓的“方法”也仅仅是对方法的引用。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组支持[]访问形式，不过数组期待的是数字下标。所以你添加的属性值并不会使数组的<code>length</code>变长。你完全可以把数组当做一个普通的键/值对来使用。</p><p>而且要注意了：<strong>如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成<br>一个数值下标（因此会修改数组的内容而不是添加一个属性）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [ <span class="string">"foo"</span>, <span class="number">42</span>, <span class="string">"bar"</span> ];</div><div class="line"></div><div class="line">myArray[<span class="string">"3"</span>] = <span class="string">"baz"</span>;</div><div class="line"></div><div class="line">myArray.length; <span class="comment">// 4</span></div><div class="line"></div><div class="line">myArray[<span class="number">3</span>]; <span class="comment">// "baz"</span></div></pre></td></tr></table></figure><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>复制不可避免需要讨论到的就是深拷贝和浅拷贝。</p><p>对于JSON安全的对象，这有一种方法可以用：<code>var newObj = JSON.parse( JSON.stringify( someObj ) );</code></p><p>ES6中定义的 <code>Object.assign(..)</code> 可以用在浅拷贝上，<code>Object.assign(..)</code> 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或者多个源对象。它会遍历一个或多个源对象的多有自由键并把它们复制（使用 = 操作符赋值）到目标对象，最后返回目标对象。</p><h4 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h4><p>在ES5之前，JavaScript语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">a:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor( myObject, <span class="string">"a"</span> );</div><div class="line"></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">// value: 2,</span></div><div class="line"><span class="comment">// writable: true,</span></div><div class="line"><span class="comment">// enumerable: true,</span></div><div class="line"><span class="comment">// configurable: true</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptor(..)</code>和<code>Object.defineProperty(..)</code>了解一下。</p><p>常见配置：</p><ol><li>Writable 是否可以修改属性的值</li><li>Configurable 只要属性是可配置的，就可以使用 <code>defineProperty(..)</code> 方法来修改属性描述符。关于<code>Configurable</code>配置为false，<code>writable</code>可以由<code>true</code>变为<code>false</code>，并且不能再变回来啦！操作不可逆哈。</li><li>Enumerable 最后一个属性描述符（还有两个，我们会在介绍 getter 和 setter 时提到）<br>是 <code>enumerable</code>。</li></ol><p>放一下总结好了，这本书就总结到这里了：</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>JavaScript 中的对象有字面形式（比如 var a = { .. }）和构造形式（比如 var a = newArray(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。</p><p>许多人都以为“JavaScript 中万物都是对象”，这是错误的。对象是 6 个（或者是 7 个，取决于你的观点）基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。</p><p>对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作（在设置属性值时是 [[Put]]），[[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]]链（参见第 5 章）。</p><p>属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象（及其属性）的不可变性级别。</p><p>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。</p><p>你可以使用 ES6 的 for..of 语法来遍历数据结构（数组、对象，等等）中的值，for..of会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里我总结了下，《你不知道的javaScript上卷》第二部分的内容，总结的可能比较简短，相关的知识点，与设计模式中间有重合，设计模式中的相关设计模式，后期也会补上。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="你不知道的JS" scheme="https://hddhyq.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式与开发实践（一）</title>
    <link href="https://hddhyq.github.io/2018/05/02/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hddhyq.github.io/2018/05/02/JavaScript设计模式与开发实践（一）/</id>
    <published>2018-05-02T14:34:41.000Z</published>
    <updated>2018-07-08T04:25:55.512Z</updated>
    
    <content type="html"><![CDATA[<p>全书分为三部分，基础知识，设计模式，设计原则和编程技巧<br>下面我会简单的总结书中的一些有用的设计模式。<br><a id="more"></a><br><strong>第一部分 基础知识</strong></p><p>这一部分，我会快速总结相关的一些知识点，包括</p><ul><li>面向对象的JavaScript</li><li>this,call和apply</li><li>闭包和高阶函数</li></ul><h1 id="面向对象的JavaScript"><a href="#面向对象的JavaScript" class="headerlink" title="面向对象的JavaScript"></a>面向对象的JavaScript</h1><p>首先我们要了解一些基本概念，关于动态类型语言，鸭子类型，原型委托和多态以及原型模式等。</p><h2 id="动态类型语言和鸭子模式"><a href="#动态类型语言和鸭子模式" class="headerlink" title="动态类型语言和鸭子模式"></a>动态类型语言和鸭子模式</h2><p>所谓动态类型语言，必定是相对于静态类型语言所做的比较。</p><ul><li>静态类型语言的优点首先是在编译时就能发现类型不匹配的错误,编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。静态类型语言的缺点首先是迫使程序员依照强契约来编写程序,为每个变量规定数据类型。</li><li>动态类型语言的优点是编写的代码数量更少,看起来也更加简洁,程序员可以把精力更多地放在业务逻辑上面。动态类型语言的缺点是无法保证变量的类型,从而在程序的运行期有可能发生跟类型相关的错误。</li></ul><p>动态语言对变量类型的宽容建立在 <strong>鸭子类型(duck typing)</strong> 的概念。</p><p>所谓鸭子类型的主要思想就是：我们只需要关注对象的行为，或者叫需要对象实现的功能，而不需要关注对象本身。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的实际含义是:同一操作作用于不同的对象上面,可以产生不同的解释和不同的执行结果。换句话说,给不同的对象发送同一个消息的时候,这些对象会根据这个消息分别给出不同的反馈。</p><p>静态语言中，多态的实现需要抽象一个超类，通过继承来实现。</p><p>多态的思想主要是“做什么”和“谁去做”，这样我们就能消除类型之间的耦合关系，完成多态的实现。</p><p>多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性,从而消除这些条件分支语句。</p><p>下面来看一段简单的渲染map的代码，实现多态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> googleMap = &#123;</div><div class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染谷歌地图'</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> baiduMap = &#123;</div><div class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染百度地图'</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params"> map </span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> ( map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span> )&#123;</div><div class="line">        map.show();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">renderMap( googleMap );</div><div class="line">renderMap( baiduMap );</div><div class="line"></div><div class="line"><span class="comment">// 我们需要一个添加新的地图渲染，就死添加一个新的对象就行了，避免判断</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> sosoMap = &#123;</div><div class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染搜搜地图'</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">renderMap( sosoMap );</div></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在 JavaScript 或者其他语言中，封装有很多含义，不仅仅限定于封装数据，只要是将数据隐藏的“任何形式的封装”，我们都能够称之为封装。在 JS 中，我们常见的封装的封装形式就是作用域及闭包了。封装失对象之间的耦合变松散，我们只需要关注对象之间暴露的API，来实现所需功能了。</p><p>《设计模式》中有一段话用来描述封装</p><blockquote><p>“ 考虑你的设计中哪些地方可能变化,这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变,而是考虑你怎样才能够在不重新设计的情况下进行改变。这里的关键在于封装发生变化的概念,这是许多设计模式的主题。”</p></blockquote><p>这段话的核心也就是封装的本质， <strong>“找到变化并封装之”</strong>。</p><h2 id="原型模式和基于原型继承的-JavaScript-对象系统"><a href="#原型模式和基于原型继承的-JavaScript-对象系统" class="headerlink" title="原型模式和基于原型继承的 JavaScript 对象系统"></a>原型模式和基于原型继承的 JavaScript 对象系统</h2><p>如同题目所示，原型模式早就融入到 JavaScript 中了。原型模式不单是一种设计模式,也被称为一种编程泛型。</p><p>原型模式是用于创建对象的一种模式。原型模式的核心就是克隆，原型模式的关键也是语言本身是否提供 clone 方法。ECMAScript 5 提供了 Object.create方法,可以用来克隆对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Plane = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.blood = <span class="number">100</span>;</div><div class="line">    <span class="keyword">this</span>.attackLevel = <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.defenseLevel = <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> Plane();</div><div class="line">plane.blood = <span class="number">500</span>;</div><div class="line">plane.attackLevel = <span class="number">10</span>;</div><div class="line">plane.defenseLevel = <span class="number">7</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> clonePlane = <span class="built_in">Object</span>.create( plane );</div><div class="line"><span class="built_in">console</span>.log( clonePlane );<span class="comment">// 输出:Object &#123;blood: 500, attackLevel: 10, defenseLevel: 7&#125;</span></div></pre></td></tr></table></figure><p>不支持Object.create 方法的浏览器中,则可以使用以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.create = <span class="built_in">Object</span>.create || <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">    F.prototype = obj;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>JavaScript中的原型继承</strong></p><p>JavaScript遵循着一些原型编程的基本规则：</p><ul><li>所有的数据都是对象。</li><li>要得到一个对象,不是通过实例化类,而是找到一个对象作为原型并克隆它。</li><li>对象会记住它的原型。</li><li>如果对象无法响应某个请求,它会把这个请求委托给它自己的原型。</li></ul><ol><li><p>所有的数据都是对象</p><p> JavaScript 在设计的时候,模仿 Java 引入了两套类型机制:基本类型和对象类型。基本类型包括 undefined 、 number 、 boolean 、 string 、 function 、 object 。从现在看来,这并不是一个好的想法。</p><p> 按照 JavaScript 设计者的本意,除了 undefined 之外,一切都应是对象。为了实现这一目标,number 、 boolean 、 string 这几种基本类型数据也可以通过“包装类”的方式变成对象类型数据来处理。</p><p> 我们不能说在 JavaScript 中所有的数据都是对象,但可以说绝大部分数据都是对象。那么相信在 JavaScript 中也一定会有一个根对象存在,这些对象追根溯源都来源于这个根对象。</p><p> 事实上,JavaScript 中的根对象是 Object.prototype 对象。 Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象,实际上都是从 Object.prototype 对象克隆而来的,Object.prototype 对象就是它们的原型。比如下面的 obj1 对象和 obj2 对象:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</div></pre></td></tr></table></figure><p> 可以利用 ECMAScript 5 提供的 Object.getPrototypeOf 来查看这两个对象的原型:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( obj1 ) === <span class="built_in">Object</span>.prototype ); <span class="comment">// 输出:true</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( obj2 ) === <span class="built_in">Object</span>.prototype ); <span class="comment">// 输出:true</span></div></pre></td></tr></table></figure></li><li><p>要得到一个对象,不是通过实例化类,而是找到一个对象作为原型并克隆它</p><p> 了解下，我们new运算符从构造琦中得到一个对象的过程。</p><p> 当使用 new 运算符来调用函数时,此时的函数就是一个构造器。 用new 运算符来创建对象的过程,实际上也只是先克隆 Object.prototype 对象,再进行一些其他额外操作的过程。</p></li><li><p>对象会记住它的原型</p><p> 就 JavaScript 的真正实现来说，其实不能说对象有原型，而至能说对象的构造器有原型。对于”对象吧把请求委托给它自己的原型“这句话，更好的说法是对象委托给它的构造器的原型。那么队形如何把请求顺利的转交给它的构造器的原型呢？</p><p> JavaScript 给对象提供了一个名为 <strong>proto</strong> 的隐藏属性,某个对象的 <strong>proto</strong> 属性默认会指向它的构造器的原型对象,即 {Constructor}.prototype 。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="built_in">console</span>.log ( a.__proto__=== <span class="built_in">Object</span>.prototype );</div><div class="line"><span class="comment">// 输出:true</span></div></pre></td></tr></table></figure><p> 实际上, <strong>proto</strong> 就是对象跟“对象构造器的原型”联系起来的纽带。正因为对象要通过<strong>proto</strong> 属性来记住它的构造器的原型,所以我们用上一节的 objectFactory 函数来模拟用 new创建对象时, 需要手动给 obj 对象设置正确的 <strong>proto</strong> 指向。</p></li><li><p>如果对象无法响应某个请求,它会把这个请求委托给它的构造器的原型</p><p> 这条规则即是原型继承的精髓所在。</p><p> 在 JavaScript 中,每个对象都是从 Object.prototype 对象克隆而来的,如果是这样的话,我们只能得到单一的继承关系,即每个对象都继承自 Object.prototype 对象,这样的对象系统显然是非常受限的。</p><p> 实际上,虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的,但对象构造器的原型并不仅限于 Object.prototype 上,而是可以动态指向其他对象。这样一来,当对象 a 需要借用对象 b 的能力时,可以有选择性地把对象 a 的构造器的原型指向对象 b ,从而达到继承的效果。下面的代码是我们最常用的原型继承方式:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">A.prototype = obj;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log( a.name );</div></pre></td></tr></table></figure><p> 我们来看看执行这段代码的时候,引擎做了哪些事情。</p><ul><li>首先,尝试遍历对象 a 中的所有属性,但没有找到 name 这个属性。</li><li>查找 name 属性的这个请求被委托给对象 a 的构造器的原型,它被 a. <strong>proto</strong> 记录着并且<br>指向 A.prototype ,而 A.prototype 被设置为对象 obj 。</li><li><p>在对象 obj 中找到了 name 属性,并返回它的值。</p><p>当我们期望得到一个“类”继承自另外一个“类”的效果时,往往会用下面的代码来模拟实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">A.prototype = &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">B.prototype = <span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line"><span class="built_in">console</span>.log( b.name ); <span class="comment">// 输出:sven</span></div></pre></td></tr></table></figure><p>再看这段代码执行的时候,引擎做了什么事情。</p></li><li><p>首先,尝试遍历对象 b 中的所有属性,但没有找到 name 这个属性。</p></li><li>查找 name 属性的请求被委托给对象 b 的构造器的原型,它被 b. <strong>proto</strong> 记录着并且指向B.prototype ,而 B.prototype 被设置为一个通过 new A() 创建出来的对象。</li><li>在该对象中依然没有找到 name 属性,于是请求被继续委托给这个对象构造器的原型A.prototype 。</li><li>在 A.prototype 中找到了 name 属性,并返回它的值。</li></ul></li></ol><h2 id="this-、-call-和-apply"><a href="#this-、-call-和-apply" class="headerlink" title="this 、 call 和 apply"></a>this 、 call 和 apply</h2><p>在 JavaScript 的this总是指向一个对象，而具体指向那个对象是运行时 <strong>基于函数的执行环境动态绑定的</strong>，而非函数被声明时的环境。</p><h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><p>除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下四种。</p><ul><li>作为对象的方法调用。</li><li>作为普通函数调用。</li><li>构造器调用。</li><li>Function.prototype.call 或 Function.prototype.apply 调用。</li></ul><h3 id="1-作为对象的方法调用"><a href="#1-作为对象的方法调用" class="headerlink" title="1. 作为对象的方法调用"></a>1. 作为对象的方法调用</h3><p>当函数作为对象的方法被调用时，this指向该对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span> === obj); <span class="comment">// 输出：true</span></div><div class="line">        alert ( <span class="keyword">this</span>.a ); <span class="comment">// 输出: 1 </span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.getA();</div></pre></td></tr></table></figure><h3 id="2-作为普通函数调用"><a href="#2-作为普通函数调用" class="headerlink" title="2. 作为普通函数调用"></a>2. 作为普通函数调用</h3><p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指<br>向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getName());  <span class="comment">// globalName</span></div></pre></td></tr></table></figure><p>注意一下，下面这个例子阐释了this在runtime定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">    name: <span class="string">'sven'</span>,</div><div class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> getName = myObject.getName;</div><div class="line"><span class="built_in">console</span>.log(getName());    <span class="comment">// globalName</span></div></pre></td></tr></table></figure></p><h3 id="3-构造器调用"><a href="#3-构造器调用" class="headerlink" title="3. 构造器调用"></a>3. 构造器调用</h3><p>JavaScript 中没有类，但是能通过 new 运算符从构造器中创建对象。</p><p>除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象，见如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</div><div class="line">alert(obj.name); <span class="comment">// anne</span></div></pre></td></tr></table></figure></p><p>但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span>,</div><div class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 显式地返回一个对象</span></div><div class="line">        name: <span class="string">'anne'</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</div><div class="line">alert(obj.name);</div></pre></td></tr></table></figure><p>如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'anne'</span>; <span class="comment">// 返回 string 类型</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</div><div class="line">alert ( obj.name ); <span class="comment">// 输出：sven</span></div></pre></td></tr></table></figure></p><h3 id="4-Function-prototype-call-或-Function-prototype-apply-调用"><a href="#4-Function-prototype-call-或-Function-prototype-apply-调用" class="headerlink" title="4.  Function.prototype.call 或 Function.prototype.apply 调用"></a>4.  Function.prototype.call 或 Function.prototype.apply 调用</h3><p>跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    name: <span class="string">'sven'</span>,</div><div class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">    name: <span class="string">'anne'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( obj1.getName() ); <span class="comment">// 输出: sven</span></div><div class="line"><span class="built_in">console</span>.log( obj1.getName.call( obj2 ) ); <span class="comment">// 输出：anne</span></div></pre></td></tr></table></figure><h3 id="丢失的this"><a href="#丢失的this" class="headerlink" title="丢失的this"></a>丢失的this</h3><p>何为丢失的this呢？</p><p>其实主要this的指向是runtime的，前面的对象的方法的函数在外部调用也是这个意思哈。</p><h3 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h3><p>call和apply的区别主要就是在传入的参数形式不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> a, b, c </span>)</span>&#123;</div><div class="line">    alert ( [ a, b, c ] ); <span class="comment">// 输出 [ 1, 2, 3 ]</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">func.apply( <span class="literal">null</span>, [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] ); </div><div class="line"></div><div class="line">func.call( <span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> );</div></pre></td></tr></table></figure><p><strong>call和apply的用途</strong></p><ol><li>改变 this 指向</li><li>Function.prototype.bind</li></ol><p>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><p>bind, 没错就是一个语法糖。当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。</p><ol start="3"><li>借用其他对象的方法<br>借用方法的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    A.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">&#125;;</div><div class="line">B.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B( <span class="string">'sven'</span> );</div><div class="line"><span class="built_in">console</span>.log( b.getName() ); <span class="comment">// 输出： 'sven'</span></div></pre></td></tr></table></figure></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">Array</span>.prototype.push.call( <span class="built_in">arguments</span>, <span class="number">3</span> );</div><div class="line">    <span class="built_in">console</span>.log ( <span class="built_in">arguments</span> ); <span class="comment">// 输出[1,2,3]</span></div><div class="line">&#125;)( <span class="number">1</span>, <span class="number">2</span> );</div></pre></td></tr></table></figure><p>想把 arguments 转成真正的数组的时候，可以借用 Array.prototype.slice 方法；想截去<br>arguments 列表中的头一个元素时，又可以借用 Array.prototype.shift 方法。那么这种机制的内<br>部实现原理是什么呢？我们不妨翻开 V8 的引擎源码，以 Array.prototype.push 为例，看看 V8 引<br>擎中的具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> n = TO_UINT32( <span class="keyword">this</span>.length ); <span class="comment">// 被 push 的对象的 length</span></div><div class="line">    <span class="keyword">var</span> m = %_ArgumentsLength(); <span class="comment">// push 的参数个数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">        <span class="keyword">this</span>[ i + n ] = %_Arguments( i ); <span class="comment">// 复制元素 (1)</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.length = n + m; <span class="comment">// 修正 length 属性的值 (2)</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>Array.prototype.slice 实现条件：</p><ul><li>对象本身要可以存取属性</li><li>对象的 length 属性可读写</li></ul><h2 id="闭包和高阶函数"><a href="#闭包和高阶函数" class="headerlink" title="闭包和高阶函数"></a>闭包和高阶函数</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>对于 JavaScript 程序员来说，闭包（closure）是一个难懂又必须征服的概念。闭包的形成与变量的作用域以及变量的生存周期密切相关。下面我们先简单了解这两个知识点。</p><h4 id="1-变量的作用域"><a href="#1-变量的作用域" class="headerlink" title="1. 变量的作用域"></a>1. 变量的作用域</h4><p>当再函数中声明一个变量的时候，如果该变量前面没有带上关键字var，这个变量就会成为全局变量。所以避免变量声明前面不加声明关键词。</p><h4 id="2-变量的生存周期"><a href="#2-变量的生存周期" class="headerlink" title="2. 变量的生存周期"></a>2. 变量的生存周期</h4><p>除了变量的作用域之外，另外一个跟闭包有关的概念是变量的生存周期。</p><p>对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。</p><p>而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        a++;</div><div class="line">        alert(a);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f = func();</div><div class="line"></div><div class="line">f(); <span class="comment">// 输出：2</span></div><div class="line">f(); <span class="comment">// 输出：3</span></div><div class="line">f(); <span class="comment">// 输出：4</span></div><div class="line">f(); <span class="comment">// 输出：5</span></div></pre></td></tr></table></figure><p>在这里我们推出函数后，局部变量 a 并没有消失，而是似乎一直在某个地方存活着。原因是：当执行 var发= function();时，f返回一个匿名函数的引用，它可以访问到func()被调用是产生的环境，而局部变量a一直处在这个环境里。既然局部变量所在环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里就产生了一个闭包结构，局部变量的生命看起来被延续了。</p><p>闭包的一个经典应用是之前var声明的循环遍历中使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">        setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(i)</div><div class="line">        &#125;)(j), <span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func() <span class="comment">// 0, 1, 2, 3, 4</span></div></pre></td></tr></table></figure></p><h4 id="闭包的更多作用"><a href="#闭包的更多作用" class="headerlink" title="闭包的更多作用"></a>闭包的更多作用</h4><ol><li><p>封装变量<br>闭包可以帮助把一些不需要暴露在全局的变量封装乘“私有变量”。假设一个计算乘积的简单函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> calculate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++) &#123;</div><div class="line">            a = a * <span class="built_in">arguments</span>[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">','</span>);</div><div class="line">        <span class="keyword">if</span> ( args <span class="keyword">in</span> cache )&#123;</div><div class="line">            <span class="keyword">return</span> cache[ args ];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cache[args] = calculate.apply( <span class="literal">null</span>, <span class="built_in">arguments</span> );</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></li><li><p>延续局部变量的寿命</p></li></ol><p>####　闭包和面向对象设计<br>过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程,而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能,用闭包也能实现。反之亦然。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 闭包写法</span></div><div class="line"><span class="keyword">var</span> extent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        call: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            value++;</div><div class="line">            <span class="built_in">console</span>.log(value)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> extent = extent();</div><div class="line"></div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line"></div><div class="line"><span class="comment">// 面向对象写法</span></div><div class="line"><span class="keyword">var</span> extent = &#123;</div><div class="line">    value: <span class="number">0</span>,</div><div class="line">    call: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line"></div><div class="line"><span class="comment">// 原型写法</span></div><div class="line"><span class="keyword">var</span> Extent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Extent.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value++;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> extent = <span class="keyword">new</span> Extent();</div><div class="line"></div><div class="line">extent.call();</div><div class="line">extent.call();</div><div class="line">extent.call();</div></pre></td></tr></table></figure><p>关于闭包域内存管理，将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时,就会删除这些值并回收它们占用的内存。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是指至少满足下列条件之一的函数。</p><ul><li>函数可以作为参数被传递;</li><li>函数可以作为返回值输出。</li></ul><h4 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h4><p>把函数当作参数传递,这代表我们可以抽离出一部分容易变化的业务逻辑,把这部分业务逻辑放在函数参数中,这样一来可以分离业务代码中变化与不变的部分。其中一个重要应用场景就是常见的回调函数。</p><ol><li>回调函数</li><li>Array.prototype.sort</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span> ].sort( <span class="function"><span class="keyword">function</span>(<span class="params"> a, b </span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 输出: [ 1, 3, 4 ]</span></div></pre></td></tr></table></figure><h4 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h4><p>相比把函数当作参数传递,函数当作返回值输出的应用场景也许更多,也更能体现函数式编程的巧妙。让函数继续返回一个可执行的函数,意味着运算过程是可延续的。</p><h4 id="高阶函数实现AOP"><a href="#高阶函数实现AOP" class="headerlink" title="高阶函数实现AOP"></a>高阶函数实现AOP</h4><p>这一部分到后面装饰者模式再细讲。</p><h4 id="高阶函数的其他应用"><a href="#高阶函数的其他应用" class="headerlink" title="高阶函数的其他应用"></a>高阶函数的其他应用</h4><ol><li>currenying</li></ol><p>首先我们讨论的是函数柯里化。currying 又称部分求值。一个 currying 的函数首先会接受一些参数,接受了这些参数之后,该函数并不会立即求值,而是继续返回另外一个函数,刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候,之前传入的所有参数都会被一次性用于求值。</p><ol start="2"><li>uncurrying</li></ol><p>在 JavaScript 中，当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点，也是常说的鸭子类型思想。</p><p>同理，一个对象也未必只能使用它自身的方法，那么有什么办法可以让对象去借用一个原本不属于它的方法呢？</p><p>这里我们借用了一个泛化this的过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">return</span> self.apply(obj, <span class="built_in">arguments</span>)</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// var push = Array.prototype.push.uncurrying();</span></div><div class="line"></div><div class="line"><span class="comment">// (function() &#123;</span></div><div class="line"><span class="comment">//     push(arguments, 4);</span></div><div class="line"><span class="comment">//     console.log(arguments);</span></div><div class="line"><span class="comment">// &#125;)(1,2,3)</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, fn, arr = [<span class="string">'push'</span>, <span class="string">'shift'</span>, <span class="string">'forEach'</span>]; fn = arr[i++];) &#123;</div><div class="line">    <span class="built_in">Array</span>[fn] = <span class="built_in">Array</span>.prototype[fn].uncurrying();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;     </div><div class="line">    <span class="string">'length'</span>: <span class="number">3</span>,</div><div class="line">    <span class="string">'0'</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">'1'</span>: <span class="number">2</span>,</div><div class="line">    <span class="string">'2'</span>: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.push(obj, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(obj.length)</div></pre></td></tr></table></figure><ol start="3"><li>函数节流</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全书分为三部分，基础知识，设计模式，设计原则和编程技巧&lt;br&gt;下面我会简单的总结书中的一些有用的设计模式。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="设计模式" scheme="https://hddhyq.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS中排序和搜索算法</title>
    <link href="https://hddhyq.github.io/2018/02/23/JS%E4%B8%AD%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <id>https://hddhyq.github.io/2018/02/23/JS中排序和搜索算法/</id>
    <published>2018-02-23T06:51:34.000Z</published>
    <updated>2018-12-09T14:14:41.196Z</updated>
    
    <content type="html"><![CDATA[<p>看《学习JavaScript数据结构与算法》，总结了下常用的排序，如冒泡排序、选择排序、插入排序、归并排序和快速排序，以及顺序搜索和二分搜索算法。<br><a id="more"></a></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序算法之前，我们需要创建一个数组表示待排序和搜索的数据结构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayList</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> array = []; <span class="comment">//&#123;1&#125;</span></div><div class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    array.push(item);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.toString= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//&#123;3&#125;</span></div><div class="line">    <span class="keyword">return</span> array.join();</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序最简单，不过它的时间复杂度也是最大的。</p><p>冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length; <span class="comment">//&#123;1&#125;</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length; i++)&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;length<span class="number">-1</span>; j++ )&#123; <span class="comment">//&#123;3&#125;</span></div><div class="line">      <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>])&#123; <span class="comment">//&#123;4&#125;</span></div><div class="line">        swap(array, j, j+<span class="number">1</span>); <span class="comment">//&#123;5&#125;</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="keyword">var</span> swap = <span class="function"><span class="keyword">function</span>(<span class="params">array, index1, index2</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> aux = array[index1];</div><div class="line">  array[index1] = array[index2];</div><div class="line">  array[index2] = aux;</div><div class="line">&#125;; <span class="comment">// 一个私有函数，只能用在ArrayList类的内部代码中</span></div><div class="line"></div><div class="line"><span class="comment">// 可以用ES6的数组拓展</span></div><div class="line"><span class="comment">// [array[index1], array[index2]] = [array[index2], array[index1]];</span></div></pre></td></tr></table></figure><p>首先，声明一个名为length的变量，用来存储数组的长度（行{1}）。这一步可选，它能帮助我们在行{2}和行{3}时直接使用数组的长度。接着，外循环（行{2}）会从数组的第一位迭代至最后一位，它控制了在数组中经过多少轮排序（应该是数组中每项都经过一轮，轮数和数组长度一致）。然后，内循环将从第一位迭代至倒数第二位，内循环实际上进行当前项和下一项的比较（行{4}）。如果这两项顺序不对（当前项比下一项大），则交换它们（行{5}），意思是位置为j+1的值将会被换置到位置j处，反之亦然。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/冒泡算法.png" alt=""></p><p><strong>改进冒泡算法</strong><br>如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较。<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/改进冒泡算法.png" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.modifiedBubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;length<span class="number">-1</span>-i; j++ )&#123;</div><div class="line">      <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>])&#123;</div><div class="line">        swap(j, j+<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>最后，这个排序的事件复杂度是O(n²)。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, <span class="comment">//&#123;1&#125;</span></div><div class="line">    indexMin;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length<span class="number">-1</span>; i++)&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">      indexMin = i; <span class="comment">//&#123;3&#125;</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j=i; j&lt;length; j++)&#123; <span class="comment">//&#123;4&#125;</span></div><div class="line">      <span class="keyword">if</span>(array[indexMin]&gt;array[j])&#123; <span class="comment">//&#123;5&#125;</span></div><div class="line">        indexMin = j; <span class="comment">//&#123;6&#125;</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i !== indexMin)&#123; <span class="comment">//&#123;7&#125;</span></div><div class="line">    swap(i, indexMin);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>首先声明一些将在算法内使用的变量（行{1}）。接着，外循环（行{2}）迭代数组，并控制迭代轮次（数组的第n个值——下一个最小值）。我们假设本迭代轮次的第一个值为数组最小值（行{3}）。然后，从当前i的值开始至数组结束（行{4}），我们比较是否位置j的值比当前最小值小（行{5}）；如果是，则改变最小值至新最小值（行{6}）。当内循环结束（行{4}），将得出数组第n小的值。最后，如果该最小值和原最小值不同（行{7}），则交换其值。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/选择排序.png" alt=""></p><p>选择排序同样也是一个复杂度为O(n²)的算法。和冒泡排序一样，它包含有嵌套的两个循环，这导致了二次方的复杂度。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, <span class="comment">//&#123;1&#125;</span></div><div class="line">      j, temp;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;length; i++)&#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    j = i; <span class="comment">//&#123;3&#125;</span></div><div class="line">    temp = array[i]; <span class="comment">//&#123;4&#125;</span></div><div class="line">    <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; array[j<span class="number">-1</span>] &gt; temp)&#123; <span class="comment">//&#123;5&#125;</span></div><div class="line">      array[j] = array[j<span class="number">-1</span>]; <span class="comment">//&#123;6&#125;</span></div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    array[j] = temp; <span class="comment">//&#123;7&#125;</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>算法的第一行用来声明代码中使用的变量（行{1}）。接着，迭代数组来给第i项找到正确的位置（行{2}）。注意，算法是从第二个位置（索引1）而不是0位置开始的（我们认为第一项已排序了）。然后，用i的值来初始化一个辅助变量（行{3}）并将其值亦存储于一临时变量中（行{4}），便于之后将其插入到正确的位置上。下一步是要找到正确的位置来插入项目。只要变量j比0大（因为数组的第一个索引是0——没有负值的索引）并且数组中前面的值比待比较的值大（行{5}），我们就把这个值移到当前位置上（行{6}）并减小j。最终，该项目能插入到正确的位置上。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/插入排序.png" alt=""></p><p>排序小型数组时，此算法比选择排序和冒泡排序性能要好。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是第一个可以被实际使用的排序算法。，其复杂度为O(nlogⁿ)。</p><blockquote><p>JavaScript的Array类定义了一个sort函数（Array.prototype.sort）用以排序JavaScript数组（我们不必自己实现这个算法）。ECMAScript没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox使用归并排序作为Array.prototype.sort的实现，而Chrome使用了一个快速排序（下面我们会学习的）的变体。</p></blockquote><p>归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  array = mergeSortRec(array);</div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="keyword">var</span> mergeSortRec = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length;</div><div class="line">  <span class="keyword">if</span>(length === <span class="number">1</span>) &#123; <span class="comment">//&#123;1&#125;</span></div><div class="line">    <span class="keyword">return</span> array; <span class="comment">//&#123;2&#125;</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>), <span class="comment">//&#123;3&#125;</span></div><div class="line">    left = array.slice(<span class="number">0</span>, mid), <span class="comment">//&#123;4&#125;</span></div><div class="line">    right = array.slice(mid, length); <span class="comment">//&#123;5&#125;</span></div><div class="line">  <span class="keyword">return</span> merge(mergeSortRec(left), mergeSortRec(right)); <span class="comment">//&#123;6&#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>归并排序将一个大数组转化为多个小数组直到只有一个项。由于算法是递归的，我们需要一个停止条件，在这里此条件是判断数组的长度是否为1（行{1}）。如果是，则直接返回这个长度为1的数组（行{2}），因为它已排序了。</p><p>如果数组长度比1大，那么我们得将其分成小数组。为此，首先得找到数组的中间位（行{3}），找到后我们将数组分成两个小数组，分别叫作left（行{4}）和right（行{5}）。left数组由索引0至中间索引的元素组成，而right数组由中间索引至原始数组最后一个位置的元素组成。</p><p>下面的步骤是调用merge函数（行{6}），它负责合并和排序小数组来产生大数组，直到回到原始数组并已排序完成。为了不断将原始数组分成小数组，我们得再次对left数组和right数组递归调用mergeSortRec，并同时作为参数传递给merge函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> result = [], <span class="comment">// &#123;7&#125;</span></div><div class="line">      il = <span class="number">0</span>,</div><div class="line">      ir = <span class="number">0</span>; </div><div class="line">  <span class="keyword">while</span>(il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; <span class="comment">// &#123;8&#125;</span></div><div class="line">    <span class="keyword">if</span>(left[il] &lt; right[ir]) &#123;</div><div class="line">      result.push(left[il++]); <span class="comment">// &#123;9&#125;</span></div><div class="line">    &#125; <span class="keyword">else</span>&#123;</div><div class="line">      result.push(right[ir++]); <span class="comment">// &#123;10&#125;</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (il &lt; left.length)&#123; <span class="comment">// &#123;11&#125;</span></div><div class="line">    result.push(left[il++]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (ir &lt; right.length)&#123; <span class="comment">// &#123;12&#125;</span></div><div class="line">    result.push(right[ir++]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result; <span class="comment">// &#123;13&#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>merge函数接受两个数组作为参数，并将它们归并至一个大数组。排序发生在归并过程中。首先，需要声明归并过程要创建的新数组以及用来迭代两个数组（left和right数组）所需的两个变量（行{7}）。迭代两个数组的过程中（行{8}），我们比较来自left数组的项是否比来自right数组的项小。如果是，将该项从left数组添加至归并结果数组，并递增迭代数组的控制变量（行{9}）；否则，从right数组添加项并递增相应的迭代数组的控制变量（行{10}）。</p><p>接下来，将left数组或者right数组所有剩余的项添加到归并数组中（行{11}和行{12}）。最后，将归并数组作为结果返回（行{13}）。</p><p>如果执行mergeSort函数，下图是具体的执行过程：<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/归并排序.png" alt=""></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序也许是最常用的排序算法了。它的复杂度为O(nlogⁿ)，且它的性能通常比其他的复杂度为O(nlogⁿ)的排序算法要好。和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）。</p><p>快速排序比到目前为止你学过的其他排序算法要复杂一些。让我们一步步地来学习。</p><ol><li>首先，从数组中选择中间一项作为主元。</li><li>创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分操作。</li><li>接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.quickSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> quick(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>就像归并算法那样，开始我们声明一个主方法来调用递归函数，传递待排序数组，以及索引<br>0及其最末的位置（因为我们要排整个数组，而不是一个子数组）作为参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> quick = <span class="function"><span class="keyword">function</span>(<span class="params">array, left, right</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> index; <span class="comment">//&#123;1&#125;</span></div><div class="line">  <span class="keyword">if</span> (array.length &gt; <span class="number">1</span>) &#123; <span class="comment">//&#123;2&#125;</span></div><div class="line">    index = partition(array, left, right); <span class="comment">//&#123;3&#125;</span></div><div class="line">    <span class="keyword">if</span> (left &lt; index - <span class="number">1</span>) &#123; <span class="comment">//&#123;4&#125;</span></div><div class="line">      quick(array, left, index - <span class="number">1</span>); <span class="comment">//&#123;5&#125;</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (index &lt; right) &#123; <span class="comment">//&#123;6&#125;</span></div><div class="line">      quick(array, index, right); <span class="comment">//&#123;7&#125;</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>首先声明index（行{1}），该变量能帮助我们将子数组分离为较小值数组和较大值数组，这样，我们就能再次递归的调用quick函数了。partition函数返回值将赋值给index（行{3}）。</p><p>如果数组的长度比1大（因为只有一个元素的数组必然是已排序了的（行{2}），我们将对给定子数组执行partition操作（第一次调用是针对整个数组）以得到index（行{3}）。如果子数组存在较小值的元素（行{4}），则对该数组重复这个过程（行{5}）。同理，对存在较大值得子数组也是如此，如果存在子数组存在较大值，我们也将重复快速排序过程（行{7}）。</p><h3 id="1-划分过程"><a href="#1-划分过程" class="headerlink" title="1. 划分过程"></a>1. 划分过程</h3><p>第一件要做的事情是选择主元（pivot），有好几种方式。最简单的一种是选择数组的第一项（最左项）。然而，研究表明对于几乎已排序的数组，这不是一个好的选择，它将导致该算法的最差表现。另外一种方式是随机选择一个数组项或是选择中间项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span>(<span class="params">array, left, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> pivot = array[<span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)], <span class="comment">//&#123;8&#125;</span></div><div class="line">      i = left, <span class="comment">//&#123;9&#125;</span></div><div class="line">      j = right; <span class="comment">//&#123;10&#125;</span></div><div class="line">  <span class="keyword">while</span> (i &lt;= j) &#123; <span class="comment">//&#123;11&#125;</span></div><div class="line">    <span class="keyword">while</span> (array[i] &lt; pivot) &#123; <span class="comment">//&#123;12&#125;</span></div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (array[j] &gt; pivot) &#123; <span class="comment">//&#123;13&#125;</span></div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i &lt;= j) &#123; <span class="comment">//&#123;14&#125;</span></div><div class="line">      swap(array, i, j); <span class="comment">//&#123;15&#125;</span></div><div class="line">      i++;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> i; <span class="comment">//&#123;16&#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>在本实现中，我们选择中间项作为主元（行{8}）。我们初始化两个指针：left（低——行{9}），初始化为数组第一个元素；right（高——行{10}），初始化为数组最后一个元素。</p><p>只要left和right指针没有相互交错（行{11}），就执行划分操作。首先，移动left指针直到找到一个元素比主元大（行{12}）。对right指针，我们做同样的事情，移动right指针直到我们找到一个元素比主元小。</p><p>当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大（行{14}），意思是左项比右项大（值比较）。我们交换它们，然后移动两个指针，并重复此过程（从行{11}再次开始）。</p><p>在划分操作结束后，返回左指针的索引，用来在行{3}处创建子数组。</p><h3 id="2-快速排序实战"><a href="#2-快速排序实战" class="headerlink" title="2. 快速排序实战"></a>2. 快速排序实战</h3><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/快排1.png" alt=""><br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/快排2.png" alt=""><br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/快排3.png" alt=""><br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/快排4.png" alt=""><br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/快排5.png" alt=""></p><h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="顺序搜索"><a href="#顺序搜索" class="headerlink" title="顺序搜索"></a>顺序搜索</h2><p>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.sequentialSearch = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</div><div class="line">    <span class="keyword">if</span> (item === array[i])</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>二分搜索算法的原理和猜数字游戏类似，就是那个有人说“我正想着一个1到100的数字”的游戏。我们每回应一个数字，那个人就会说这个数字是高了、低了还是对了。</p><p>这个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。</p><ol><li>选择数组的中间值。</li><li>如果选中值是待搜索值，那么算法执行完毕（值找到了）。</li><li>如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。</li><li>如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.binarySearch = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.quickSort();</div><div class="line">  <span class="keyword">var</span> low = <span class="number">0</span>,</div><div class="line">    high = array.length - <span class="number">1</span>,</div><div class="line">    mid, element;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (low &lt;= high)&#123;</div><div class="line">    mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</div><div class="line">    element = array[mid];</div><div class="line">    <span class="keyword">if</span> (element &lt; item) &#123;</div><div class="line">      low = mid + <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &gt; item) &#123;</div><div class="line">      high = mid - <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>开始前需要先将数组排序，我们可以选择快速排序等。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/sortWithJs/排序时间复杂度.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看《学习JavaScript数据结构与算法》，总结了下常用的排序，如冒泡排序、选择排序、插入排序、归并排序和快速排序，以及顺序搜索和二分搜索算法。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="算法" scheme="https://hddhyq.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Cnode-Pwa 过程中的小坑</title>
    <link href="https://hddhyq.github.io/2018/02/21/Vue-Cnode-Pwa-%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
    <id>https://hddhyq.github.io/2018/02/21/Vue-Cnode-Pwa-过程中的小坑/</id>
    <published>2018-02-21T13:34:46.000Z</published>
    <updated>2018-07-08T04:25:55.512Z</updated>
    
    <content type="html"><![CDATA[<p>总结下开发过程中的一些小坑。<br><a id="more"></a></p><h1 id="项目概括"><a href="#项目概括" class="headerlink" title="项目概括"></a>项目概括</h1><p>线上地址<a href="https://brokenbones.xyz" target="_blank" rel="noopener">https://brokenbones.xyz</a></p><h2 id="页面编写"><a href="#页面编写" class="headerlink" title="页面编写"></a>页面编写</h2><p>页面编写主要采用的MVVM框架<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js</a>开发，是直接用的vue-cli脚手架提供的PWA模板,页面样式采用的是<a href="https://vuetifyjs.com/zh-Hans/" target="_blank" rel="noopener">vuetify</a>，数据管理用的是<a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="noopener">vuex</a>，api通讯采用的<a href="http://www.bootcdn.cn/axios/readme/" target="_blank" rel="noopener">axios</a>,页面的路由采用的<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">vue-router</a>，其中我才用了history模式，这种模式更适合PWA。边写文章部分，采用了，Mavon-Editor的markdown编辑器。</p><h2 id="PWA部分"><a href="#PWA部分" class="headerlink" title="PWA部分"></a>PWA部分</h2><p>主要是自己编写了<code>mainfest.json</code>，sw.js则是利用<strong>sw-precahe-webpack-plugin</strong>生成。</p><h2 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h2><p>PWA应用必须采用https,这里我用的是腾讯云的免费的SSL证书，配置十分方便，推荐，免费一年。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>根据路由拆分=&gt;项目的主要page有：</p><ul><li>主题列表<ul><li>全部</li><li>精华</li><li>分享</li><li>问答</li><li>招聘</li><li>测试</li></ul></li><li>主题详情<ul><li>文章部分</li><li>文章回复列表</li><li>回复收藏文章、点赞和回复他人评论</li></ul></li><li>个人中心<ul><li>最近回复</li><li>最近发布</li><li>话题收藏</li></ul></li><li>我的消息<ul><li>已读消息</li><li>未读消息</li></ul></li><li>新建主题<ul><li>Mavon-Editor</li></ul></li><li>关于</li></ul><p><strong>项目准备工作</strong></p><p>主要是，对常见的字体和ret.styl进行打包下载，也观察了其他一些人做相同的社区的页面的结构。</p><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="路由部分"><a href="#路由部分" class="headerlink" title="路由部分"></a>路由部分</h2><p>这个项目让我对vue-router的认识更加深了一步。</p><h3 id="HTML5-history模式"><a href="#HTML5-history模式" class="headerlink" title="HTML5 history模式"></a>HTML5 history模式</h3><p>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p><p>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p><p>当你使用 history 模式时，URL 就像正常的 url，例如 <a href="http://yoursite.com/user/id" target="_blank" rel="noopener">http://yoursite.com/user/id</a>　，也好看！</p><p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a href="http://oursite.com/user/id" target="_blank" rel="noopener">http://oursite.com/user/id</a> 就会返回 404，这就不好看了。</p><p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p><p>后端配置见:<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">后端配置</a></p><p>最后，给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  mode: <span class="string">'history'</span>,</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'*'</span>, <span class="attr">component</span>: NotFoundComponent &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h3 id="导航守卫和watch路由变化"><a href="#导航守卫和watch路由变化" class="headerlink" title="导航守卫和watch路由变化"></a>导航守卫和watch路由变化</h3><p>导航守卫有：</p><ul><li>beforeRouteEnter</li><li>beforeRouteUpdate (2.2 新增)</li><li>beforeRouteLeave</li></ul><p>这个项目中，我用了直接的<code>watch</code>路由变化和<code>beforeRouteUpdate</code></p><p>主题详情界面有五个分路由，全部、问答和测试等。在路由设置中，我们保持的keep-alive，这样可以保持组件的状态保持，对于项目的体验比较好。可是页面的路由变化，如果使用的是同一组件的时候，页面的内容就不会变化，像主题的切换和主题详情的内容的变化等，这是我们就需要利用<br><code>beforeRouteUpdate</code>或者<code>watch</code>路由的变化。</p><p>例如，ListView组件中的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">beforeRouteUpdate(to, <span class="keyword">from</span>, next) &#123;</div><div class="line">  <span class="keyword">this</span>.postList = []</div><div class="line">  <span class="keyword">this</span>.getTabData(to.query.tab)</div><div class="line">  next()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>和TopicDetail中的<code>watch</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">watch: &#123;</div><div class="line">  $route(to, <span class="keyword">from</span>) &#123;</div><div class="line">    <span class="comment">// 理解一下to＝＝要去的路由 记录TopicId,避免相同页面再重复加载</span></div><div class="line">    <span class="comment">// this.topic = []</span></div><div class="line">    <span class="keyword">if</span> (to.name === <span class="string">'topic'</span> &amp;&amp; to.params.id !== <span class="keyword">this</span>.topicId) &#123;</div><div class="line">      <span class="keyword">this</span>.topic = &#123;&#125;</div><div class="line">      <span class="keyword">this</span>.getDetail(<span class="keyword">this</span>.$route.params.id)</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">from</span>.name === <span class="string">'topic'</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.setTopicId(<span class="keyword">from</span>.params.id)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="页面的滚动状态保持"><a href="#页面的滚动状态保持" class="headerlink" title="页面的滚动状态保持"></a>页面的滚动状态保持</h3><p>当我们，在主题列表滚动了一段距离之后，我们点击了一个主题，然后我们再次返回的时候，主题列表需要保持原来的滚动状态。</p><p>本来我的主题列表想要添加<a href="https://ustbhuangyi.github.io/better-scroll/#/" target="_blank" rel="noopener">better-scroll</a>的。但是每次页面滚动之后，点击新主题，再返回的时候，页面总会跳转到顶端，这样的话，浏览体验就非常不好。然后我了解了一下 better-scroll 的滚动原理：<br><img src="http://static.galileo.xiaojukeji.com/static/tms/shield/scroll-4.png" alt=""><br>绿色部分为 wrapper，也就是父容器，它会有固定的高度。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。</p><p>这里，我们了解到了，better-scroll 的滚动原理中，我们需要一个固定的wrapper，这样的话，我们的内容在我们的页面中的话，就是在一个固定的窗口下。</p><p>vue-router 中有一个scrollBehavior ，<a href="https://router.vuejs.org/zh-cn/advanced/scroll-behavior.html" target="_blank" rel="noopener">滚动行为</a>，使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p><p>我们需要记录scrollTop属性，上面采用 better-scroll 的话，我们的窗口是固定的，也就是，这里的scrollTop是相对于我们wrapper，而wrapper在页面中的位置是固定的就是没有scrollTop，这样的话，我们记录的scrollTop没有用。</p><p>如果用 better-scroll ，我们就需要页面跳转的话每次将scrollTop的值手动传给组件，十分麻烦，最后我放弃了并采用了原生的scroll。</p><h3 id="vue-router懒加载"><a href="#vue-router懒加载" class="headerlink" title="vue-router懒加载"></a>vue-router懒加载</h3><p>没什么好说的，为了加载高效肯定要用的。</p><h2 id="其他一些"><a href="#其他一些" class="headerlink" title="其他一些"></a>其他一些</h2><h3 id="mavonEditor"><a href="#mavonEditor" class="headerlink" title="mavonEditor"></a>mavonEditor</h3><p>论坛的文章编辑，现在大部分写文章的都是md了，所以我找了找，最好的还是这个，安装好npm包，加一个标签再加上一点配置接好了。地址：<a href="https://github.com/hinesboy/mavonEditor" target="_blank" rel="noopener">mavonEditor</a></p><h3 id="多处用的登录验证"><a href="#多处用的登录验证" class="headerlink" title="多处用的登录验证"></a>多处用的登录验证</h3><p>没有登录的时候，很多地方都需要登录验证。因为有路由跳转逻辑，需要 js ，有了 mixin 就很好了。我们写好了 mixin 后，在我们需要添加登录页面的地方添加 mixin 和添加登录页面的组件。</p><p>最后，还想到什么有需要总结的还是会更新文章的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下开发过程中的一些小坑。&lt;br&gt;
    
    </summary>
    
      <category term="vue-items" scheme="https://hddhyq.github.io/categories/vue-items/"/>
    
    
      <category term="vue-cnode" scheme="https://hddhyq.github.io/tags/vue-cnode/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JS总结-作用域和闭包(二)</title>
    <link href="https://hddhyq.github.io/2018/02/05/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E6%80%BB%E7%BB%93-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85-%E4%BA%8C/"/>
    <id>https://hddhyq.github.io/2018/02/05/你不知道的JS总结-作用域和闭包-二/</id>
    <published>2018-02-05T15:10:19.000Z</published>
    <updated>2018-07-08T04:25:55.520Z</updated>
    
    <content type="html"><![CDATA[<p>关于你不知道的JS总结-作用域和闭包的第二部分。<br><a id="more"></a></p><h1 id="第-4-章-提升"><a href="#第-4-章-提升" class="headerlink" title="第 4 章 提升"></a>第 4 章 提升</h1><h2 id="先有鸡还是先有蛋"><a href="#先有鸡还是先有蛋" class="headerlink" title="先有鸡还是先有蛋"></a>先有鸡还是先有蛋</h2><p>关于JS的代码执行顺序，直觉上是由上到下一行一行执行的。实际上并不完全正确，考虑下下面的代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log( a );</div></pre></td></tr></table></figure></p><p>你认为<code>console.log( a );</code>声明会输出什么呢？很多人会认为是<code>undefined</code>，其实真实的输出结果是2。而<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( a );</div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div></pre></td></tr></table></figure></p><p>这段代码输出结果又是<code>ReferenceError</code>异常。</p><p>按照第一章的编译器顺序，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。</p><p>所以看到的<code>var a = 2;</code>其实是<code>var a;</code> 和 <code>a = 2;</code>两个声明。代码的编译过程是如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"></div><div class="line"><span class="comment">// 加上顺序，流程如下：</span></div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a = <span class="number">2</span>;</div></pre></td></tr></table></figure></p><p>从上面的例子可以看出，是现有声明，再有赋值。这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。</p><blockquote><p>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。</p></blockquote><h3 id="关于函数的声明"><a href="#关于函数的声明" class="headerlink" title="关于函数的声明"></a>关于函数的声明</h3><p>首先看一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>foo 函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可以正常执行。</p><p>正确的执行顺序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></div><div class="line">  a = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p><p><strong>函数声明会被提升，但是函数表达式却不会被提升。</strong></p><p>下面看一段函数表达式的代码片段：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// TypeError</span></div><div class="line">bar(); <span class="comment">// ReferenceError</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 经过提升</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line">foo(); <span class="comment">// TypeError</span></div><div class="line">bar(); <span class="comment">// ReferenceError</span></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> bar = ...self...</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h2><p>函数声明和变量声明都会被提升，那么哪一个的优先权大呢？答案就在标题。<br>看这一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// 1</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</div><div class="line">&#125;</div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这个代码片段会被引擎理解为如下形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</div><div class="line">&#125;</div><div class="line">foo(); <span class="comment">// 1</span></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>尽管　<code>var foo</code> 出现在<code>function foo()...</code>，但它是一个重复的声明，会被忽略掉。因为函数声明会被提升到普通变量之前。</p><p>而且，后面的函数声明会覆盖前面的声明。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// 3</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="number">3</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程 <strong>不会像下面的代码暗示的那样可以被条件判断所控制：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">foo(); <span class="comment">// "b"</span></div><div class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span> (a) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"a"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"b"</span>); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们习惯将 <code>var a = 2</code>; 看作一个声明，而实际上 <strong>JavaScript</strong> 引擎并不这么认为。它将 <code>var a</code>和 <code>a = 2</code> 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。</p><p>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为<strong>提升</strong>。</p><p>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</p><p>要注意避免重复声明，特别是当普通的 <code>var</code> 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！</p><h1 id="第-5-章-作用域闭包"><a href="#第-5-章-作用域闭包" class="headerlink" title="第 5 章 作用域闭包"></a>第 5 章 作用域闭包</h1><h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>闭包无处不在，你所需要的只是理解它</p><h2 id="实质问题"><a href="#实质问题" class="headerlink" title="实质问题"></a>实质问题</h2><p>闭包的定义：</p><blockquote><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p></blockquote><p>下面这段代码的定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">  &#125;</div><div class="line">  bar();</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p><p>上面的代码中，基于词法作用域，函数<code>bar()</code>可以访问外部作用域中的变量a（利用RHS引用调用）。这里的词法作用域的利用，是闭包的一部分，也是最重要的一部分。</p><p>从纯学术的角度说，函数 <code>bar()</code> 具有一个涵盖 <code>foo()</code> 作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域））。也可以认为 bar() 被封闭在了 foo() 的作用域中。为什么呢？原因简单明了，因为 bar() 嵌套在 foo() 内部。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( a );</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> baz = foo();</div><div class="line">baz(); <span class="comment">// 2 —— 朋友，这就是闭包的效果。</span></div></pre></td></tr></table></figure></p><p>函数<code>bar()</code>的词法作用域能够访问<code>foo()</code>的内部作用域。然后我们将<code>bar()</code>函数本身当做一个值类型进行传递。上面这个例子中，我们就是将bar所应用的函数对象本身当做返回值。</p><p>在<code>foo()</code>执行后，其返回值（也就是内部的 <code>bar()</code> 函数）赋值给变量 <code>baz</code> 并调用 <code>baz()</code>，实际上只是通过不同的标识符引用调用了内部的函数<code>bar()</code>。</p><p><code>bar()</code>显然可以被正常执行，但是在这个例子中，它在自己定义的词法作用域以外的地方执行。</p><p><code>foo()</code> 执行后，通常会期待 <code>foo()</code> 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 <code>foo()</code> 的内容不会再被使用，所以很自然地会考虑对其进行回收。</p><p>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 <code>bar()</code> 本身在使用。</p><p>拜 <code>bar()</code> 所声明的位置所赐，它拥有涵盖 <code>foo()</code> 内部作用域的闭包，使得该作用域能够一直存活，以供 <code>bar()</code> 在之后任何时间进行引用。</p><p><code>bar()</code> 依然持有对该作用域的引用，而这个引用就叫作闭包。</p><p>因此，在<strong>几微秒</strong>之后变量 baz 被实际调用（调用内部函数 <code>bar</code>），不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。</p><p>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。</p><p>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">  &#125;</div><div class="line">  bar( baz );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  fn(); <span class="comment">// 妈妈快看呀，这就是闭包！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</p></blockquote><h2 id="现在我懂了"><a href="#现在我懂了" class="headerlink" title="现在我懂了"></a>现在我懂了</h2><p>来看这段代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( message );</div><div class="line">  &#125;, <span class="number">1000</span> );</div><div class="line">&#125;</div><div class="line">wait( <span class="string">"Hello, closure!"</span> );</div></pre></td></tr></table></figure></p><p>将一个内部函数（名为 <code>timer</code>）传递给 <code>setTimeout(..)</code>。<code>timer</code> 具有涵盖 <code>wait(..)</code> 作用域的闭包，因此还保有对变量 <code>message</code> 的引用。</p><p><code>wait(..)</code> 执行 1000 毫秒后，它的内部作用域并不会消失，<code>timer</code> 函数依然保有 <code>wait(..)</code>作用域的闭包。</p><p>深入到引擎的内部原理中，内置的工具函数 <code>setTimeout(..)</code> 持有对一个参数的引用，这个参数也许叫作 <code>fn</code> 或者 <code>func</code>，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 <code>timer</code> 函数，而词法作用域在这个过程中保持完整。</p><p><strong>这就是闭包。</strong></p><p>本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！</p><p>IIFE模式，因为函数（示例代码中的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行。这是是创建了一个闭包但是并不能调用。</p><h2 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h2><p>要说明闭包，for循环是最常见的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( i );</div><div class="line">  &#125;, i*<span class="number">1000</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们预期的效果是:分别输出数字 1~5，每秒一次，每次一个。</p><p>得到的结果是，每秒一次的频率输出五次 6。</p><p>首先我们看一下6是怎么来的。这个例子中的终止条件是<code>i&lt;=5</code>。所以首次成立时的i的值是6，因此，输出显示的是循环结束时 i 的最终值。</p><p>仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 <code>setTimeout(.., 0)</code>，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。</p><p>缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的<strong>副本</strong>。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个<strong>共享的全局作用域中</strong>，因此实际上只有一个 i。</p><p>我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。</p><p>首先试下IIFE<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log( i );</div><div class="line">    &#125;, i*<span class="number">1000</span> );</div><div class="line">  &#125;)();</div><div class="line">&#125; <span class="comment">// 这样的写法不行，为什么呢？因为每个IIFE中i的值并没有定义，也就是说这个作用于是空的</span></div><div class="line"></div><div class="line"><span class="comment">//　改进</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log( j );</div><div class="line">    &#125;, j*<span class="number">1000</span> );</div><div class="line">  &#125;)( i );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>重返块作用域</strong></p><p>我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。第 3 章介绍了 let 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。</p><p>本质上这是将一个块转换成一个可以被关闭的作用域。因此，下面这些看起来很酷的代码就可以正常运行了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="keyword">let</span> j = i; <span class="comment">// 是的，闭包的块作用域！</span></div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( j );</div><div class="line">  &#125;, j*<span class="number">1000</span> );</div><div class="line">&#125;</div><div class="line"><span class="comment">// for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( i );</div><div class="line">  &#125;, i*<span class="number">1000</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>还有其他的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一起来研究其中最强大的一个：<strong>模块</strong>。</p><p>模块模式需要具备两个必要条件。</p><ol><li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够到达那里。但实际上它只是一个标准，显然就是关于如何在函数作为值按需传递的词法环境中书写代码的。</p><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</p><p>如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。</p><p>模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</p><p>现在我们会发现代码中到处都有闭包存在，并且我们能够识别闭包然后用它来做一些有用的事！</p><h1 id="附录-A-动态作用域"><a href="#附录-A-动态作用域" class="headerlink" title="附录 A 动态作用域"></a>附录 A 动态作用域</h1><p>JS中作用域就是词法作用域，（事实上大部分语言都是基于词法作用域的）。</p><p>而JS中，this的机制，类似于动态作用域。</p><p>词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的<strong>书写阶段</strong>（假设你没有使用eval() 或 with）。而动态作用域，是一个运行时被被动确定状态的形式。</p><p>例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">bar();</div></pre></td></tr></table></figure></p><p>词法作用域让 <code>foo()</code> 中的 <code>a</code> 通过 <strong>RHS</strong> 引用到了全局作用域中的 <code>a</code>，因此会输出 2。</p><p>而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。</p><p>因此，如果 JavaScript 具有动态作用域，理论上，上面代码中的 <code>foo()</code> 在执行时将会输出 3。</p><p>为什么会这样？因为当 <code>foo()</code> 无法找到 <code>a</code> 的变量引用时，会顺着调用栈在调用 <code>foo()</code> 的地方查找 <code>a</code>，而不是在嵌套的词法作用域链中向上查找。由于 <code>foo()</code> 是在 <code>bar()</code> 中调用的，引擎会检查 <code>bar()</code> 的作用域，并在其中找到值为 3 的变量 <code>a</code>。</p><h1 id="附录-B-块作用域的替代方案"><a href="#附录-B-块作用域的替代方案" class="headerlink" title="附录 B 块作用域的替代方案"></a>附录 B 块作用域的替代方案</h1><p>第 3 章深入研究了块作用域。至少从 ES3 发布以来，JavaScript 中就有了块作用域，而with 和 catch 分句就是块作用域的两个小例子。</p><p>但随着 ES6 中引入了 let，我们的代码终于有了创建完整、不受约束的块作用域的能力。块作用域在功能上和代码风格上都拥有很多激动人心的新特性。</p><p>但如果我们想在 ES6 之前的环境中使用块作用域呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure><p>这段代码在 ES6 环境中可以正常工作。但是在 ES6 之前的环境中如何才能实现这个效果？答案是使用 catch。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;<span class="keyword">throw</span> <span class="number">2</span>;&#125;<span class="keyword">catch</span>(a)&#123;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p><p>了解原理剩下就交给ES6转换器吧。</p><h1 id="附录-C-this-词法"><a href="#附录-C-this-词法" class="headerlink" title="附录 C this 词法"></a>附录 C this 词法</h1><p>ES6 中有一个主题用非常重要的方式将 this同词法作用域联系起来了，我们会简单地讨论一下。</p><p>ES6 添加了一个特殊的语法形式用于函数声明，叫作箭头函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">a</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log( a );</div><div class="line">&#125;;</div><div class="line">foo( <span class="number">2</span> ); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><p>这里称作“胖箭头”的写法通常被当作单调乏味且冗长（挖苦）的 function 关键字的简写。</p><p>看这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  id: <span class="string">"awesome"</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.id );</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> id = <span class="string">"not awesome"</span></div><div class="line">obj.cool(); <span class="comment">// 酷</span></div><div class="line">setTimeout( obj.cool, <span class="number">100</span> ); <span class="comment">// 不酷</span></div></pre></td></tr></table></figure></p><p>问题在于 cool() 函数丢失了同 this 之间的绑定。解决这个问题有好几种办法，但最长用的就是 var self = this;。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  count: <span class="number">0</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (self.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        self.count++;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"awesome?"</span> );</div><div class="line">      &#125;, <span class="number">100</span> );</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.cool(); <span class="comment">// 酷吧？</span></div></pre></td></tr></table></figure><p><code>var self = this</code> 这种解决方案圆满解决了理解和正确使用 <code>this</code> 绑定的问题，并且没有把问题过于复杂化，它使用的是我们非常熟悉的工具：词法作用域。</p><p>ES6 中的箭头函数引入了一个叫作 this 词法的行为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  count: <span class="number">0</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 箭头函数是什么鬼东西？</span></div><div class="line">        <span class="keyword">this</span>.count++;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"awesome?"</span> );</div><div class="line">      &#125;, <span class="number">100</span> );</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.cool(); <span class="comment">// 很酷吧 ?</span></div></pre></td></tr></table></figure></p><p>简单来说，箭头函数在涉及 <code>this</code> 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 <code>this</code> 绑定的规则，取而代之的是用当前的词法作用域覆盖了 <code>this</code> 本来的值。</p><p>因此，这个代码片段中的箭头函数并非是以某种不可预测的方式同所属的 <code>this</code> 进行了解绑定，而只是“继承”了 <code>cool()</code> 函数的 <code>this</code> 绑定（因此调用它并不会出错）。</p><p>箭头函数将程序员们经常犯的一个错误给标准化了，也就是混淆了 <code>this</code> 绑定规则和词法作用域规则。</p><p>换句话说：为什么要自找麻烦使用 <code>this</code> 风格的代码模式呢？把它和词法作用域结合在一起非常让人头疼。在代码中使用两种风格其中的一种是非常自然的事情，但是不要将两种风格混在一起使用。</p><blockquote><p>另一个导致箭头函数不够理想的原因是它们是匿名而非具名的。具名函数比<br>匿名函数更可取的原因参见第 3 章。</p></blockquote><p>在我看来，解决这个“问题”的另一个更合适的办法是正确使用和包含 this 机制。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  count: <span class="number">0</span>,</div><div class="line">  cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.count++; <span class="comment">// this 是安全的</span></div><div class="line">        <span class="comment">// 因为 bind(..)</span></div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"more awesome"</span> );</div><div class="line">      &#125;.bind( <span class="keyword">this</span> ), <span class="number">100</span> ); <span class="comment">// look, bind()!</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.cool(); <span class="comment">// 更酷了。</span></div></pre></td></tr></table></figure></p><p>无论你是喜欢箭头函数中 this 词法的新行为模式，还是喜欢更靠得住的 bind()，都需要注意箭头函数不仅仅意味着可以少写代码。</p><p>它们之间有意为之的不同行为需要我们理解和掌握，才能正确地使用它们。</p><p>现在我们已经完全理解了词法作用域（还有闭包），理解 this 词法是小菜一碟！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于你不知道的JS总结-作用域和闭包的第二部分。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="你不知道的JS" scheme="https://hddhyq.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JS总结-作用域和闭包(一)</title>
    <link href="https://hddhyq.github.io/2018/02/05/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E6%80%BB%E7%BB%93-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85(%E4%B8%80)/"/>
    <id>https://hddhyq.github.io/2018/02/05/你不知道的JS总结-作用域和闭包(一)/</id>
    <published>2018-02-05T08:37:10.000Z</published>
    <updated>2018-12-09T14:14:41.197Z</updated>
    
    <content type="html"><![CDATA[<p>这几天读了下《你不知道的JavaScript（上卷）》,对于书中<strong>作用域和闭包</strong>的知识点做一下总结<br><a id="more"></a></p><h1 id="第-1-章-作用域是什么"><a href="#第-1-章-作用域是什么" class="headerlink" title="第 1 章 作用域是什么"></a>第 1 章 作用域是什么</h1><p>要了解作用域的规则，首先需要了解简单的编译原理。</p><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。</p><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p><ul><li><p>分词/词法分析（Tokenizing/Lexing）</p><p>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。<br>如：var a = 2;  =&gt;  var、a、=、2 、;</p></li><li><p>解析/语法分析（Parsing）</p><p>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。</p></li><li><p>代码生成</p><p>将 AST 转换为可执行代码的过程称被称为代码生成。</p></li></ul><h2 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h2><p>  需要理解三个处理过程中的参与者：</p><ul><li><p>引擎</p><p>从头到尾负责整个 JavaScript 程序的编译及执行过程。</p></li><li><p>编译器</p><p>引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。</p></li><li><p>作用域</p><p>引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p></li></ul><p>例子: <code>var a = 2;</code></p><p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p><p>在赋值中，对于引擎来讲，引擎会为变量 a 进行 <strong>LHS</strong> 查询。另外一个查找的类型叫作 <strong>RHS</strong>。</p><p><strong>RHS</strong> 查询与简单地查找某个变量的值别无二致，而 <strong>LHS</strong> 查询则是试图找到变量的容器本身，从而可以对其赋值。<strong>RHS</strong> 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。</p><p>你可以将 <strong>RHS</strong> 理解成 retrieve his source value（取到它的源值）。</p><h2 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h2><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/UDntKnowJS/作用域.png" alt=""></p><p>不管是<strong>LHS</strong> 和 <strong>RHS</strong>都需要对作用域按照上图进行查找。一旦抵达全局作用域，无论你有没有找到所需变量，查找过程都会终止。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>LHS</strong>和<strong>RHS</strong>,在最终没有找到变量的时候处理方式会有差异:</p><ul><li><strong>RHS</strong> 抛出异常<code>ReferenceError</code></li><li><strong>LHS</strong> 在严格模式，抛出异常<code>ReferenceError</code>,正常模式，会创建一个具有该名称的变量，并将其返还给引擎。</li></ul><p><strong>RHS</strong>　中，如果找到一个变量对这个变量进行不合理的操作。会抛出<code>TypeError</code></p><p><code>ReferenceError</code> 同作用域判别失败相关，而 <code>TypeError</code> 则代表作用域判别成功了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 <strong>LHS</strong> 查询；如果目的是获取变量的值，就会使用 <strong>RHS</strong> 查询。赋值操作符会导致 <strong>LHS</strong> 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p><p>JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 <code>var a = 2</code> 这样的声明会被分解成两个独立的步骤：</p><ol><li>首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li><li>接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。</li></ol><p><strong>LHS</strong> 和 <strong>RHS</strong> 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。不成功的 <strong>RHS</strong> 引用会导致抛出 <code>ReferenceError</code> 异常。不成功的 <strong>LHS</strong> 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 <code>ReferenceError</code> 异常（严格模式下）。</p><h1 id="第-2-章-词法作用域"><a href="#第-2-章-词法作用域" class="headerlink" title="第 2 章 词法作用域"></a>第 2 章 词法作用域</h1><p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的 <strong>词法作用域</strong> ，我们会对这种作用域进行深入讨论。另外一种叫作 <strong>动态作用域</strong>，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。</p><h2 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h2><p>第 1 章介绍过，大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。回忆一下，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。</p><p>简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( a, b, c );</div><div class="line">  &#125;</div><div class="line">  bar( b * <span class="number">3</span> );</div><div class="line">&#125;</div><div class="line">foo( <span class="number">2</span> ); <span class="comment">// 2, 4, 12</span></div></pre></td></tr></table></figure><p>这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们想象成几个逐级包含<br>的气泡。<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/UDntKnowJS/wordScope.png" alt=""></p><ol><li>包含着整个全局作用域，其中只有一个标识符：foo。</li><li>包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。</li><li>包含着 bar 所创建的作用域，其中只有一个标识符：c</li></ol><p>没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。</p><p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“ <strong>遮蔽效应</strong> ”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。</p><p>无论函数在<em>哪里</em>被调用，也无论它<em>如何</em>被调用，它的词法作用域都<em>只由</em>函数被声明时所处的位置决定。</p><h2 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h2><p>如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？</p><p>JavaScript 中有两种机制来实现这个目的</p><ol><li><p>eval </p><p>JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。</p></li><li>with<br>JavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是with 关键字。</li></ol><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>这是我们抛弃上述两个方法的主要原因，</p><p>JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。</p><p>但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。</p><p>如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</p><p>JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。</p><p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。</p><h1 id="第-3-章-函数作用域和块作用域"><a href="#第-3-章-函数作用域和块作用域" class="headerlink" title="第 3 章 函数作用域和块作用域"></a>第 3 章 函数作用域和块作用域</h1><h2 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">  <span class="comment">// 一些代码</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 更多的代码</span></div><div class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡。 在下一章<strong>提升</strong>中会着重介绍。</p><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript 变量可以根据需要改变值类型的“动态”特性。</p><h2 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h2><p>对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。</p><p>有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  b = a + doSomethingElse( a * <span class="number">2</span> );</div><div class="line">  <span class="built_in">console</span>.log( b * <span class="number">3</span> );</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a - <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b;</div><div class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></div></pre></td></tr></table></figure><p>上述的例子中，就是一个反例，将应该私有的变量b和函数doSomethingElse(..)暴露给了外部作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a - <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> b;</div><div class="line">  b = a + doSomethingElse( a * <span class="number">2</span> );</div><div class="line">  <span class="built_in">console</span>.log( b * <span class="number">3</span> );</div><div class="line">&#125;</div><div class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></div></pre></td></tr></table></figure><p>修改后的代码，b和 <code>doSomethingElse(..)</code>都无法从外部被访问。</p><p><strong>规避冲突</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    i = <span class="number">3</span>; <span class="comment">// 修改 for 循环所属作用域中的 i</span></div><div class="line">    <span class="built_in">console</span>.log( a + i );</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">    bar( i * <span class="number">2</span> ); <span class="comment">// 糟糕，无限循环了！</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p><p>bar(..) 内部的赋值表达式 i = 3 意外地覆盖了声明在 foo(..) 内部 for 循环中的 i。在这个例子中将会导致无限循环，因为 i 被固定设置为 3，永远满足小于 10 这个条件。</p><p>这里我们能选用两种方法，一种新声明一个本地变量，<code>var i = 3;</code>。另一种，新添加一个标识符名称，比如 <code>var j = 3</code>。</p><p>软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，所以通过作用域来“隐藏”内部声明是唯一的最佳选择。</p><ol><li>全局命名空间<br>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。</li></ol><p>这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyReallyCoolLibrary = &#123;</div><div class="line">  awesome: <span class="string">"stuff"</span>,</div><div class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  doAnotherThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><ol start="2"><li>模块管理<br>这种避免冲突的方法和现代的木块机制很接近，从众多的模块管理器挑选一个使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。</li></ol><p>显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>在前面我们知道了，在任意代码片段外部添加包装函数，可以讲变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。</p><p>这个方法也有不理想之处。我们必须声明一个具名函数，这也就意味着，这个具名函数的名称已经“污染”了所在作用域。其次，必须显示的调用这个具名函数，才能运行其中的代码。</p><p>如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。</p><p>JS中的同时解决两种问题的方案：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">// &lt;-- 添加这一行</span></div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></div><div class="line">&#125;)(); <span class="comment">// &lt;-- 以及这一行</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><p>包装函数的声明以 (function… 而不仅是以 function… 开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理。其实就是立即执行了。</p><blockquote><p>区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位<br>置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中<br>的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p></blockquote><p><strong>函数声明</strong> 和 <strong>函数表达式</strong> 之间最重要的区别是它们的名称标识符将会绑定在何处。</p><p>(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。</p><h3 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>);</div><div class="line">&#125;, <span class="number">1000</span> );</div></pre></td></tr></table></figure><p>上述的定时的代码片段，我们很熟悉，这就是 <strong>匿名函数表达式</strong> , 因为<code>function()</code>.. 没有名称标识符。</p><p>匿名函数书写起来简单便捷，不过有几个缺点需要考虑。</p><ol><li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</li><li>如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li><li>匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</li></ol><h3 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h3><p><strong>IIFE</strong>, 代表立即执行函数表达式（Immediately Invoked Function Expression）；</p><p>函数名对于<strong>IIFE</strong>不是必需的，IIFE 最常见的用法是使用一个匿名函数表达式。</p><ul><li><strong>IIFE</strong> 的一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。</li><li><strong>IIFE</strong> 另一个场景，解决undefined 标识符的默认值被错误覆盖导致的异常（虽然不常见）。</li><li><strong>IIFE</strong> 是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。</li></ul><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log( i );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 i 会被绑定在外部作用域（函数或全局）中的事实。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  <span class="keyword">var</span> bar = foo * <span class="number">2</span>;</div><div class="line">  bar = something( bar );</div><div class="line">  <span class="built_in">console</span>.log( bar );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用 var 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。这段代码是为了风格更易读而伪装出的形式上的块作用域，如果使用这种形式，要确保没在作用域其他地方意外地使用 bar 只能依靠自觉性。</p><p>块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。实现方法：</p><ol><li>with</li><li>try/catch catch分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。</li><li>let</li></ol><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>这里我们着重介绍下，let的实现原理。</p><p>let关键字可以将变量绑定到所在的任意作用域中，通常是{ .. } 内部.换句话说，let为其声明的变量隐式地了所在的块作用域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  <span class="keyword">let</span> bar = foo * <span class="number">2</span>;</div><div class="line">  bar = something( bar );</div><div class="line">  <span class="built_in">console</span>.log( bar );</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p><p>用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。</p><p>在开发和修改代码的过程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将其包含在其他的块中，就会导致代码变得混乱。</p><p>显示的块作用域，可以解决上述问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  &#123; <span class="comment">// &lt;-- 显式的快</span></div><div class="line">    <span class="keyword">let</span> bar = foo * <span class="number">2</span>;</div><div class="line">    bar = something( bar );</div><div class="line">    <span class="built_in">console</span>.log( bar );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p><p>例子中，我们在 if 声明内部显式地创建了一个块，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响</p><ol><li>垃圾收集</li></ol><p>另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。通过块作用域，能够让引擎知道我们执行后的代码片段不需要继续保存。</p><ol start="2"><li>let循环</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log( i );</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( i ); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure><p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</p><p>下面通过另一种方式来说明每次迭代时进行重新绑定的行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> j;</div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</div><div class="line">    <span class="keyword">let</span> i = j; <span class="comment">// 每个迭代重新绑定！</span></div><div class="line">    <span class="built_in">console</span>.log( i );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>const</strong></p><p>同样可以用来创建块作用域变量，但其值是固定的（常量）。</p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</p><p>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。</p><p>从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。</p><p>在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。</p><p>有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天读了下《你不知道的JavaScript（上卷）》,对于书中&lt;strong&gt;作用域和闭包&lt;/strong&gt;的知识点做一下总结&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://hddhyq.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://hddhyq.github.io/tags/JS/"/>
    
      <category term="你不知道的JS" scheme="https://hddhyq.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"/>
    
  </entry>
  
  <entry>
    <title>《Web性能权威指南》读书总结</title>
    <link href="https://hddhyq.github.io/2018/01/08/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://hddhyq.github.io/2018/01/08/《Web性能权威指南》读书总结/</id>
    <published>2018-01-08T08:13:58.000Z</published>
    <updated>2018-12-09T14:14:41.193Z</updated>
    
    <content type="html"><![CDATA[<p>总结了针对 <strong>HTTP 1.x</strong> 和 <strong>HTTP 2.0</strong> 的优化，以及 <strong>HTTP 2.0</strong> 的一些历史。<br><a id="more"></a></p><h1 id="Web性能优化要点"><a href="#Web性能优化要点" class="headerlink" title="Web性能优化要点"></a>Web性能优化要点</h1><h2 id="宏观的-Web-性能优化"><a href="#宏观的-Web-性能优化" class="headerlink" title="宏观的 Web 性能优化"></a>宏观的 Web 性能优化</h2><ul><li>延迟和带宽对 Web 性能的影响；</li><li>传输协议（TCP）对 HTTP 的限制；</li><li>HTTP 协议自身的功能和缺陷；</li><li>Web 应用的发展趋势及性能需求；</li><li>浏览器局限性和优化思路。</li></ul><p>页面加载时间，是来衡量 Web 性能的事实标准。页面加载时间常简写为PLT（Page Load Time）。</p><p>PLT 的简单定义就是：“浏览器中的加载旋转图标停止旋转的时间。”更技术的定义则是浏览器中的 onload 事件，这个事件由浏览器在文档及其所有依赖资源（JavaScript、图片，等等）下载完毕时触发。</p><p>除了测量每个资源及整个页面的加载时间（PLT），还要关注有关应用的如下几<br>个问题：</p><ul><li>应用加载过程中的里程碑是什么？</li><li>用户第一次交互的时机何在？</li><li>什么交互应该吸引用户参与？</li><li>每个用户的参与及转化率如何？</li></ul><p>接下来我们了解一下 <strong>脚本、样式表和标记文档之间复杂依赖</strong> :<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/WebPerformance/broswer.png" alt=""></p><p>浏览器在解析 HTML 文档的基础上构建  <strong>DOM（Document Object Model，文档对象模型）</strong> 。与此同时，还有一个常常被忽略的模型—— <strong>CSSOM（CSS ObjectModel，CSS 对象模型）</strong> ，也会基于特定的样式表规则和资源构建而成。这两个模型共同创建“渲染树”，之后浏览器就有了足够的信息去进行布局，并在屏幕上绘制图形。到目前为止，一切都很好理解。</p><p>然而，此时不得不提到我们最大的朋友和祸害： <strong>JavaScript</strong> 。脚本执行过程中可能遇到一个同步 <strong>document.write</strong> ，从而阻塞 DOM 的解析和构建。类似地，脚本也可能查询任何对象的计算样式，从而阻塞 CSS 处理。结果，DOM 及 CSSOM的构建频繁地交织在一起：DOM 构建在 JavaScript 执行完毕前无法进行，而 <strong>JavaScript 在 CSSOM 构建完成前也无法进行</strong> 。</p><p>应用的性能，特别是首次加载时的 <strong>“渲染前时间”</strong> ，直接取决于标记、样式表和JavaScript 这三者之间的依赖关系。顺便说一句，还记得流行的“样式在上，脚本在下”的最佳实践吗？现在你该知道为什么了。渲染和脚本执行都会受样式表的阻塞，因此必须让 <strong>CSS</strong> 以最快的速度下载完。</p><p>剩下就是要知道，<strong>延迟是性能瓶颈</strong> 。减少延迟是Web性能优化的关键。分析资源瀑布图，对资源进行合理的分配。</p><h1 id="HTTP-1-x"><a href="#HTTP-1-x" class="headerlink" title="HTTP 1.x"></a>HTTP 1.x</h1><p>放在前面的Steve Souder 的《高性能网站建设指南》中概括了 14 条规则，有一半针对网络优化：</p><ul><li><p>减少DNS查询</p><p>每次域名解析都需要一次网络往返，增加请求的延迟，在查询期间会阻塞请求。</p></li><li><p>减少HTTP请求</p><p><strong>任何请求都不如没有请求更快</strong>，因此要去掉页面上没有必要的资源。</p></li><li><p>使用CDN</p><p>从地理上把数据放到接近客户端的地方，可以显著减少每次 TCP 连接的网络延迟，增加吞吐量。</p></li><li><p>添加Expires首部并配置ETag标签</p><p>相关资源应该缓存，以避免重复请求每个页面中相同的资源。Expires 首部可用于指定缓存时间，在这个时间内可以直接从缓存取得资源，完全避免 HTTP 请求。ETag 及 Last-Modified 首部提供了一个与缓存相关的机制，相当于最后一次更新的指纹或时间戳。</p></li><li><p>Gzip资源</p><p>所有文本资源都应该使用 Gzip 压缩，然后再在客户端与服务器间传输。一般来说，Gzip 可以减少 60%~80% 的文件大小，也是一个相对简单（只要在服务器上配置一个选项），但优化效果较好的举措。</p></li><li><p>避免HTTP重定向</p><p>HTTP 重定向极其耗时，特别是把客户端定向到一个完全不同的域名的情况下，还会导致额外的 DNS 查询、TCP 连接延迟，等等。</p></li></ul><p>现实当中，我们应该对这些技术有正确的认识：它们都是些针对当前HTTP 1.1 协议的局限性而采用的权宜之计。我们本来不应该操心去连接文件、拼合图标、分割域名或嵌入资源。但遗憾的是，“不应该”并不是务实的态度：这些优化手段之所以存在，都是有原因的，在背后的问题被 HTTP 的下一个版本解决之前，必须得依靠它们。</p><h2 id="持久连接的优点"><a href="#持久连接的优点" class="headerlink" title="持久连接的优点"></a>持久连接的优点</h2><p>每个 TCP 连接开始都有三次握手，要经历一次客户端与服务器间完整的往返。此后，会因为 HTTP 请求和响应的两次通信而至少引发另一次往返。最后，还要加上服务器处理时间，才能得到每次请求的总时间。HTTP 持久连接，可以避免再次请求的延迟。</p><p>HTTP 1.1，  默认启用持久连接。用 HTTP 1.0，则可以明确使用 Connection: Keep-Alive 首部声明使用持久连接。</p><h2 id="HTTP管道"><a href="#HTTP管道" class="headerlink" title="HTTP管道"></a>HTTP管道</h2><p>服务器处理完第一次请求后，会发生了一次完整的往返：先是响应回传，接着是第二次请求。在此期间服务器空闲。如果服务器能在处理完第一次请求后，立即开始处理第二次请求呢？</p><p>这就是HTTP管道的作用，通过尽早分派请求，不被每次响应阻塞，可以再次消除额外的网络往返。这样，就从非持久连接状态下的每个请求两次往返，变成了整个请求队列只需要两次网络往返！</p><p>HTTP 1.1 管道的好处，主要就是消除了发送请求和响应的等待时间。这种并行处理请求的能力对提升应用性能的帮助非常之大。</p><p>讨论下HTTP 1.x 协议的一些局限性对，HTTP管道优化的不支持。HTTP 1.x 只能严格串行地返回响应。特别是，HTTP  1.x 不允许一个连接上的多个响应数据交错到达（多路复用），因而一个响应必须完全返回后，下一个响应才会开始传输。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/WebPerformance/HttpPipe.png" alt=""></p><p>演示了如下几个方面：</p><ul><li>HTML 和 CSS 请求同时到达，但先处理的是 HTML 请求</li><li>服务器并行处理两个请求，其中处理 HTML 用时 40 ms，处理 CSS 用时 20 ms；</li><li>CSS 请求先处理完成，但被缓冲起来以等候发送 HTML 响应；</li><li>发送完 HTML 响应后，再发送服务器缓冲中的 CSS 响应。</li></ul><p>实际中，由于不可能实现多路复用，HTTP 管道会导致 HTTP 服务器、代理和客户端出现很多微妙的，不见文档记载的问题：</p><ul><li>一个慢响应就会阻塞所有后续请求；</li><li>并行处理请求时，服务器必须缓冲管道中的响应，从而占用服务器资源，如果有个响应非常大，则很容易形成服务器的受攻击面；</li><li>响应失败可能终止 TCP 连接，从页强迫客户端重新发送对所有后续资源的请求，导致重复处理；</li><li>由于可能存在中间代理，因此检测管道兼容性，确保可靠性很重要；</li><li>如果中间代理不支持管道，那它可能会中断连接，也可能会把所有请求串联起来。</li></ul><p>HTTP 管道技术的应用非常有限，虽然其优点毋庸置疑。今天，一些支持管道的浏览器，通常都将其作为一个高级配置选项，但大多数浏览器都会禁用它。</p><p>实践中部署 HTTP 管道的最佳途径，就是在客户端和服务器间使用安全通道（HTTPS）。这样，就能可靠地避免那些不理解或不支持管道的中间代理的干扰。</p><h2 id="使用多个TCP连接"><a href="#使用多个TCP连接" class="headerlink" title="使用多个TCP连接"></a>使用多个TCP连接</h2><p>由于 HTTP 1.x 不支持多路复用，浏览器可以不假思索地在客户端排队所有 HTTP请求，然后通过一个持久连接，一个接一个地发送这些请求。浏览器开发商没有别的办法，只能允许我们并行打开多个 TCP会话。多少个？现实中，大多数现代浏览器，包括桌面和移动浏览器，都支持每个主机打开 6 个连接。</p><p>同时打开多个 TCP 连接意味着什么:</p><ul><li>客户端可以并行分派最多 6 个请求；</li><li>服务器可以并行处理最多 6 个请求；</li><li>第一次往返可以发送的累计分组数量（TCP cwnd）增长为原来的 6 倍。</li></ul><p>这样做的代价：</p><ul><li>更多的套接字会占用客户端、服务器以及代理的资源，包括内存缓冲区和 CPU时钟周期；</li><li>并行 TCP 流之间竞争共享的带宽；</li><li>由于处理多个套接字，实现复杂性更高；</li><li>即使并行 TCP 流，应用的并行能力也受限制</li></ul><p>实践中，CPU 和内存占用并非微不足道，由此会导致客户端和服务器端的资源占用量上升，运维成本提高。</p><p>cwnd 值最近又提高到了 10 个分组，而所有最新的平台都能可靠地支持 TCP 窗口缩放。</p><h3 id="消耗客户端和服务器资源"><a href="#消耗客户端和服务器资源" class="headerlink" title="消耗客户端和服务器资源"></a>消耗客户端和服务器资源</h3><p>限制每个主机最多 6 个连接，可以让浏览器检测出无意（或有意）的 DoS（Denialof Service）攻击。如果没有这个限制，客户端有可能消耗掉服务器的所有资源。</p><p>讽刺的是，同样的安全检测在某些浏览器上却会招致反向攻击：如果客户端超过了最大连接数，那么所有后来的客户端请求都将被阻塞。大家可以做个试验，在一个主机上同时打开 6 个并行下载，然后再打开第 7 个下载请求，这个请求会挂起，直到前面的请求完成才会执行。</p><p>用足客户端连接的限制似乎是一个可以接受的安全问题，但对于需要实时交付数据的应用而言，这样做越来越容易造成部署上的问题。比如 WebSocket、ServerSent Event 和挂起 XHR，这些会话都会占用整整一个 TCP 流，而不管有无数据传输——记住，没有多路复用一说！实际上，如果你不注意，那很可能自己对自己的应用施加 DoS 攻击。</p><h2 id="域名分区"><a href="#域名分区" class="headerlink" title="域名分区"></a>域名分区</h2><p>HTTP 1.x 协议的一项空白强迫浏览器开发商引入并维护着连接池，每个主机最多 6个 TCP 流。好的一方面是对这些连接的管理工作都由浏览器来处理。作为应用开发者，你根本不必修改自己的应用。不好的一方面呢，就是 6 个并行的连接对你的应用来说可能仍然不够用。</p><p>根据 HTTP Archive 的统计，目前平均每个页面都包含 90 多个独立的资源，如果这些资源都来自同一个主机，那么仍然会导致明显的排队等待（图 11-5）。实际上，何必把自己只限制在一个主机上呢？我们不必只通过一个主机（例如 <a href="http://www.example.com）提供所有资源，而是可以手工将所有资源分散到多个子域名：{shard1,shardn}.example.com。由于主机名称不一样了，就可以突破浏览器的连接限制，实现更高的并行能力。域名分区使用得越多，并行能力就越强！" target="_blank" rel="noopener">www.example.com）提供所有资源，而是可以手工将所有资源分散到多个子域名：{shard1,shardn}.example.com。由于主机名称不一样了，就可以突破浏览器的连接限制，实现更高的并行能力。域名分区使用得越多，并行能力就越强！</a></p><p>天下没有免费的午餐，域名分区也不例外：每个新主机名都要求有一次额外的 DNS 查询，每多一个套接字都会多消耗两端的一些资源，而更糟糕的是，站点作者必须手工分离这些资源，并分别把它们托管到多个主机上。</p><p>实践中，把多个域名（如 shard1.example.com、shard2.example.com）解析到同一个 IP 地址是很常见的做法。所有分区都通过 CNAME DNS 记录指向同一个服务器，而浏览器连接限制针对的是主机名，不是 IP 地址。另外，每个分区也可以指向一个 CDN 或其他可以访问到的服务器。</p><p>怎么计算最优的分区数目呢？这个问题不好回答，因为没有简单的方程式。答案取决于页面中资源的数量（每个页面都可能不一样），以及客户端连接的可用带宽和延迟（因客户端而异）。实际上，我们能做的，就是在调查的基础上做出预测，然后使用固定数量的分区。幸运的话，多这么一点复杂性，还是能给大多数用户带来好处的。</p><p>注意:</p><ul><li>首先，把 TCP 利用好</li><li>浏览器会自动为你打开 6 个连接；</li><li>资源的数量、大小和响应时间都会影响最优的分区数目；</li><li>客户端延迟和带宽会影响最优的分区数目；</li><li>域名分区会因为额外的 DNS 查询和 TCP 慢启动而影响性能。</li></ul><p>域名分区是一种合理但又不完美的优化手段。请大家一定先从最小分区数目（不分区）开始，然后逐个增加分区并度量分区后对应用的影响。现实当中，真正因同时打开十几个连接而提升性能的站点并不多，如果你最终使用了很多分区，那么你会发现减少资源数量或者将它们合并为更少的请求，反而能带来更大的好处。</p><h2 id="度量和控制协议开销"><a href="#度量和控制协议开销" class="headerlink" title="度量和控制协议开销"></a>度量和控制协议开销</h2><p>有时，寥寥 15 个字符的 JSON 消息被 352 字节的 HTTP 首部包裹着，全部以纯文本形式发送——协议字节开销占 96%，而且这还是没有 cookie 的最好情况。减少要传输的首部数据（高度重复且未压缩），可以节省相当于一次往返的延迟时间，显著提升很多 Web 应用的性能。</p><p>主要就是度量下，内容和协议大小，为下节连接和拼合做准备。</p><p>注：</p><ul><li>Cookie 在很多应用中都是常见的性能瓶颈，很多开发者都会忽略它给每次请求增加的额外负担。</li></ul><h2 id="连接与拼合"><a href="#连接与拼合" class="headerlink" title="连接与拼合"></a>连接与拼合</h2><p>最快的请求是不用请求。不管使用什么协议，也不管是什么类型的应用，减少请求次数总是最好的性能优化手段。可是，如果你无论如何也无法减少请求，那么对HTTP 1.x 而言，可以考虑把多个资源捆绑打包到一块，通过一次网络请求获取：</p><ul><li><p>连接</p><p>把多个 JavaScript 或 CSS 文件组合为一个文件。</p></li><li><p>拼合</p><p>把多张图片组合为一个更大的复合的图片。</p></li></ul><p>对 JavaScript 和 CSS 来说，只要保持一定的顺序，就可以做到把多个文件连接起来而不影响代码的行为和执行。类似地，多张图片可以组合为一个“图片精灵”，然后使用 CSS 选择这张大图中的适当部分，显示在浏览器中。这两种技术都具备两方面的优点。</p><ul><li><p>减少协议开销</p><p>通过把文件组合成一个资源，可以消除与文件相关的协议开销。如前所述，每个文件很容易招致 KB 级未压缩数据的开销。</p></li><li><p>应用层管道</p><p>说到传输的字节，这两种技术的效果都好像是启用了 HTTP 管道：来自多个响应的数据前后相继地连接在一起，消除了额外的网络延迟。实际上，就是把管道提高了一层，置入了应用中。</p></li></ul><p>连接和拼合技术都属于以内容为中心的应用层优化，它们通过减少网络往返开销，可以获得明显的性能提升。可是，实现这些技术也要求额外的处理、部署和编码（比如选择图片精灵中子图的 CSS 代码），因而也会给应用带来额外的复杂性。此外，把多个资源打包到一块，也可能给缓存带来负担，影响页面的执行速度。</p><p>要理解为什么这些技术会伤害性能，可以考虑一种并不少见的情况：一个包含十来个 JavaScript 和 CSS 文件的应用，在产品状态下把所有文件合并为一个 CSS 文件和一个 JavaScript 文件。</p><ul><li>相同类型的资源都位于一个 URL（缓存键）下面。</li><li>资源包中可能包含当前页面不需要的内容。</li><li>对资源包中任何文件的更新，都要求重新下载整个资源包，导致较高的字节开销。</li><li>JavaScript 和 CSS 只有在传输完成后才能被解析和执行，因而会拖慢应用的执行速度。</li></ul><p>所以将资源合理的打包很重要。这也需要度量。</p><p>内存占用也会成为问题。对图片精灵来说，浏览器必须分析整个图片，即便实际上只显示了其中的一小块，也要始终把整个图片都保存在内存中。浏览器是不会把不显示的部分从内存中剔除掉的！</p><p>为什么执行速度还会受影响呢？我们知道，浏览器是以递增方式处理HTML 的，而对于 JavaScript 和 CSS 的解析及执行，则要等到整个文件下载完毕。JavaScript 和 CSS 处理器都不允许递增式执行。</p><p><strong>CSS 和 JavaScript 文件大小与执行性能</strong></p><p>CSS 文件越大，浏览器在构建 CSSOM 前经历的阻塞时间就越长，从而推迟首次绘制页面的时间。类似地，JavaScript 文件越大，对执行速度的影响同样越大；小文件倒是能实现“递增式”执行。</p><p>打包文件到底多大合适呢？可惜的是，没有理想的大小。然而，谷歌 PageSpeed团队的测试表明，30~50 KB（压缩后）是每个 JavaScript 文件大小的合适范围：既大到了能够减少小文件带来的网络延迟，还能确保递增及分层式的执行。具体的结果可能会由于应用类型和脚本数量而有所不同。</p><p>总之，连接和拼合是在 HTTP 1.x 协议限制（管道没有得到普遍支持，多请求开销大）的现实之下可行的应用层优化。使用得当的话，这两种技术可以带来明显的性能提升，代价则是增加应用的复杂度，以及导致缓存、更新、执行速度，甚至渲染页面的问题。应用这两种优化时，要注意度量结果，根据实际情况考虑如下问题。</p><ul><li>你的应用在下载很多小型的资源时是否会被阻塞？</li><li>有选择地组合一些请求对你的应用有没有好处？</li><li>放弃缓存粒度对用户有没有负面影响？</li><li>组合图片是否会占用过多内存？</li><li>首次渲染时是否会遭遇延迟执行？</li></ul><p><strong>举例：优化 Gmail 性能</strong></p><p>Gmail 使用了大量 JavaScript，而且也不断拓展了现代浏览器的性能边界。要提升首次加载性能，Gmail 团队尝试了各种技术，目前包括如下这些：</p><ul><li>把首次绘制所需的 CSS 单独拿出来，优先于其他 CSS 文件发送；</li><li>递增地交付较小的 JavaScript 块，以实现递增式执行；</li><li>使用定制的外部更新机制，即客户端在后台下载新的 JavaScript 文件，然后在页面刷新时更新。</li></ul><p>鉴于 Gmail 如此庞大的用户数量，如果所有打开的浏览器都要更新脚本，那哪怕一次简单的 JavaScript 更新，都可能演变为一次自残式的 DoS 攻击。为此，Gmail会在用户使用旧版本页面时，在后台预先加载更新文件，这样既可以分散负荷，又能提升下一次刷新时的速度。这个过程每天都重复不止一次。</p><p>在此基础上，为了让用户感觉第一次加载的速度很快，Gmail 团队还在 HTML 文档中嵌入了关键性 CSS 和 JavaScript，然后以块的形式递增加载其余 JavaScript 文件，以加快脚本执行——第一次打开 Gmail 时显示的进度条，反映的就是这个过程！</p><h2 id="嵌入资源"><a href="#嵌入资源" class="headerlink" title="嵌入资源"></a>嵌入资源</h2><p>嵌入资源是另一种非常流行的优化方法，把资源嵌入文档可以减少请求的次数。比如，JavaScript 和 CSS 代码，通过适当的 script 和 style 块可以直接放在页面中，而图片甚至音频或 PDF 文件，都可以通过数据 URI（data:[mediatype][;base64],data）的方式嵌入到页面中：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"data:image/gif;base64,R0lGODlhAQABAIAAAAA</span></span></div><div class="line"><span class="tag"><span class="string"> AAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw=="</span></span></div><div class="line"><span class="tag"> <span class="attr">alt</span>=<span class="string">"1x1 transparent (GIF) pixel"</span> /&gt;</span></div></pre></td></tr></table></figure></p><p>前面的例子是在文档中嵌入了一个 1×1 的透明 GIF 像素。而任何 MIME类型，只要浏览器能理解，都可以通过类似方式嵌入到页面中，包括PDF、音频、视频。不过，有些浏览器会限制数据 URI 的大小，比如 IE8最大只允许 32 KB。</p><p>建议：</p><ul><li>如果文件很小，而且只有个别页面使用，可以考虑嵌入；</li><li>如果文件很小，但需要在多个页面中重用，应该考虑集中打包；</li><li>如果小文件经常需要更新，就不要嵌入了；</li><li>通过减少 HTTP cookie 的大小将协议开销最小化。</li></ul><p>数据 URI 适合特别小的，理想情况下，最好是只用一次的资源。以嵌入方式放到页面中的资源，应该算是页面的一部分，不能被浏览器、CDN 或其他缓存代理作为单独的资源缓存。换句话说，如果在多个页面中都嵌入同样的资源，那么这个资源将会随着每个页面的加载而被加载，从而增大每个页面的总体大小。另外，如果嵌入资源被更新，那么所有以前出现过它的页面都将被宣告无效，而由客户端重新从服务器获取。</p><p>最后，虽然 CSS 和 JavaScript 等基于文本的资源很容易直接嵌入页面，也不会带来多余的开销，但非文本性资源则必须通过 base64 编码，而这会导致开销明显增大：编码后的资源大小比原大小增大 33% ！</p><h1 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h1><p>HTTP 2.0 可以让我们的应用更快、更简单、更健壮——这几词凑到一块是很罕见的！ HTTP 2.0 把很多以前我们针对 HTTP 1.1 想出来的“歪招儿”一笔勾销，把解决那些问题的方案内置在了传输层中。不仅如此，HTTP 2.0 还为我们进一步优化应用、改进性能，提供了全新的机会！</p><p>HTTP 2.0 的目的就是通过支持请求与响应的多路复用来减少延迟，通过压缩 HTTP首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持。为达成这些目标，HTTP 2.0 还会给我们带来大量其他协议层面的辅助实现，比如新的流量控制、错误处理和更新机制。上述几种机制虽然不是全部，但却是最重要的，所有 Web 开发者都应该理解并在自己的应用中利用它们。</p><p>HTTP 2.0 不会改动 HTTP 的语义。HTTP 方法、状态码、URI 及首部字段，等等这些核心概念一如往常。但是，HTTP 2.0 修改了格式化数据（分帧）的方式，以及客户端与服务器间传输这些数据的方式。这两点统帅全局，通过新的组帧机制向我们的应用隐藏了所有复杂性。换句话说，所有原来的应用都可以不必修改而在新协议运行。这当然是好事。</p><p>可是，我们关心的不止是交付能用的应用，我们目标是交付最佳性能！ HTTP 2.0为我们的应用提供了很多新的优化机制，这些机制是前所未有的，而我们的工作就是把它们都利用好。</p><h2 id="历史及其与SPDY的渊源"><a href="#历史及其与SPDY的渊源" class="headerlink" title="历史及其与SPDY的渊源"></a>历史及其与SPDY的渊源</h2><p>SPDY 是谷歌开发的一个实验性协议，于 2009 年年中发布，其主要目标是通过解决HTTP 1.1 中广为人知的一些性能限制，来减少网页的加载延迟。大致上，这个项目设定的目标如下：</p><ul><li>页面加载时间（PLT，Page Load Time）降低 50%；</li><li>无需网站作者修改任何内容；</li><li>把部署复杂性降至最低，无需变更网络基础设施；</li><li>与开源社区合作开发这个新协议；</li><li>收集真实性能数据，验证这个实验性协议是否有效。</li></ul><p>为了达到降低 50% 页面加载时间的目标，SPDY 引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层 TCP 连接。</p><h2 id="走向HTTP-2-0"><a href="#走向HTTP-2-0" class="headerlink" title="走向HTTP 2.0"></a>走向HTTP 2.0</h2><p>SPDY 是 HTTP 2.0 的催化剂，但 SPDY 并非 HTTP 2.0。2012 年初，W3C 向社会征集 HTTP 2.0 的建议，HTTP-WG 经过内部讨论，决定将 SPDY 规范作为制定标准的基础。从那时起，SPDY 已经经过了很多变化和改进，而且在 HTTP 2.0 官方标准公布之前，还将有很多变化和改进。</p><p>HTTP 2.0 致力于突破上一代标准众所周知的性能限制，但它也是对之前1.x 标准的扩展，而非替代。HTTP 的语义不变，提供的功能不变，HTTP 方法、状态码、URI 和首部字段，等等这些核心概念也不变；这些方面的变化都不在考虑之列。既然如此，那“2.0”还名副其实吗？之所以要递增一个大版本到 2.0，主要是因为它改变了客户端与服务器之间交换数据的方式。为实现宏伟的性能改进目标，HTTP 2.0 增加了新的二进制分帧数据层，而这一层并不兼容之前的 HTTP 1.x 服务器及客户端——是谓 2.0。</p><blockquote><p>除非你在实现 Web 服务器或者定制客户端，需要使用原始的 TCP 套接字，否则你很可能注意不到 HTTP 2.0 技术面的实际变化：所有新的、低级分帧机制都是浏览器和服务器为你处理的。或许唯一的区别就是可选的 API多了一些，比如服务器推送！</p></blockquote><h2 id="设计和技术目标"><a href="#设计和技术目标" class="headerlink" title="设计和技术目标"></a>设计和技术目标</h2><h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h3><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/WebPerformance/http2_1.png" alt=""></p><h3 id="流、消息和帧"><a href="#流、消息和帧" class="headerlink" title="流、消息和帧"></a>流、消息和帧</h3><ul><li><p>流</p><p>已建立的连接上的双向字节流。</p></li><li><p>消息</p><p>与逻辑消息对应的完整的一系列数据帧。</p></li><li><p>帧</p><p>HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流。</p></li></ul><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/WebPerformance/http2_3.png" alt=""></p><p>所有 HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。</p><p>要理解 HTTP 2.0，就必须理解流、消息和帧这几个基本概念。</p><ul><li>所有通信都在一个 TCP 连接上完成。</li><li>流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数<br>标识符（1、2…N）。</li><li>消息是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。</li><li>帧是最小的通信单位，承载着特定类型的数据，如 HTTP 首部、负荷，等等。</li></ul><p>简言之，HTTP 2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。相应地，很多流可以并行地在同一个 TCP 连接上交换消息</p><h3 id="多向请求与响应"><a href="#多向请求与响应" class="headerlink" title="多向请求与响应"></a>多向请求与响应</h3><p>在 HTTP 1.x 中，如果客户端想发送多个并行的请求以及改进性能，那么必须使用多个 TCP 连接。这是 HTTP 1.x 交付模型的直接结果，该模型会保证每个连接每次只交付一个响应（多个响应必须排队）。更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下。</p><p>HTTP 2.0 中新的二进制分帧层突破了这些限制，实现了多向请求和响应：客户端和服务器可以把 HTTP 消息分解为互不依赖的帧（图 12-3），然后乱序发送，最后再在另一端把它们重新组合起来。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/WebPerformance/http2_2.png" alt=""></p><p>优点：</p><ul><li>可以并行交错地发送请求，请求之间互不影响；</li><li>可以并行交错地发送响应，响应之间互不干扰；</li><li>只使用一个连接即可并行发送多个请求和响应；</li><li>消除不必要的延迟，从而减少页面加载的时间；</li><li>不必再为绕过 HTTP 1.x 限制而多做很多工作；</li><li>更多优势。</li></ul><p>总之，HTTP 2.0 的二进制分帧机制解决了 HTTP 1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。结果，就是应用速度更快、开发更简单、部署成本更低。</p><blockquote><p>支持多向请求与响应，可以省掉针对 HTTP 1.x 限制所费的那些脑筋和工作，比如拼接文件、图片精灵、域名分区。类似地，通过减少 TCP 连接的数量，HTTP 2.0 也会减少客户端和服务器的 CPU 及内存占用。</p></blockquote><h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，进一步提升性能。为了做到这一点，每个流都可以带有一个 31 比特的优先值：</p><ul><li>0 表示最高优先级；</li><li>2^31-1 表示最低优先级。</li></ul><p><strong>浏览器请求优先级与 HTTP 2.0</strong><br>浏览器在渲染页面时，并非所有资源都具有相同的优先级：HTML 文档本身对构建 DOM 不可或缺，CSS 对构建 CSSOM 不可或缺，而 DOM 和 CSSOM 的构建都可能受到 JavaScript 资源的阻塞，其他资源（如图片）的优先级都可以降低。</p><p>为加快页面加载速度，所有现代浏览器都会基于资源的类型以及它在页面中的位置排定请求的优先次序，甚至通过之前的访问来学习优先级模式——比如，之前的渲染如果被某些资源阻塞了，那么同样的资源在下一次访问时可能就会被赋予更高的优先级。</p><p>在 HTTP 1.x 中，浏览器极少能利用上述优先级信息，因为协议本身并不支持多路复用，也没有办法向服务器通告请求的优先级。此时，浏览器只能依赖并行连接，且最多只能同时向一个域名发送 6 个请求。于是，在等连接可用期间，请求只能在客户端排队，从而增加了不必要的网络延迟。理论上，HTTP 管道可以解决这个问题，只是由于缺乏支持而无法付诸实践。</p><p>HTTP 2.0 一举解决了所有这些低效的问题：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。</p><p>我们也要合理度量，因为：</p><p>如果服务器不理睬所有优先值，那么可能会导致应用响应变慢：浏览器明明在等关键的 CSS 和 JavaScript，服务器却在发送图片，从而造成渲染阻塞。不过，规定严格的优先级次序也可能带来次优的结果，因为这可能又会引入队首阻塞问题，即某个高优先级的慢请求会不必要地阻塞其他资源的交付。</p><p>服务器可以而且应该交错发送不同优先级别的帧。只要可能，高优先级流都应该优先，包括分配处理资源和客户端与服务器间的带宽。不过，为了最高效地利用底层连接，不同优先级的混合也是必需的。</p><h2 id="每个来源一个连接"><a href="#每个来源一个连接" class="headerlink" title="每个来源一个连接"></a>每个来源一个连接</h2><p>有了新的分帧机制后，HTTP 2.0 不再依赖多个 TCP 连接去实现多流并行了。现在，每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别优先级。于是，所有HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。</p><p>所以我们可以停止<strong>域名分区</strong>了。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>在同一个 TCP 连接上传输多个数据流，就意味着要共享带宽。标定数据流的优先级有助于按序交付，但只有优先级还不足以确定多个数据流或多个连接间的资源分配。为解决这个问题，HTTP 2.0 为数据流和连接的流量控制提供了一个简单的机制：</p><ul><li>流量控制基于每一跳进行，而非端到端的控制；</li><li>流量控制基于窗口更新帧进行，即接收方广播自己准备接收某个数据流的多少字节，以及对整个连接要接收多少字节；</li><li>流量控制窗口大小通过 WINDOW_UPDATE 帧更新，这个字段指定了流 ID 和窗口大小递增值；</li><li>流量控制有方向性，即接收方可能根据自己的情况为每个流乃至整个连接设置任意窗口大小；</li><li>流量控制可以由接收方禁用，包括针对个别的流和针对整个连接。</li></ul><blockquote><p>HTTP 2.0 连接建立之后，客户端与服务器交换 SETTINGS 帧，目的是设置双向的流量控制窗口大小。除此之外，任何一端都可以选择禁用个别流或整个连接的流量控制。</p></blockquote><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。</p><p>为什么需要这样一个机制呢？通常的 Web 应用都由几十个资源组成，客户端需要分析服务器提供的文档才能逐个找到它们。那为什么不让服务器提前就把这些资源推送给客户端，从而减少额外的时间延迟呢？服务器已经知道客户端下一步要请求什么资源了，这时候服务器推送即可派上用场。事实上，如果你在网页里嵌入过 CSS、JavaScript，或者通过数据 URI 嵌入过其他资源，那你就已经亲身体验过服务器推送了。</p><p>把资源直接插入到文档中，就是把资源直接推送给客户端，而无需客户端请求。在HTTP 2.0 中，唯一的不同就是可以把这个过程从应用中拿出来，放到 HTTP 协议本身来实现，而且还带来了如下好处：</p><ul><li>客户端可以缓存推送过来的资源；</li><li>客户端可以拒绝推送过来的资源；</li><li>推送资源可以由不同的页面共享；</li><li>服务器可以按照优先级推送资源。</li></ul><blockquote><p>所有推送的资源都遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。</p></blockquote><h2 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h2><p>HTTP 的每一次通信都会携带一组首部，用于描述传输的资源及其属性。在 HTTP  1.x 中，这些元数据都是以纯文本形式发送的，通常会给每个请求增加 500~800 字节的负荷。如果算上 HTTP cookie，增加的负荷通常会达到上千字节。为减少这些开销并提升性能，HTTP 2.0 会压缩首部元数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结了针对 &lt;strong&gt;HTTP 1.x&lt;/strong&gt; 和 &lt;strong&gt;HTTP 2.0&lt;/strong&gt; 的优化，以及 &lt;strong&gt;HTTP 2.0&lt;/strong&gt; 的一些历史。&lt;br&gt;
    
    </summary>
    
      <category term="web优化" scheme="https://hddhyq.github.io/categories/web%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Web优化" scheme="https://hddhyq.github.io/tags/Web%E4%BC%98%E5%8C%96/"/>
    
      <category term="Web性能" scheme="https://hddhyq.github.io/tags/Web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>css揭秘总结(四)</title>
    <link href="https://hddhyq.github.io/2018/01/05/css%E6%8F%AD%E7%A7%98%E6%80%BB%E7%BB%93%E5%9B%9B/"/>
    <id>https://hddhyq.github.io/2018/01/05/css揭秘总结四/</id>
    <published>2018-01-05T06:15:37.000Z</published>
    <updated>2018-12-09T14:14:41.193Z</updated>
    
    <content type="html"><![CDATA[<p>主要是CSS揭秘的最后一章，过渡与动画。<br><a id="more"></a></p><h1 id="过渡和动画"><a href="#过渡和动画" class="headerlink" title="过渡和动画"></a>过渡和动画</h1><h2 id="42-缓动效果"><a href="#42-缓动效果" class="headerlink" title="42. 缓动效果"></a>42. 缓动效果</h2><blockquote><p>背景知识：基本的 CSS 过渡，基本的 CSS 动画</p></blockquote><h3 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h3><p>给过渡和动画加上缓动效果（比如具有回弹效果的过渡过程）是一种流行的表现手法，可以让界面显得更加生动和真实：在现实世界中，物体从 A点到 B 点的移动往往不是完全匀速的。所以我们主要要讨论的就是回弹效果。这里主要要讲的就是贝塞尔曲线。</p><p>常见需要回弹的效果体验：</p><ul><li>尺寸变化（比如：元素在 :hover 时变大，弹出框从 transform:scale(0) 的状态开始放大显示，柱状图中的每根柱子动态地冒出来，等等）</li><li>角度变化（比如：元素的旋转动作，饼图中的各个扇区以动画的方式从 0°开始展开为实际大小，等等）</li></ul><h3 id="弹跳动画"><a href="#弹跳动画" class="headerlink" title="弹跳动画"></a>弹跳动画</h3><p>常见的内置缓动曲线：<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/csssercets/easeLinear.png" alt=""></p><p>ease-out 是 ease-in 是反向版本。这一对组合正好是实现回弹效果所需要的：每当小球的运动方向相反时，我们希望调速函数也是相反的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> bounce &#123;</div><div class="line"> 60%, 80%, <span class="selector-tag">to</span> &#123;</div><div class="line">   <span class="attribute">transform</span>: <span class="built_in">translateY</span>(400px);</div><div class="line"> <span class="attribute">animation-timing-function</span>: ease-out;</div><div class="line"> &#125;</div><div class="line"> 70% &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(300px); &#125;</div><div class="line"> 90% &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(360px); &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.ball</span> &#123;</div><div class="line"> <span class="comment">/* 其余样式写在这里 */</span></div><div class="line"> <span class="attribute">animation</span>: bounce <span class="number">3s</span> ease-in;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="cubic-bezier-函数"><a href="#cubic-bezier-函数" class="headerlink" title="cubic-bezier() 函数"></a>cubic-bezier() 函数</h3><p>把控制锚点的水平坐标和垂直坐标互换，就可以得到任何调速函数的反向版本。</p><p>cubic-bezier.com</p><h3 id="弹性过渡"><a href="#弹性过渡" class="headerlink" title="弹性过渡"></a>弹性过渡</h3><p>假设有一个文本输入框，每当它被聚焦时，都需要展示一个提示框。</p><p>如果我们需要一个文本框先慢慢扩大至1.1倍，再回弹至1倍，那么收缩的时候，会有一个scale(-0.1)的收缩，而不是scale(1.1)。<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/csssercets/收缩.png" alt=""></p><p>这里我们需要单独设置，盖 <code>transition-duration</code>,可以用 <code>transition</code> 这个简写属性来覆盖所有的值，就不需要显式指定 <code>ease</code>，因为它本来就是初始值。再指定一下<code>transition-property</code>就可以了。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:focus)</span> + <span class="selector-class">.callout</span> &#123;</div><div class="line"> <span class="attribute">transform</span>: <span class="built_in">scale</span>(0);</div><div class="line"> <span class="attribute">transition</span>: .<span class="number">25s</span> transform;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.callout</span> &#123;</div><div class="line"> <span class="attribute">transform-origin</span>: <span class="number">1.4em</span> -.<span class="number">4em</span>;</div><div class="line"> <span class="attribute">transition</span>: .<span class="number">5s</span> <span class="built_in">cubic-bezier</span>(.25,.1,.3,1.5) transform;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="43-逐帧动画"><a href="#43-逐帧动画" class="headerlink" title="43. 逐帧动画"></a>43. 逐帧动画</h2><p>在很多时候，我们需要一个很难（或不可能）只通过某些 CSS 属性的过渡来实现的动画。比如一段卡通影片，或是一个复杂的进度指示框。在这种场景下，基于图片的逐帧动画才是完美的选择；不过想在网页中以一种灵活的方式来实现这种动画，可谓是一项惊人的挑战。</p><h3 id="GIF动画短板"><a href="#GIF动画短板" class="headerlink" title="GIF动画短板"></a>GIF动画短板</h3><ul><li>GIF 图片的所能使用的颜色数量被限制在 256 色。</li><li>GIF 不具备 Alpha 透明的特性。当我们不确定 GIF 动画的下层是什么时，这往往是一个大问题。</li><li>我们无法在 CSS 层面修改动画的某些参数，比如动画的持续时间、循环次数、是否暂停等。</li></ul><p>2004 年，Mozilla 发起了一个建议：在 PNG 格式中增加对逐帧动画的支持，就像 GIF 格式同时支持静态图像和动画一样。这种格式被称作APNG。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>假设我们已经把动画中的所有帧全部拼合到一张 PNG 图片中了，如图:<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/csssercets/菊花图.png" alt=""></p><p>动画平滑特性恰恰毁掉了我们想实现的逐帧动画效果。此时我们需要<code>steps()</code> ：<br><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/csssercets/steps.png" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loader"</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> loader &#123;</div><div class="line"> <span class="selector-tag">to</span> &#123; <span class="attribute">background-position</span>: -<span class="number">800px</span> <span class="number">0</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.loader</span> &#123;</div><div class="line"> <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line"> <span class="attribute">background</span>: <span class="built_in">url</span>(img/loader.png) <span class="number">0</span> <span class="number">0</span>;</div><div class="line"> <span class="attribute">animation</span>: loader <span class="number">1s</span> infinite <span class="built_in">steps</span>(8);</div><div class="line"> <span class="comment">/* 把文本隐藏起来 */</span></div><div class="line"> <span class="attribute">text-indent</span>: <span class="number">200%</span>;</div><div class="line"> <span class="attribute">white-space</span>: nowrap;</div><div class="line"> <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="44-闪烁效果"><a href="#44-闪烁效果" class="headerlink" title="44. 闪烁效果"></a>44. 闪烁效果</h2><blockquote><p>背景知识：基本的 CSS 动画，“逐帧动画”</p></blockquote><h3 id="难题-1"><a href="#难题-1" class="headerlink" title="难题"></a>难题</h3><p>就是通过数次闪烁（不超过三次）来提示用户界面中有某处发生了变化，或者用来凸显出当前链接的目标。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="50-循环动画"><a href="#50-循环动画" class="headerlink" title="50%循环动画"></a>50%循环动画</h4><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/csssercets/生硬闪烁.png" alt="">，<br>将动画的起点，调整到50%来避免生硬的跳转。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> blink-smooth &#123; 50% &#123; <span class="attribute">color</span>: transparent &#125; &#125;</div><div class="line"><span class="selector-class">.highlight</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: <span class="number">1s</span> blink-smooth <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="alternate动画（alternate-reverse动画）"><a href="#alternate动画（alternate-reverse动画）" class="headerlink" title="alternate动画（alternate-reverse动画）"></a>alternate动画（alternate-reverse动画）</h4><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/csssercets/alternate闪烁.png" alt=""><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> blink-smooth &#123; <span class="selector-tag">to</span> &#123; <span class="attribute">color</span>: transparent &#125; &#125;</div><div class="line"><span class="selector-class">.highlight</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: .<span class="number">5s</span> blink-smooth <span class="number">6</span> alternate;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="普通闪烁效果"><a href="#普通闪烁效果" class="headerlink" title="普通闪烁效果"></a>普通闪烁效果</h4><p><code>steps(1)</code>本质上等同于 <code>steps(1, end)</code>。如果直接从0开始跳转，那么感觉就是没有任何效果。颜色值的切换只会发生在动画周期的末尾。因此，我们会看到起始值贯穿于整个动画周期，而终止值只在动画结尾的无限短的时间点处出现。</p><p>唯一的解决方案是调整动画的关键帧，让切换动作发生在 50% 处。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> blink &#123; 50% &#123; <span class="attribute">color</span>: transparent &#125; &#125;</div><div class="line"><span class="selector-class">.highlight</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> blink <span class="number">3</span> <span class="built_in">steps</span>(1); <span class="comment">/* 或用step-end */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="45-打字动画"><a href="#45-打字动画" class="headerlink" title="45. 打字动画"></a>45. 打字动画</h2><blockquote><p>背景知识：基本的 CSS 动画，“逐帧动画”，“闪烁效果”</p></blockquote><h3 id="难题-2"><a href="#难题-2" class="headerlink" title="难题"></a>难题</h3><p>有些时候，我们希望一段文本中的字符逐个显现，模拟出一种打字的效果。这个效果在技术类网站中尤为流行，用等宽字体可以营造出一种终端命令行的感觉。</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/csssercets/打字动画.png" alt=""></p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>核心思路就是让容器的宽度成为动画的主体：把所有文本包裹在这个容器中，然后让它的宽度从 0 开始以步进动画的方式、一个字一个字地扩张到它应有的宽度。你可能已经察觉到了，这个方法是有局限的：它并不适用于多行文本 。然而幸运的是，在绝大多数情况下，我们把这种效果应用在类似标题的单行文本上。</p><p>另外一件需要注意的事情是，动画的持续时间越长，动画效果越差：持续时间较短的动画会让界面显得更加精致，在某些场景下还是有益于可用性的。反之，动画的持续时间越长，越容易让用户感到厌烦。因此，即使这个技巧可以用在大段文本身上，也不一定是个好主意。</p><p>中间需要解决的问题有：</p><ul><li>宽度的变化需要<code>steps</code>，所以<code>steps()</code>来修复。</li><li>我们已经用 em 单位指定了宽度，虽然它比像素单位要好一些，但仍然不够理想。通过 ch 单位来缓解。取值就是字符的数量。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> typing &#123;</div><div class="line"> <span class="selector-tag">from</span> &#123; <span class="attribute">width</span>: <span class="number">0</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line"> <span class="attribute">width</span>: <span class="number">15ch</span>; <span class="comment">/* 文本的宽度 */</span></div><div class="line"> <span class="attribute">overflow</span>: hidden;</div><div class="line"> <span class="attribute">white-space</span>: nowrap;</div><div class="line"> <span class="attribute">animation</span>: typing <span class="number">6s</span> <span class="built_in">steps</span>(15);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后添加上一个闪烁的光标</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> typing &#123;</div><div class="line"> <span class="selector-tag">from</span> &#123; <span class="attribute">width</span>: <span class="number">0</span> &#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> caret &#123;</div><div class="line"> 50% &#123; <span class="attribute">border-color</span>: transparent; &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line"> <span class="attribute">width</span>: <span class="number">15ch</span>; <span class="comment">/* 文本的宽度 */</span></div><div class="line"> <span class="attribute">overflow</span>: hidden;</div><div class="line"> <span class="attribute">white-space</span>: nowrap;</div><div class="line"> <span class="attribute">border-right</span>: .<span class="number">05em</span> solid;</div><div class="line"> <span class="attribute">animation</span>: typing <span class="number">6s</span> <span class="built_in">steps</span>(15),</div><div class="line"> caret <span class="number">1s</span> <span class="built_in">steps</span>(1) infinite;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="46-状态平滑的动画"><a href="#46-状态平滑的动画" class="headerlink" title="46. 状态平滑的动画"></a>46. 状态平滑的动画</h2><blockquote><p>背景知识: 基本的 CSS 动画，animation-direction（在“闪烁效果”中曾简要提及）</p></blockquote><p>不是所有动画都是在页面一加载好就立即播放的。更常见的情况是，我们想通过动画来响应用户的动作，比如用户的鼠标悬停在某个元素上（:hover），或者按住鼠标（:active），等等。在这种场景下，我们将无法控制动画实际的循环次数，因为用户的动作会随时中断动画，而此时动画不可能刚好插放到我们事先指定的循环次数。举例来说，用户的鼠标可能会触发一个华丽的:hover 动画，而在动画还没有播完的时候，鼠标就从元素上移走了。在这种情况下，你觉得动画会如何收场呢？</p><h3 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h3><p>暂停和继续一个一直存在的动画，重要的属性。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">animation-play-state</span>: <span class="selector-tag">paused</span>;</div><div class="line"><span class="selector-tag">animation-play-state</span>: <span class="selector-tag">running</span>;</div></pre></td></tr></table></figure></p><h2 id="沿环形路径平移的动画"><a href="#沿环形路径平移的动画" class="headerlink" title="沿环形路径平移的动画"></a>沿环形路径平移的动画</h2><blockquote><p>背景知识：CSS 动画，CSS 变形，“平行四边形”，“菱形图片”，“闪烁效果”</p></blockquote><h3 id="难题-3"><a href="#难题-3" class="headerlink" title="难题"></a>难题</h3><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/csssercets/环形路径.png" alt=""></p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/Wallpapers/csssercets/404page.png" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"path"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"lea.jpg"</span> <span class="attr">class</span>=<span class="string">"avatar"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> spin &#123;</div><div class="line"> <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(1turn); &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.avatar</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: spin <span class="number">3s</span> infinite linear;</div><div class="line"> <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">150px</span>; <span class="comment">/* 150px = 路径的半径 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它不仅让头像沿着环形路径转动，同时还会让头像自身旋转</p><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/csssercets/自身旋转.png" alt=""></p><p>这里我只放出两个div方案。</p><h3 id="需要两个元素的解决方案"><a href="#需要两个元素的解决方案" class="headerlink" title="需要两个元素的解决方案"></a>需要两个元素的解决方案</h3><p>用内层的变形来抵消外层的变形效果。</p><p>抵消作用是贯穿于整个动画的每一帧的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"path"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"avatar"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"lea.jpg"</span> /&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> spin &#123;</div><div class="line"> <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(1turn); &#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> spin-reverse &#123;</div><div class="line"> <span class="selector-tag">from</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(1turn); &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.avatar</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: spin <span class="number">3s</span> infinite linear;</div><div class="line"> <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">150px</span>; <span class="comment">/* 150px = 路径的半径 */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.avatar</span> &gt; <span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: spin-reverse <span class="number">3s</span> infinite linear;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>利用一套动画css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> spin &#123;</div><div class="line"> <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(1turn); &#125;</div><div class="line"> &#125;</div><div class="line"><span class="selector-class">.avatar</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: spin <span class="number">3s</span> infinite linear;</div><div class="line"> <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">150px</span>; <span class="comment">/* 150px = 路径的半径 */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.avatar</span> &gt; <span class="selector-tag">img</span> &#123;</div><div class="line"> <span class="attribute">animation</span>: inherit;</div><div class="line"> <span class="attribute">animation-direction</span>: reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是CSS揭秘的最后一章，过渡与动画。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://hddhyq.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://hddhyq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css揭秘总结(三)</title>
    <link href="https://hddhyq.github.io/2018/01/03/css%E6%8F%AD%E7%A7%98%E6%80%BB%E7%BB%93%E4%B8%89/"/>
    <id>https://hddhyq.github.io/2018/01/03/css揭秘总结三/</id>
    <published>2018-01-03T10:16:27.000Z</published>
    <updated>2018-12-09T14:14:41.194Z</updated>
    
    <content type="html"><![CDATA[<p>主要总结了书里的字体排版，用户体验，结构与布局。字体排版由于介绍英文比较多，这里就直接跳过了几个段落。<br><a id="more"></a></p><h1 id="字体排印"><a href="#字体排印" class="headerlink" title="字体排印"></a>字体排印</h1><h2 id="20-连字符断行"><a href="#20-连字符断行" class="headerlink" title="20. 连字符断行"></a>20. 连字符断行</h2><p>CSS 文本（第三版）引入了一个新的属性 hyphens。它接受三个值：none、manual 和 auto。manual 是它的初始值，其行为正好对应了现有的工作方式：我们可以在任何时候手工插入软连字符，来实现断词折行的效果。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">hyphens</span>: <span class="selector-tag">auto</span>;</div></pre></td></tr></table></figure></p><h2 id="21-插入换行"><a href="#21-插入换行" class="headerlink" title="21. 插入换行"></a>21. 插入换行</h2><p>通过 CSS 来插入换行的需求通常与定义列表有关。</p><p>利用伪类。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">dd</span> + <span class="selector-tag">dd</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">', '</span>;</div><div class="line"> <span class="attribute">margin-left</span>: -.<span class="number">25em</span>;</div><div class="line"> <span class="attribute">font-weight</span>: normal;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="22-文本行的斑马条纹"><a href="#22-文本行的斑马条纹" class="headerlink" title="22. 文本行的斑马条纹"></a>22. 文本行的斑马条纹</h2><blockquote><p>背景知识: CSS 渐变，background-size，“条纹背景”，“灵活的背景定位”</p></blockquote><h3 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(even)</span> &#123;</div><div class="line"> <span class="attribute">background</span>: <span class="built_in">rgba</span>(0,0,0,.2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>表格的“斑马条纹”，只需要一个伪类的选择就可以了。而文本呢。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们可以在CSS 中用渐变直接生成背景图像，为了让背景自动跟着内边距的宽度走，我们需要在解析 <code>background-position</code>时以 <code>content box</code> 的外沿作为基准。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">padding</span>: <span class="selector-class">.5em</span>;</div><div class="line"><span class="selector-tag">line-height</span>: 1<span class="selector-class">.5</span>;</div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">beige</span>;</div><div class="line"><span class="selector-tag">background-size</span>: <span class="selector-tag">auto</span> 3<span class="selector-tag">em</span>;</div><div class="line"><span class="selector-tag">background-origin</span>: <span class="selector-tag">content-box</span>;</div><div class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">rgba</span>(0,0,0,<span class="selector-class">.2</span>) 50%,</div><div class="line"> <span class="selector-tag">transparent</span> 0);</div></pre></td></tr></table></figure></p><h2 id="23-调整-tab-的宽度"><a href="#23-调整-tab-的宽度" class="headerlink" title="23. 调整 tab 的宽度"></a>23. 调整 tab 的宽度</h2><h3 id="难题-1"><a href="#难题-1" class="headerlink" title="难题"></a>难题</h3><p>调整网页code的宽度。</p><p>利用新属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">pre</span> &#123;</div><div class="line"> <span class="attribute">tab-size</span>: <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="24-连字"><a href="#24-连字" class="headerlink" title="24. 连字"></a>24. 连字</h2><p><code>font-variant-ligatures</code>来控制启用所有可能连字。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">font-variant-ligatures</span>: <span class="selector-tag">common-ligatures</span></div><div class="line">                        <span class="selector-tag">discretionary-ligatures</span></div><div class="line">                        <span class="selector-tag">historical-ligatures</span>;</div></pre></td></tr></table></figure><h2 id="25-华丽的-amp-符号"><a href="#25-华丽的-amp-符号" class="headerlink" title="25. 华丽的 &amp; 符号"></a>25. 华丽的 &amp; 符号</h2><blockquote><p>背景知识: 通过 @font-face </p></blockquote><p>规则实现基本的字体嵌入我们通常会在 font-family 声明中同时指定多个字体（即字体队列）。这样，即使我们指定的最优先字体不可用，浏览器还可以回退到其他符合整体设计风格的字体。</p><p>在这个规则之下，如果有一款字体只包含一个字符（你肯定猜到是哪个了吧），那这款字体将只用于显示这个字符，其他字符会由字体队列中排在第二位、第三位或更后面的字体来显示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">font-face</span> &#123;</div><div class="line"> <span class="attribute">font-family</span>: Ampersand;</div><div class="line"> <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">"fonts/ampersand.woff"</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line"> <span class="attribute">font-family</span>: Ampersand, Helvetica, sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>还需要一个描述符</strong>，<code>unicode-range</code>，要查出你想指定的这些字符的十六进制码位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">font-face</span> &#123;</div><div class="line"> <span class="attribute">font-family</span>: Ampersand;</div><div class="line"> <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">'Baskerville'</span>),</div><div class="line"> <span class="built_in">local</span>(<span class="string">'Goudy Old Style'</span>),</div><div class="line"> <span class="built_in">local</span>(<span class="string">'Palatino'</span>),</div><div class="line"> <span class="built_in">local</span>(<span class="string">'Book Antiqua'</span>);</div><div class="line"> <span class="attribute">unicode-range</span>: U+<span class="number">26</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line"> <span class="attribute">font-family</span>: Ampersand, Helvetica, sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="26-自定义下划线"><a href="#26-自定义下划线" class="headerlink" title="26. 自定义下划线"></a>26. 自定义下划线</h2><blockquote><p>背景知识: CSS 渐变，background-sizetext-shadow，“条纹背景”</p></blockquote><h3 id="难题-2"><a href="#难题-2" class="headerlink" title="难题"></a>难题</h3><p>默认太丑，<code>text-decoration: underline;</code>。</p><p><code>border-bottom</code>，会阻止正常的文本换行行为。<code>box-shadow: 0 -1px gray inset;</code>类似一样的会产生上述问题。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>最佳方案来自于<code>background-image</code> 及其相关属性。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">gray</span>, <span class="selector-tag">gray</span>) <span class="selector-tag">no-repeat</span>;</div><div class="line"><span class="selector-tag">background-size</span>: 100% 1<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">background-position</span>: 0 1<span class="selector-class">.15em</span>;</div></pre></td></tr></table></figure></p><p>新增：</p><ul><li>text-decoration-color 用于自定义下划线或其他装饰效果的颜色。</li><li>text-decoration-style 用于定义装饰效果的风格（比如实线、虚线、波浪线等）。</li><li>text-decoration-skip 用于指定是否避让空格、字母降部或其他对象。</li><li>text-underline-position 用于微调下划线的具体摆放位置。</li></ul><h2 id="27-现实中的文字效果"><a href="#27-现实中的文字效果" class="headerlink" title="27. 现实中的文字效果"></a>27. 现实中的文字效果</h2><blockquote><p>背景知识：基本的 text-shadow</p></blockquote><h3 id="凸版印刷效果"><a href="#凸版印刷效果" class="headerlink" title="凸版印刷效果"></a>凸版印刷效果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">hsl</span>(210, 13%, 40%);</div><div class="line"><span class="selector-tag">color</span>: <span class="selector-tag">hsl</span>(210, 13%, 75%);</div><div class="line"><span class="selector-tag">text-shadow</span>: 0 <span class="selector-tag">-1px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">black</span>;</div></pre></td></tr></table></figure><h3 id="空心字效果"><a href="#空心字效果" class="headerlink" title="空心字效果"></a>空心字效果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">deeppink</span>;</div><div class="line"><span class="selector-tag">color</span>: <span class="selector-tag">white</span>;</div><div class="line"><span class="selector-tag">text-shadow</span>: 1<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">black</span>, <span class="selector-tag">-1px</span> <span class="selector-tag">-1px</span> <span class="selector-tag">black</span>,</div><div class="line"> 1<span class="selector-tag">px</span> <span class="selector-tag">-1px</span> <span class="selector-tag">black</span>, <span class="selector-tag">-1px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">black</span>;</div></pre></td></tr></table></figure><h3 id="文字外发光效果"><a href="#文字外发光效果" class="headerlink" title="文字外发光效果"></a>文字外发光效果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-id">#203</span>;</div><div class="line"><span class="selector-tag">color</span>: <span class="selector-id">#ffc</span>;</div><div class="line"><span class="selector-tag">text-shadow</span>: 0 0 <span class="selector-class">.1em</span>, 0 0 <span class="selector-class">.3em</span>;</div></pre></td></tr></table></figure><h3 id="文字凸起效果"><a href="#文字凸起效果" class="headerlink" title="文字凸起效果"></a>文字凸起效果</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">mixin</span> text-3d(<span class="variable">$color</span>: white, <span class="variable">$depth</span>: 5) &#123;</div><div class="line"> <span class="variable">$shadows</span>: ();</div><div class="line"> <span class="variable">$shadow-color</span>: <span class="variable">$color</span>;</div><div class="line"> @<span class="keyword">for</span> <span class="variable">$i</span> from 1 through <span class="variable">$depth</span> &#123;</div><div class="line"> <span class="variable">$shadow-color</span>: darken(<span class="variable">$shadow-color</span>, <span class="number">10%</span>);</div><div class="line"> <span class="variable">$shadows</span>: append(<span class="variable">$shadows</span>,</div><div class="line"> <span class="number">0</span> (<span class="variable">$i</span> * <span class="number">1px</span>) <span class="variable">$shadow-color</span>, comma);</div><div class="line"> &#125;</div><div class="line"> <span class="attribute">color</span>: <span class="variable">$color</span>;</div><div class="line"> <span class="attribute">text-shadow</span>: append(<span class="variable">$shadows</span>,</div><div class="line"> <span class="number">0</span> (<span class="variable">$depth</span> * <span class="number">1px</span>) <span class="number">10px</span> black, comma);</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123; @<span class="keyword">include</span> text-3d(<span class="number">#eee</span>, 4); &#125;</div></pre></td></tr></table></figure><p>复古风格的排印效果</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@function text-retro(<span class="variable">$color</span>: black, <span class="variable">$depth</span>: 8) &#123;</div><div class="line"> <span class="variable">$shadows</span>: (<span class="number">1px</span> <span class="number">1px</span> <span class="variable">$color</span>,);</div><div class="line"> @<span class="keyword">for</span> <span class="variable">$i</span> from 2 through <span class="variable">$depth</span> &#123;</div><div class="line"> <span class="variable">$shadows</span>: append(<span class="variable">$shadows</span>,</div><div class="line"> (<span class="variable">$i</span>*<span class="number">1px</span>) (<span class="variable">$i</span>*<span class="number">1px</span>) <span class="variable">$color</span>, comma);</div><div class="line">  &#125;</div><div class="line"> @return <span class="variable">$shadows</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line"> <span class="attribute">color</span>: white;</div><div class="line"> <span class="attribute">background</span>: hsl(<span class="number">0</span>,<span class="number">50%</span>,<span class="number">45%</span>);</div><div class="line"> <span class="attribute">text-shadow</span>: text-retro();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="28-环形文字"><a href="#28-环形文字" class="headerlink" title="28. 环形文字"></a>28. 环形文字</h2><blockquote><p>背景知识：基本的 SVG</p></blockquote><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>在 SVG 中，让文本按照路径排列的基本方法就是用一个 <textpath>元 素 来 包 裹 住 这 段 文 本， 再 把 它 们 装 进 一 个 <text> 元 素 中。 这 个<textpath> 元素还需要在它的 ID 属性中引用一个 <path></path> 元素，然后就可以用这个 <path></path> 元素来定义我们想要的路径。</textpath></text></textpath></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$$(<span class="string">'.circular'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> NS = <span class="string">"http://www.w3.org/2000/svg"</span>;</div><div class="line"> <span class="keyword">var</span> xlinkNS = <span class="string">"http://www.w3.org/1999/xlink"</span>;</div><div class="line"> <span class="keyword">var</span> svg = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"svg"</span>);</div><div class="line"> <span class="keyword">var</span> circle = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"path"</span>);</div><div class="line"> <span class="keyword">var</span> text = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"text"</span>);</div><div class="line"> <span class="keyword">var</span> textPath = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"textPath"</span>);</div><div class="line"> svg.setAttribute(<span class="string">"viewBox"</span>, <span class="string">"0 0 100 100"</span>);</div><div class="line"> circle.setAttribute(<span class="string">"d"</span>, <span class="string">"M0,50 a50,50 0 1,1 0,1z"</span>);</div><div class="line"> circle.setAttribute(<span class="string">"id"</span>, <span class="string">"circle"</span>);</div><div class="line"> textPath.textContent = el.textContent;</div><div class="line"> textPath.setAttributeNS(xlinkNS, <span class="string">"xlink:href"</span>, <span class="string">"#circle"</span>);</div><div class="line"> text.appendChild(textPath);</div><div class="line"> svg.appendChild(circle);</div><div class="line"> svg.appendChild(text);</div><div class="line"> el.textContent = <span class="string">''</span>;</div><div class="line"> el.appendChild(svg);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h1 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h1><h2 id="29-选用合适的鼠标光标"><a href="#29-选用合适的鼠标光标" class="headerlink" title="29. 选用合适的鼠标光标"></a>29. 选用合适的鼠标光标</h2><h3 id="难题-3"><a href="#难题-3" class="headerlink" title="难题"></a>难题</h3><p>通过 <code>cursor</code> 属性来指定光标类型，比如 pointer 光标可以提示某个元素是可点击的，而 help 光标用来暗示这里有提示信息。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/csssercets/cursor.png" alt=""></p><ol><li><p>提示禁用状态</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:disabled</span>, <span class="selector-attr">[disabled]</span>, <span class="selector-attr">[aria-disabled="true"]</span> &#123;</div><div class="line"> <span class="attribute">cursor</span>: not-allowed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>隐藏鼠标光标</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">video</span> &#123;</div><div class="line"> <span class="attribute">cursor</span>: <span class="built_in">url</span>(transparent.gif);</div><div class="line"> <span class="attribute">cursor</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="30-扩大可点击区域"><a href="#30-扩大可点击区域" class="headerlink" title="30. 扩大可点击区域"></a>30. 扩大可点击区域</h2><h3 id="难题-4"><a href="#难题-4" class="headerlink" title="难题"></a>难题</h3><p>其可点击区域（热区）向外扩张往往也可以带来可用性的提升。没有人愿意对一个狭小的按钮尝试点按很多次。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>首先<code>cursor: pointer</code>，然后伪元素。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">button</span> &#123;</div><div class="line"> <span class="attribute">position</span>: relative;</div><div class="line">  <span class="comment">/* [其余样式] */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">top</span>: -<span class="number">10px</span>; <span class="attribute">right</span>: -<span class="number">10px</span>;</div><div class="line"> <span class="attribute">bottom</span>: -<span class="number">10px</span>; <span class="attribute">left</span>: -<span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="31-自定义复选框"><a href="#31-自定义复选框" class="headerlink" title="31. 自定义复选框"></a>31. 自定义复选框</h2><h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>当 <label> 元素与复选框关联之后，也可以起到触发开关的作用。</label></p><p>由于 label 不是复选框那样的替换元素，我们可以为它添加生成性内容（伪元素），并基于复选框的状态来为其设置样式。然后，就可以把真正的复选框隐藏起来（但不能把它从 tab 键切换焦点的队列中完全删除），再把生成性内容美化一番，用来顶替原来的复选框！</p><p>试一试<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"awesome"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"awesome"</span>&gt;</span>Awesome!<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">'\a0'</span>; <span class="comment">/* 不换行空格 */</span></div><div class="line"> <span class="attribute">display</span>: inline-block;</div><div class="line"> <span class="attribute">vertical-align</span>: .<span class="number">2em</span>;</div><div class="line"> <span class="attribute">width</span>: .<span class="number">8em</span>;</div><div class="line"> <span class="attribute">height</span>: .<span class="number">8em</span>;</div><div class="line"> <span class="attribute">margin-right</span>: .<span class="number">2em</span>;</div><div class="line"> <span class="attribute">border-radius</span>: .<span class="number">2em</span>;</div><div class="line"> <span class="attribute">background</span>: silver;</div><div class="line"> <span class="attribute">text-indent</span>: .<span class="number">15em</span>;</div><div class="line"> <span class="attribute">line-height</span>: .<span class="number">65</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">content</span>: <span class="string">'\2713'</span>;</div><div class="line"> <span class="attribute">background</span>: yellowgreen;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 把原来的复选框以一种不损失可</span></div><div class="line"><span class="comment">访问性的方式隐藏起来  */</span></div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span> &#123;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">clip</span>: <span class="built_in">rect</span>(0,0,0,0);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 聚焦或禁用时改变它的样式 */</span></div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:focus</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> .<span class="number">1em</span> .<span class="number">1em</span> <span class="number">#58a</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:disabled</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"> <span class="attribute">background</span>: gray;</div><div class="line"> <span class="attribute">box-shadow</span>: none;</div><div class="line"> <span class="attribute">color</span>: <span class="number">#555</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://images-1253206717.cos.ap-guangzhou.myqcloud.com/csssercets/labelinput.png" alt=""></p><h3 id="开关式按钮"><a href="#开关式按钮" class="headerlink" title="开关式按钮"></a>开关式按钮</h3><p>其实只需要把 label 设置为按钮的样式即可，并不需要用到伪元素。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span> &#123;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">clip</span>: <span class="built_in">rect</span>(0,0,0,0);</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span> + <span class="selector-tag">label</span> &#123;</div><div class="line"> <span class="attribute">display</span>: inline-block;</div><div class="line"> <span class="attribute">padding</span>: .<span class="number">3em</span> .<span class="number">5em</span>;</div><div class="line"> <span class="attribute">background</span>: <span class="number">#ccc</span>;</div><div class="line"> <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(#ddd, #bbb);</div><div class="line"> <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(0,0,0,.2);</div><div class="line"> <span class="attribute">border-radius</span>: .<span class="number">3em</span>;</div><div class="line"> <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> white inset;</div><div class="line"> <span class="attribute">text-align</span>: center;</div><div class="line"> <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> white;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span>,</div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:active</span> + <span class="selector-tag">label</span> &#123;</div><div class="line"> <span class="attribute">box-shadow</span>: .<span class="number">05em</span> .<span class="number">1em</span> .<span class="number">2em</span> <span class="built_in">rgba</span>(0,0,0,.6) inset;</div><div class="line"> <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(0,0,0,.3);</div><div class="line"> <span class="attribute">background</span>: <span class="number">#bbb</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="32-通过阴影来弱化背景"><a href="#32-通过阴影来弱化背景" class="headerlink" title="32. 通过阴影来弱化背景"></a>32. 通过阴影来弱化背景</h2><blockquote><p>背景知识：RGBA 颜色</p></blockquote><p>设置一个足够大的<code>box-shadow</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 0 50<span class="selector-tag">vmax</span> <span class="selector-tag">rgba</span>(0,0,0,<span class="selector-class">.8</span>);</div></pre></td></tr></table></figure></p><p>然而没啥用，不能js交互。</p><p>作者推荐有限度地应用这个技巧，比如配合固定定位来使用，或者当页面没有滚动条时再用。</p><h3 id="通过模糊来弱化背景"><a href="#通过模糊来弱化背景" class="headerlink" title="通过模糊来弱化背景"></a>通过模糊来弱化背景</h3><p>mask添加<code>filter</code></p><h2 id="34-滚动提示"><a href="#34-滚动提示" class="headerlink" title="34. 滚动提示"></a>34. 滚动提示</h2><blockquote><p>背景知识：CSS 渐变，background-size</p></blockquote><p>给个网址：</p><p><a href="https://www.w3cplus.com/css3/css-secrets/scrolling-hints.html" target="_blank" rel="noopener">https://www.w3cplus.com/css3/css-secrets/scrolling-hints.html</a></p><h2 id="35-交互式的图片对比控件"><a href="#35-交互式的图片对比控件" class="headerlink" title="35. 交互式的图片对比控件"></a>35. 交互式的图片对比控件</h2><p><a href="https://www.w3cplus.com/css3/css-secrets/interactive-image-comparison.html" target="_blank" rel="noopener">https://www.w3cplus.com/css3/css-secrets/interactive-image-comparison.html</a></p><h1 id="结构与布局"><a href="#结构与布局" class="headerlink" title="结构与布局"></a>结构与布局</h1><h2 id="36-自适应内部元素"><a href="#36-自适应内部元素" class="headerlink" title="36. 自适应内部元素"></a>36. 自适应内部元素</h2><p><code>min-content</code><br>这个关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽的单词、图片或具有固定宽度的盒元素<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">figure</span> &#123;</div><div class="line"> <span class="attribute">max-width</span>: <span class="number">300px</span>;</div><div class="line"> <span class="attribute">max-width</span>: min-content;</div><div class="line"> <span class="attribute">margin</span>: auto;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">figure</span> &gt; <span class="selector-tag">img</span> &#123; <span class="attribute">max-width</span>: inherit; &#125;</div></pre></td></tr></table></figure></p><h2 id="37-精确控制表格列宽"><a href="#37-精确控制表格列宽" class="headerlink" title="37. 精确控制表格列宽"></a>37. 精确控制表格列宽</h2><p>只需：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">table</span> &#123;</div><div class="line"> <span class="attribute">table-layout</span>: fixed;</div><div class="line"> <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="38-根据兄弟元素的数量来设置样式"><a href="#38-根据兄弟元素的数量来设置样式" class="headerlink" title="38. 根据兄弟元素的数量来设置样式"></a>38. 根据兄弟元素的数量来设置样式</h2><h3 id="难题-5"><a href="#难题-5" class="headerlink" title="难题"></a>难题</h3><p>在某些场景下，我们需要根据兄弟元素的总数来为它们设置样式。最常见的场景就是，当一个列表不断延长时，通过隐藏控件或压缩控件等方式来节省屏幕空间，以此提升用户体验。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>利用两次伪类选择。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 定义mixin */</span></div><div class="line">@<span class="keyword">mixin</span> n-items(<span class="variable">$n</span>) &#123;</div><div class="line"> &amp;:first-child:nth-last-child(#&#123;<span class="variable">$n</span>&#125;),</div><div class="line"> &amp;:first-child:nth-last-child(#&#123;<span class="variable">$n</span>&#125;) ~ &amp; &#123;</div><div class="line"> @<span class="keyword">content</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 调用时是这样的： */</span></div><div class="line"><span class="selector-tag">li</span> &#123;</div><div class="line"> @<span class="keyword">include</span> n-items(<span class="number">4</span>) &#123;</div><div class="line"> <span class="comment">/* 属性与值写在这里 */</span></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="根据兄弟元素的数量范围来匹配元素"><a href="#根据兄弟元素的数量范围来匹配元素" class="headerlink" title="根据兄弟元素的数量范围来匹配元素"></a>根据兄弟元素的数量范围来匹配元素</h3><p>变量方式。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:nth-last-child(n+4)</span>,</div><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:nth-last-child(n+4)</span> ~ <span class="selector-tag">li</span> &#123;</div><div class="line"> <span class="comment">/* 当列表至少包含四项时，命中所有列表项 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>假设我们希望在列表包含 2 ～ 6 个列表项时命中所有的列表项，可以<br>这样写：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:nth-last-child(n+2)</span><span class="selector-pseudo">:nth-last-child(-n+6)</span>,</div><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:nth-last-child(n+2)</span><span class="selector-pseudo">:nth-last-child(-n+6)</span> ~ <span class="selector-tag">li</span> &#123;</div><div class="line"> <span class="comment">/* 当列表包含2～6项时，命中所有列表项 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="39-满幅的背景，定宽的内容"><a href="#39-满幅的背景，定宽的内容" class="headerlink" title="39. 满幅的背景，定宽的内容"></a>39. 满幅的背景，定宽的内容</h2><h3 id="难题-6"><a href="#难题-6" class="headerlink" title="难题"></a>难题</h3><p>在过去的几年间，有一种网页设计手法逐渐流行起来，我将它称作背景宽度满幅，内容宽度固定</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>利用算术表达式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line"> <span class="attribute">max-width</span>: <span class="number">900px</span>;</div><div class="line"> <span class="attribute">margin</span>: <span class="number">1em</span> <span class="built_in">calc</span>(50% - 450px);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果我们将长度值应用到父元素的padding上。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">footer</span> &#123;</div><div class="line"> <span class="attribute">max-width</span>: <span class="number">900px</span>;</div><div class="line"> <span class="attribute">padding</span>: <span class="number">1em</span> <span class="built_in">calc</span>(50% - 450px);</div><div class="line"> <span class="attribute">background</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.wrapper</span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 回退机制 */</span></div><div class="line"><span class="selector-tag">footer</span> &#123;</div><div class="line"> <span class="attribute">padding</span>: <span class="number">1em</span>;</div><div class="line"> <span class="attribute">padding</span>: <span class="number">1em</span> <span class="built_in">calc</span>(50% - 450px);</div><div class="line"> <span class="attribute">background</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="40-垂直居中"><a href="#40-垂直居中" class="headerlink" title="40. 垂直居中"></a>40. 垂直居中</h2><h3 id="基于绝对定位的解决方案"><a href="#基于绝对定位的解决方案" class="headerlink" title="基于绝对定位的解决方案"></a>基于绝对定位的解决方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">main</span> &#123;</div><div class="line"> <span class="attribute">position</span>: absolute;</div><div class="line"> <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line"> <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line"> <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于视口单位的解决方案"><a href="#基于视口单位的解决方案" class="headerlink" title="基于视口单位的解决方案"></a>基于视口单位的解决方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">main</span> &#123;</div><div class="line"> <span class="attribute">width</span>: <span class="number">18em</span>;</div><div class="line"> <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">1.5em</span>;</div><div class="line"> <span class="attribute">margin</span>: <span class="number">50vh</span> auto <span class="number">0</span>;</div><div class="line"> <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基于-Flexbox-的解决方案"><a href="#基于-Flexbox-的解决方案" class="headerlink" title="基于 Flexbox 的解决方案"></a>基于 Flexbox 的解决方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">main</span> &#123;</div><div class="line"> <span class="attribute">display</span>: flex;</div><div class="line"> <span class="attribute">align-items</span>: center;</div><div class="line"> <span class="attribute">justify-content</span>: center;</div><div class="line"> <span class="attribute">width</span>: <span class="number">18em</span>;</div><div class="line"> <span class="attribute">height</span>: <span class="number">10em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="41-紧贴底部的页脚"><a href="#41-紧贴底部的页脚" class="headerlink" title="41. 紧贴底部的页脚"></a>41. 紧贴底部的页脚</h2><blockquote><p>背景知识：视口相关的长度单位（参见“垂直居中”），calc()</p></blockquote><h3 id="calc-函数"><a href="#calc-函数" class="headerlink" title="calc() 函数"></a>calc() 函数</h3><p>我们可以把 <header> 和 <main> 元素包在一个容器里，然后在算式中就只需要考虑页脚的高度了：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#wrapper</span> &#123;</div><div class="line"> <span class="attribute">min-height</span>: <span class="built_in">calc</span>(100vh - 7em);</div><div class="line">&#125;</div></pre></td></tr></table></figure></main></header></p><h3 id="更灵活的解决方案flex"><a href="#更灵活的解决方案flex" class="headerlink" title="更灵活的解决方案flex"></a>更灵活的解决方案flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line"> <span class="attribute">display</span>: flex;</div><div class="line"> <span class="attribute">flex-flow</span>: column;</div><div class="line"> <span class="attribute">min-height</span>: <span class="number">100vh</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">main</span> &#123; <span class="attribute">flex</span>: <span class="number">1</span>; &#125;</div></pre></td></tr></table></figure><p>这 个 <code>flex</code> 属性实际上是<code>flex-grow</code>、<code>flex-shrink</code> 和<code>flex-basis</code> 的简写语法。 任何元素只要设置了一个大于 0 的<code>flex</code> 值，就将获得可伸缩的特性；<code>flex</code> 的值负责控制多个可伸缩元素之间的尺寸分配比例。举例来说，在我们眼前的这个例子中， 如 果 <code>&lt;main&gt;</code> 是 flex: 2 而<code>&lt;footer&gt;</code> 是 flex: 1，那么内容区块的高度将是页脚高度的两倍。如果把它们的值从 2 和 1 改为 4 和 2，结果也是一样的，因为真正起作用的是它们的数值比例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要总结了书里的字体排版，用户体验，结构与布局。字体排版由于介绍英文比较多，这里就直接跳过了几个段落。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://hddhyq.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://hddhyq.github.io/tags/CSS/"/>
    
  </entry>
  
</feed>
