{"pages":[{"title":"","text":"google-site-verification: google0d6f72050fc22a0c.html","link":"/google0d6f72050fc22a0c.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"","text":"个人简介","link":"/about/index.html"},{"title":"","text":"来而不往非礼也 畅所欲言，有留必应","link":"/message/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"CircleCI实践gh-pages部署","text":"这里展示一下CircleCI集成与github之间联系。 当你在Circle中添加一个项目时。相关的 GitHub 设置中将会使用您在注册时为CircleCI提供的权限。 deloy key 用来从 GitHub 中查看项目源代码。 service hook 用来通知 CircleCI ，当你向 GitHub 中提交代码。 常见 push hooks： 另外 两个钩子： * 提供PR hooks，用来储存 PR 请求。 * 如果PR钩子在forked的项目中，CircleCI将会在PRs在分支仓库创建时提交。 详见 workflows filters CircleCI在每次测试都会清理容器。你的 github 的仪表盘中也会有显示。 使你CircleCI的项目能够检出私有仓库 如果你的测试过程涉及多个存储库，除了部署密钥之外，CircleCI还需要GitHub用户密钥，因为每个部署密钥仅对一个储存库有效，而GitHub用户莫要可以访问所有GitHub储存库。查看adding ssh keys章节来查看更多。 在 Project Settings &gt; Checkout SSH keys 页面提供给 CircleCI GitHub用户私钥。CircleCI创建和关联新的SSH密钥来访问你的所有的仓库。 用户密钥安全 CircleCI 绝对不会公开你的SSH密钥。 请记住，SSH密钥只能分享给信任的用户，所有的 GitHub 合作者拥有了SSH密钥都可以访问你的仓库。所以要确保你的SSH密钥的安全。 用户密钥访问相关错误信息 下面的错误表明你需要添加用户密钥 Python: 在 pip install步骤期间 1ERROR: Repository not found. Ruby: 在bundle install步骤期间 1Permission denied (publickey). 创建机器用户 要对多个存储库进行细粒度访问，请考虑为CircleCI项目创建机器用户。一个机器用户是你为运行自动化任务而创建的GitHub用户。通过使用机器用户的SSH密钥，你可以允许任何人对仓库进行，构造，测试和部署项目。创建机器用户还可以降低丢失与单个用户关联的凭据的风险。 要为机器用户使用SSH密钥，请遵循下列步骤： 注意: 要执行下列步骤，机器用户必须拥有管理员权限。完成项目添加后，可以将机器用户权限设为只读。 根据instructions on GitHub，创建机器用户权限。 作为机器用户登陆Github。 登陆CircleCI。当GitHub提醒你需要授权给CircleCI的时候，点击 Authorize application 按钮。 在添加项目, follow你希望使用机器用户访问的项目。 在 Project Settings &gt; Checkout SSH keys页面，点击 Authorize With GitHub 按钮。这将给CircleCI权限作为机器用户去创造和上传SSH密钥。 点击 Create and add XXXX user Key 按钮。 现在Circle将使用机器用户的SSH密钥来使用Git命令行运行你的构建。 权限概述 CircleCI要求你的版本控制系统（VCS）提供以下权限，GitHub permissions model 读权限 获取用户的邮件地址 写权限 给仓库添加部署密钥 给仓库添加服务器钩子 获取用户所有仓库的列表 给用户账户添加SSH密钥 注意: CircleCI只有在必须的时候才会请求权限。但是，CircleCI受到VCS提供的权限约束。举例，从GitHub获取所有用户仓库，需要写权限，因为GitHub没有提供只读权限。 如果你强烈的希望减少CircleCI的使用，考虑向你的VCS供应商联系。 团队账户权限 本节概述了可用于满足各种业务需求的团队和个人帐户选择： 如果单个用户拥有个人GitHub账户，他会使用它登录CircleCI然后在CircleCI里follow任务。GitHub中该存储库上的每个“协作者”也能够跟踪项目并在推送提交时构建在CircleCI上。由于GitHub储存协作者的方式，CircleCI不会显示完整的列表。有关合作者的完整列表需要参阅GitHub。 如果一个个人用户升级到团队用户，他们将被允许添加用户，甚至给那些运行构建任务的合作者管理者权限。团队用户的拥有者必须到CircleCI的Add Project，点击链接到GitHub应用权限界面，选择授权CircleCI来使组织的成员通过他们的账户follow项目。拥有两名成员的团队帐户每月25美元，而不是个人帐户每月7美元。 对于最多五人的团队，个人Bitbucket账户可免费用于私人回购。个人可以创建Bitbucket团队，添加成员并根据需要为需要构建的人员提供管理员权限。该项目将出现在CircleCI中，供会员遵循，无需额外费用。 如何为GitHub组织重新启用CircleCI 这一章节描述了如何在GitHub组织启用了第三方应用程序限制后重新启用CircleCi。参见[GitHub Seeting]。 \"申请进入\"，如果你不是组织的管理者会有这种问题。管理者应该批准访问。 \"授予访问权限\"如果你是管理者应该给予。 获取访问权限后，CircleCi的行为将会正常。 GitHub最近添加了在每个组织级别准第三方程序访问权限。再此之前，组织的成员都能授权给应用（生成 OAhth token 关联他们的GitHub用户账户），而且应用可以使用 OAuth token 来代表用户行事，可以使用OAuth flow中的任何权限。 现在的当第三方组织限制打开的时候，OAuth token默认情况下没有办法访问第三方数据。不管是OAuth进程之前或者之后，你必须准备为组织申请权限，然后组织管理者需要批准权限。 你也可以在GitHub的组织设置界面打开第三方访问权限。并单击“第三方应用程序访问策略”部分中的“设置应用程序访问限制”按钮。 如果您对已运行CircleCI的组织启用这些限制，那么我们将停止从GitHub接收推送事件挂钩（因此不会构建新的推送）。而且API调用将被拒绝（例如，导致重新构建旧版本以使源检出失败。）要使CircleCI再次运行，您必须授予对CircleCI应用程序的访问权限。 部署密钥和用户密钥 什么是部署密钥？ 当你创建新项目的时候，CircleCi将会为你的项目在基于网络的分布式系统上（例如GitHub和Bitbucket）创建密钥。部署密钥是仓库专属的密钥。如果你使用GitHub作为你的分布式系统，而且GitHub有用公钥，CircleCi将会储存私有秘钥。部署密钥给CircleCi访问单个仓库的权限。为了保护CircleCi不能推送内容到你的仓库，部署密钥是只读的。 如果你想要在构建中push内容到你的仓库，你需要一个拥有读写取新鲜的部署密钥，即用户密钥。下面几步展示了为你的VCS创建用户密钥。 什么是用户密钥？ 一个用户密钥是用户专属的SSH密钥。你的VCS拥有公钥，CircleCi存储私钥。拥有私钥能够给予你模仿用户的能力，像使用git访问项目。 创建GitHub用户密钥 在下面的例子中，GitHub仓库是https://github.com/you/test-repo，你的CircleCi项目是https://circleci.com/gh/you/test-repo。 根据GitHub instructions创建SSH密钥。当提示输入密码的时候，一定不要输入密码。 警告：默认情况下，ssh-keygen中的最新更新不会以PEM格式生成密钥。如果你的密钥不是以-----BEGIN RSA PRIVATE KEY-----开始，通过使用ssh-keygen -m PEM -t rsa -C \"your_email@example.com\"来强制生成密钥。 到https://github.com/you/test-repo/settings/keys，点击\"Add deploy key\"。在 Title 输入框写下标题，复制粘贴你在第一步创建的密钥，点击\"Allow write access\"，然后点击\"Add key\"。 到 https://circleci.com/gh/you/test-repo/edit#ssh，添加在上面创建的密钥到\"Hostname\"输入框，输入\"github.com\"，添加提交按钮 在你的 config.yml ，添加指纹到add_ssh_keys。 1234567version: 2jobs: deploy-job: steps: - add_ssh_keys: fingerprints: - \"SO:ME:FIN:G:ER:PR:IN:T\" 这些键是怎么用的？ 当CircleCi构建你的项目的时候，私有秘钥会被创建到.ssh目录，随后将SSH配置为与您的版本控制提供程序进行通信。此后，私有秘钥会给用户提供下列权限： 检查主要项目。 检查任何 GitHub 托管的子项目。 检查任何 GitHub 托管的私有依赖项。 自动化 git 的合并和打标签等操作。 由于上述的原因，部署建对于需要添加私有依赖项的项目功能不够强大。 关于安全因素？ 私钥对于CircleCi生成的密钥绝对不会离开CircleCi系统，只有公钥会被传输给GitHub。私钥会被安全加密的存储。然而，当你将私钥用于你构建的容器，你的CircleCi的任何代码都可以读到他们。 部署密钥和用户密钥的区别？ 部署密钥和用户密钥是GitHub唯一支持的密钥类型。部署密钥是全局唯一的，举例来说，没有机制能使部署密钥访问多个仓库。而用户密钥没有分割区域，用户可以访问所有与之相关的仓库。 为了实现访问多个不同的仓库，应该考录常见一个GitHub的机器用户。给这个用户你构建项目所需要的权限，然后再CircleCi上关联用户密钥到你的项目。 关于GitHub机器用户 如果你的服务需要访问多个仓库，你可以创建一个新的GitHub账户，然后连接的SSH密钥，仅仅用以项目的自动化。这样的Github账户不会被用户使用，这样的Github账户被称作机器账户。你可以添加一个机器用户作为个人账户的合作者（授予读写权限），或者作为公共仓库的外有合作者（授予读写或者管理者权限），或者作为需要自动化的团队仓库。 GitHub服务条框是: 不允许机器或者自动化注册账户. 这表示你不能自动创建账户.但是如果你只是创建一个私有用户来为你的项目或者组织运行自动化脚本,这么做是推荐的. Pros 任何有权访问仓库或者服务的人都有能力部署项目. 真实用户,或者说是人类用户,不需要改变他们的本地SSH密钥. 多个密钥是不需要的,一个服务就够了. Cons 只有组织能够限制机器用户值有读写权限.个人仓库总是授予合作者读写权限. 机器用户密钥和部署密钥一样,不受密码保护. 创建 运行ssh-keygen过程在你的服务器上,然后通过机器用户连接公钥. 给及其用户你想自动化的仓库.你可以通过添加账户作为合作者,作为一个外界合作者,或者组织的一个团队. gh-pages实践步骤 1. 创建机器用户 经过上面的介绍，基本上应该知道。push dist 目录到相应的分支，这里需要用到push的权限。我们必不可少的就是需要一个用户密钥。使用用户密钥的方法就是利用新创建一个git用户，下面我创建了一个hddMachine的用户。然后原仓库的管理者将机器用户添加到合作者中，然后在CircleCI中生成对应的fingerprints，并添加到下面的yml文件。这样当我们每次push的时候就会调用机器用户权限来使用 git 命令。 git 12345678910111213141516171819202122232425262728293031323334353637version: 2jobs: build: working_directory: ~/repo # directory where steps will run docker: # use the docker executor type; machine and macos executors are also supported - image: circleci/node:8.10 # the primary container, where your job's commands are run filters: branches: only: master steps: - add_ssh_keys: fingerprints: '41:f1:b3:2d:89:ff:f0:16:a4:eb:49:92:39:27:95:04' - checkout # check out the code in the project directory - run: name: update-npm command: 'sudo npm install -g npm@latest' - restore_cache: # special step to restore the dependency cache # Read about caching dependencies: https://circleci.com/docs/2.0/caching/ key: dependency-cache-{{ checksum \"package.json\" }} - run: name: install-npm command: npm install - save_cache: # special step to save the dependency cache key: dependency-cache-{{ checksum \"package.json\" }} paths: - ./node_modules - run: # run build name: build command: npm run build - run: # git push name: push-github command: | git config --global user.email \"975018306@qq.com\" git config --global user.name \"hddMachine\" git add -f dist git commit -m 'create dist' git push origin `git subtree split --prefix dist master`:gh-pages --force 参考 https://circleci.com/docs/2.0/configuration-reference/#add_ssh_keys https://circleci.com/docs/2.0/language-javascript/ https://github.com/CircleCI-Public/circleci-demo-javascript-express/blob/master/.circleci/config.yml git-subtree-cant-push GitHub和Bitbucket使用CircleCI","link":"/2019/01/31/CircleCI%E5%AE%9E%E8%B7%B5gh-pages%E9%83%A8%E7%BD%B2/"},{"title":"CircleCI简单概念","text":"又是关于前两个星期零零星星看的文章的总结，主要关于 CircleCI 。首先是CircleCI的介绍，然后下一篇文字介绍下部署一个vue项目到gh-pages的步骤。 概念 导航,概念 ## 步骤（Steps） 步骤一般是可执行的命令组成的。 12345678910#... steps: - checkout # Special step to checkout your source code - run: # Run step to execute commands, see # circleci.com/docs/2.0/configuration-reference/#run name: Running tests command: make test # executable command run in # non-login shell with /bin/bash -eo pipefail option # by default.#... 镜像（Image） 指定确定的docker容器。 12345678910111213141516171819202122232425262728version 2jobs: build1: # job name docker: # Specifies the primary container image, # see circleci.com/docs/2.0/circleci-images/ for # the list of pre-built CircleCI images on dockerhub. - image: buildpack-deps:trusty - image: postgres:9.4.1 # Specifies the database image # for the secondary or service container run in a common # network where ports exposed on the primary container are # available on localhost. environment: # Specifies the POSTGRES_USER authentication # environment variable, see circleci.com/docs/2.0/env-vars/ # for instructions about using environment variables. POSTGRES_USER: root... build2: machine: # Specifies a machine image that uses # an Ubuntu version 14.04 image with Docker 17.06.1-ce # and docker-compose 1.14.0, follow CircleCI Discuss Announcements # for new image releases. image: circleci/classic:201708-01... build3: macos: # Specifies a macOS virtual machine with Xcode version 9.0 xcode: \"9.0\"... 任务（Jobs） 任务是步骤的集合，单个任务必须指定docker，machine和macos。 缓存 可以缓存诸如项目中源代码的依赖的文件或者目录。 12345678910111213141516171819202122232425version: 2jobs: build1: docker: # Each job requires specifying an executor # (either docker, macos, or machine), see # circleci.com/docs/2.0/executor-types/ for a comparison # and more examples. - image: circleci/ruby:2.4-node - image: circleci/postgres:9.4.12-alpine steps: - checkout - save_cache: # Caches dependencies with a cache key # template for an environment variable, # see circleci.com/docs/2.0/caching/ key: v1-repo-{{ .Environment.CIRCLE_SHA1 }} paths: - ~/circleci-demo-workflows build2: docker: - image: circleci/ruby:2.4-node - image: circleci/postgres:9.4.12-alpine steps: - restore_cache: # Restores the cached dependency. key: v1-repo-{{ .Environment.CIRCLE_SHA1 }} 工作流 工作流定义了一系列的任务和他们的运行顺序。它可以使任务并行，穿行和按计划或者手动控制运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647version: 2jobs: build1: docker: - image: circleci/ruby:2.4-node - image: circleci/postgres:9.4.12-alpine steps: - checkout - save_cache: # Caches dependencies with a cache key key: v1-repo-{{ .Environment.CIRCLE_SHA1 }} paths: - ~/circleci-demo-workflows build2: docker: - image: circleci/ruby:2.4-node - image: circleci/postgres:9.4.12-alpine steps: - restore_cache: # Restores the cached dependency. key: v1-repo-{{ .Environment.CIRCLE_SHA1 }} - run: name: Running tests command: make test build3: docker: - image: circleci/ruby:2.4-node - image: circleci/postgres:9.4.12-alpine steps: - restore_cache: # Restores the cached dependency. key: v1-repo-{{ .Environment.CIRCLE_SHA1 }} - run: name: Precompile assets command: bundle exec rake assets:precompile...workflows: version: 2 build_and_test: # name of your workflow jobs: - build1 - build2: requires: - build1 # wait for build1 job to complete successfully before starting # see circleci.com/docs/2.0/workflows/ for more examples. - build3: requires: - build1 # wait for build1 job to complete successfully before starting # run build2 and build3 in parallel to save time. 工作区域和文件 Artifacts， Workspaces，Caches的讨论看 Persisting Data in Workflows: When to Use Caching, Artifacts, and Workspaces 也可以看看 Jobs and Steps来查看更多。 工作流 要通过更快的反馈，更短的重运行时间和更有效的资源使用来提高软件开发的速度，请配置工作流程。这个文档描述了工作流程的特性而且提供以下章节的用例： 概述 工作流配置案例 手动控制持久工作流 有序化一个工作流程 使用上下文来过滤你的工作流程 使用工作区来在任务重分享数据 重运行失败的任务 故障排除 概述 你能做的有： 通过实时状态反馈来运行和解决任务中的问题 将需要定期执行的工作流按计划执行 通过多个并行任务来进行有效的版本测试 快速部署到多个不同的平台 平行任务 在底部添加workflows，通过build_and_test 可看Sample Parallel Workflow config 顺序任务 需要添加require关键字。 1234567891011121314workflows: version: 2 build-test-and-deploy: jobs: - build - test1: requires: - build - test2: requires: - test1 - deploy: requires: - test2 扇出/扇入工作流示例 下面视图扇出一组工作流，然后扇入来运行公共的部署任务： Sample Fan-in/Fan-out Workflow config 1234567891011121314151617181920212223workflows: version: 2 build_accept_deploy: jobs: - build - acceptance_test_1: requires: - build - acceptance_test_2: requires: - build - acceptance_test_3: requires: - build - acceptance_test_4: requires: - build - deploy: requires: - acceptance_test_1 - acceptance_test_2 - acceptance_test_3 - acceptance_test_4 通过手动批准来控制工作流 工作流可以设置为需要手动批准再进行下一个任务。任何有权利访问代码库的人都可以继续工作流。为了做到这一点，在任务列表中添加type: approval。 1234567891011121314151617181920workflows: version: 2 build-test-and-approval-deploy: jobs: - build # your custom job from your config, that builds your code - test1: # your custom job; runs test suite 1 requires: # test1 will not run until the `build` job is completed. - build - test2: # another custom job; runs test suite 2, requires: # test2 is dependent on the succes of job `test1` - test1 - hold: # &lt;&lt;&lt; A job that will require manual approval in the CircleCI web application. type: approval # &lt;&lt;&lt; This key-value pair will set your workflow to a status of \"On Hold\" requires: # We only run the \"hold\" job when test2 has succeeded - test2 # On approval of the `hold` job, any successive job that requires the `hold` job will run. # In this case, a user is manually triggering the deploy job. - deploy: requires: - hold 上例中举例，就是在最后需要手动批准hold才能进行部署任务。 下面也有一些我们在工作流中需要注意的地方： * approval是仅在workflow下job的一个特殊类型。 * hold任务必须确保不再其他任务中重名。 * 这代表着，你的个人定制任务，像build或者test1在上例中不能给type: approval键 * 任务的名字随意。 * 在手动任务之后的任务都需要添加require:来依赖这个手动任务。 * 任务按顺序执行，直到碰到了type: approval。 下面展示一下截图 安排工作流程 手动书写每个分支的任务和流程十分的低效和耗时，所以我们能够在确定不同分支的运行时间。 在夜晚执行的任务 默认工作流的触发依赖于每次git push，为了按照计划执行工作流，我们可以添加triggers键来特殊化工作调度。 下面的例子中，我们将运行一个旨在夜晚12点后运行的工作流。使用POSIX crontab语法指定cron键。crontab man page来查看基本语法。 1234567891011121314151617workflows: version: 2 commit: jobs: - test - deploy nightly: triggers: - schedule: cron: \"0 0 * * *\" filters: branches: only: - master - beta jobs: - coverage 制定有效的计划 一个有效的计划，需要cron键和filter键。cron的键值必须是一个有效的vaild crontab entry键。 使用任务上下文来分享环境变量 下面的例子展示了如何使用上下文来在一个工作流的四个平行任务中分享环境变量。 12345678910111213141516workflows: version: 2 build-test-and-deploy: jobs: - build - test1: requires: - build context: org-global - test2: requires: - test1 context: org-global - deploy: requires: - test2 分支级别的任务执行 下面的例子会展示，如何在三个分支配置任务流。工作流会在忽略在任务底下的分支键，如果想在工作流中添加任务级别的分支，需要移除任务级别的分支，转而描述它。 123456789101112131415161718workflows: version: 2 dev_stage_pre-prod: jobs: - test_dev: filters: # using regex filters requires the entire branch to match branches: only: # only branches matching the below regex filters will run - dev - /user-.*/ - test_stage: filters: branches: only: stage - test_pre-prod: filters: branches: only: /pre-prod(?:-.+)?$/ 执行Git Tag的工作流 circleci并不会主动执行 git tags 分支，除非你定义特定的tags过滤器。如果一个任务直接间接的需要另外一个任务，你必须指定正则表达式来制定任务的tag filter。轻量级和注释的tag都被支持。 下面的例子展示了两种tag分支方式： 1. untagged-build为所有分支运行build任务。 2. tagged-build为所有分支和带v的标签运行build。 1234567891011workflows: version: 2 untagged-build: jobs: - build tagged-build: jobs: - build: filters: tags: only: /^v.*/ 下面展示的三个例子就是workflow的步骤 * build跑所有分支和有config-test名称的tags。 * test跑所有分支和有config-test名称的tags。 * deploy不跑分支只跑有config-test的任务。 12345678910111213141516171819202122workflows: version: 2 build-test-deploy: jobs: - build: filters: # required since `test` has tag filters AND requires `build` tags: only: /^config-test.*/ - test: requires: - build filters: # required since `deploy` has tag filters AND requires `test` tags: only: /^config-test.*/ - deploy: requires: - test filters: tags: only: /^config-test.*/ branches: ignore: /.*/ 需要注意的是，GitHub的分支单词只能承受5MB和少于三个标签。意味着，如果你一次添加多个标签，那么CircleCi也许不会接受他们全部。 使用工作区来在任务中分享数据 每个工作流都有一个相关的工作区，能够将文件转换为下游任务的工作流流程。工作区仅用来添加数据的储存。任务可以在工作区中持久化数据。此配置归档数据并在容器外存储中创建新层。下游文件可以通过文件系统的容器访问工作区。附加工作区会根据工作流程中上游作业的顺序下载并解压缩每个层。 使用工作区来传递当前层及下层需要的特殊数据。工作流程的任务运行于多个分支，也许需要将数据分享到工作区中。工作区也可以用于在测试容器中比较数据。 举个例子，Scala项目一般需要打来的CPU计算来完成build任务。相比之下，Scala测试任务不是CPU密集型的而且可以很好的跨容器并行化。使用一个大的容器来build任务，然后保存编译好的数据到工作区，能够让测试容器中使用到编译好的数据。 第二个例子就是，一个能编译的项目，使用build好的包，然后保存到工作区。build任务扇出到的分支能够并行的使用打包好的文件。 为了将一个任务中的数据持久化，并使它能够在其他的任务中使用。我们需要使用persist_to_workspace键。文件和目录中的带有paths的属性使用persist_to_workspace会被上传到工作区中的临时目录中，相对于root键定义的目录。文件和目录在这时上传之后，就可以在相应的子任务中使用。 配置任务接收存储的数据，需要用到attach_workspace键。下面的例子中的config.yml文件中，定义了下游文件使用了流任务中的两个任务。这里的工作流是顺序的。所以downstream需要等到流文件结束才能开始。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# Note that the following stanza uses CircleCI 2.1 to make use of a Reusable Executor# This allows defining a docker image to reuse across jobs.# visit https://circleci.com/docs/2.0/reusing-config/#authoring-reusable-executors to learn more.version: 2.1executors: my-executor: docker: - image: buildpack-deps:jessie working_directory: /tmpjobs: flow: executor: my-executor steps: - run: mkdir -p workspace - run: echo \"Hello, world!\" &gt; workspace/echo-output # Persist the specified paths (workspace/echo-output) into the workspace for use in downstream job. - persist_to_workspace: # Must be an absolute path, or relative path from working_directory. This is a directory on the container which is # taken to be the root directory of the workspace. root: workspace # Must be relative path from root paths: - echo-output downstream: executor: my-executor steps: - attach_workspace: # Must be absolute path or relative path from working_directory at: /tmp/workspace - run: | if [[ `cat /tmp/workspace/echo-output` == \"Hello, world!\" ]]; then echo \"It worked!\"; else echo \"Nope!\"; exit 1 fiworkflows: version: 2.1 btd: jobs: - flow - downstream: requires: - flow 可通过Persisting Data in Workflows: When to Use Caching, Artifacts, and Workspaces查看更多的关于使用workspaces, caching, and artifacts。 重运行失败的任务 当你使用工作流的时候，你能增加你快速响应失败任务的能力。为了重运行工作流中失败的任务。你可以在Workflows中选择相应的工作流，选择Rerun按钮。 return 故障排除 这个章节讨论一些工作流中常见的问题。 工作流没有开始 如果你创建和修改了工作流的配置，如果你没看见新的任务，很有可能是你的配置文件config.yml出现了问题。 通常情况下，如果你没看见你的工作流正常触发，配置错误阻止了工作流的启动。作为结论，工作流没有启动任何一个任务。 在设置工作流程时，您当前必须检查CircleCI应用程序的工作流程页面（而不是作业页面）以查看配置错误。 工作流等待GitHub的状态。 配置circleci CircleCI 镜像 https://hub.docker.com/r/circleci/ https://github.com/circleci/circleci-images https://github.com/circleci-public/circleci-dockerfiles 最佳实践 最好确定好版本号，不适用last版本。Debian系统需要在尾部添加上-jessie和-stretch。 使用镜像的便签来标注语言和操作系统 circleci/golang:1.8.6-jessie 注意: 如果没有固定标签，Docker将会使用latest标签。latest引用的是最有一个稳定版本的镜像。这样的镜像时十分不稳定的，所以最佳时间推荐使用稳定的镜像。 使用Docker镜像ID将图像固定到固定版本 每一个Docker都有唯一的ID。 1sha256:df1808e61a9c32d0ec110960fed213ab2339451ca88941e9be01a03adc98396e 如何找到最近的镜像的ID 1. 在CircleCI应用程序中，转到最后使用该镜像的构建中。 2. 在Test Summary栏中，点击Spin up environment。 3. 在日志输出中，找到镜像的摘要。 4. 将图像ID添加到图像名称，如下所示 1circleci/ruby@sha256:df1808e61a9c32d0ec110960fed213ab2339451ca88941e9be01a03adc98396e 镜像类型 CircleCi为了便利，提供了两种镜像。语言镜像和服务器镜像。所有的镜像都需要添加circleci用户来作为系统用户。 镜像语言 Android Clojure Elixir Go (Golang) JRuby Node.js OpenJDK (Java) PHP Python Ruby Rust 语言镜像变体 Circleci维持了一些语言变量的变体镜像。要使用这些变种将以下后缀之一添加到图像标记的末尾。 -node 包括用于多语言应用程序的Node.js. -browsers 包括Chrome，Firefox，Java 8和Geckodriver. -browsers-legacy 包括Chrome，Firefox，Java 8和PhantomJS. -node-browsers 结合了-node和-browsers变体. -node-browsers-legacy 结合了-node和-browsers-legacy变体. 服务器镜像 服务镜像是数据库等服务的便利镜像。这些景象应该在语言镜像之后列出，使之成为二级镜像。 buildpack-deps DynamoDB MariaDB MongoDB MySQL PostgreSQL Redis 服务镜像变体 使用RAM加速需要添加-ram后缀。举例，circleci/postgres:9.5-postgis =&gt; circleci/postgres:9.5-postgis-ram。 预安装工具 除了安卓镜像，其他都包括下列预安装工具，通过apt-get安装。 bzip2 ca-certificates curl git gnupg gzip locales mercurial net-tools netcat openssh-client parallel sudo tar unzip wget xvfb zip","link":"/2019/01/25/CircleCI%E7%AE%80%E5%8D%95%E6%A6%82%E5%BF%B5/"},{"title":"HTTP识别、认证与安全(https)","text":"阅读的HTTP权威指南 # 客户端识别与cookie机制 Web服务器需要和成千上百个服务器通信。服务器通常需要记录下它们与谁交换，而不会认为所有请求都来自匿名的客户端。能使用的方法主要有： * HTTP首部 * 客户端IP地址 * 用户登录 * 胖URL * cookie HTTP首部 常见http首部: 首部名称 首部类型 描述 From 请求 用户的Email地址 User-Agent 请求 用户的浏览器软件 Referer 请求 用户是从这个页面跳转过来的 Authorization 请求 用户名和密码 Client-IP 拓展(请求) 客户端的IP地址 X-Forwarded-For 拓展(请求) 客户端的IP地址 Cookie 拓展(请求) 服务器产生的ID标签 客户端IP地址 早期的Web先锋曾尝试将客户端IP作为一种标示形式使用，如果每一个用户一个IP地址，那这个用法说不定还行，不过。。。 用户登录 Web服务器无需被动的根据用户的IP地址来猜测他的用户，它可以要求用户通过用户名和密码进行认证(登录)来显式地询问用户是谁。下一节基本认证会再讲解，关于Authorization中包涵用户的登录信息。服务器不知道用户的时候(认证没通过)一般会返回401错误码。 胖URL 有些Web站点会为每个用户生成特定版本的URL来追踪用户的身份。这个胖URL存在很多问题。 * 丑陋的URL * 无法共享URL * 破坏缓存 * 额外的服务器负荷 * 逃逸口（跳转URL） * 在会话间是非持久的 cookie cookie是当前识别用户，实现持久会话的最好方式。前面各种技术中存在的问题对他并没有什么影响。 有两种cookie类型，分别是：会话cookie和持久cookie。会话cookie是一种临时cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话cookie就删除了。持久cookie的生存时间更长一些，它们储存在硬盘上，计算器重启时，它们仍然存在。通常会用持久cookie维护某个用户会周期性访问的站点的配置文件或登录名。 这里我们需要知道，cookie常见也就是键值对，如：Cookie: name=\"Hdd\" 基本认证机制 认证就是要给出一些身份证明。证明你是你。基本的：HTTP的质询/响应机制。 HTTP的质询/响应认证框架 安全域 Web服务器会将受保护的文档组织成一个安全域。每个安全域可以有不同的授权用户集。 如下图： 下面是一个假想的基本认证质询： 12HTTP/1.0 401 UnauthorizedWWW-Authenticate: Basic realm = &quot;Corporate Financials&quot; Base-64 用户名/密码编码 密码和账户名用Base-64编码能无需担心字符集，还有能防止管理员无意间看到用户名和密码。 基本认证的安全缺陷 基本认证简单便捷，但并不安全。只能用它来防止非恶意用户无意间进行的访问，或将其与SSL这样的加密技术配合使用。 缺陷如下： 1. 基本认证会通过网络发送用户名和密码。这几乎与“明文”传送，容易被拦截破解。 2. 即使密码没有被破解，但第三方用户仍可以将修改过的捕获的用户名和秘密不断传送给原始服务器来访问。 3. 即使基本认证用于一些不太重要的应用程序，也要防止有心人用它来“撞库”。 4. 基本认证没有提供任何针对代理和作为中间人的中间节点的防护措施，它们没有修改认证首部，却修改了报文的其他部分，这样就很严重的改变的事物的本质，所以下一节会介绍摘要认证。 5. 假冒服务器很容易骗过基本认证，从而伪造钓鱼网站之类的。 摘要认证 摘要认证的改进 摘要认证是另一种HTTP认证协议，它试图修复基本认证的严重缺陷。如下改进： * 永远不会以明文方式在网络发送密码。 发送的都是密码的摘要，而只有服务端和客户端是知道密码的，那密码第三方就不会知道了。 可以防止恶意用户捕获并重放认证的握手过程。 服务器会生成一个随机数发送给客户端，在进行摘要计算，常见算法为MD5。这时会进行随机数和密码进行摘要处理，随机数和时间戳有关，这样第三方无法得知原始密码，也就无法对新的摘要进行计算。质询握手过程。 可以有选择的防止对报文内容的篡改 我们的内容也经过了摘要计算，所及Authentication-Info中qop(保护质量)的信息就也有内容摘要。 防范其他几种常见的攻击方式 预授权 在普通认证方式中，事务结束之前，每个请求都有一次请求/质询的循环，而预授权中，客户端知道了随机数就可以取消这一过程，减少报文数量。如图： 安全性考虑 要知道，摘要认证对于密码的保护确实厉害了很多，不过对于窃听报文内容等还是保护不够，真正的安全的事物只有通过SSL才能实现。 安全HTTP HTTPS前瞻 功能： * 服务器认证（客户端知道他们是在于真正的服务器而不是伪造的服务器通话） * 客户端认证（服务器知道他们在与真正的客户端而不是伪造的客户端通话） * 完整性（保证数据不被修改） * 加密（通话是私密的，不用担心被窃听） * 效率（足够快） * 普适性（基本上所有的服务器端和客户端都能支持） * 管理的可扩展性（任何地方任何人都可以进行安全通信） * 适应性（能够支持当前最知名的安全方法） * 社会可行性（满足社会的政治文化需求） 关于HTTPS的传输： 大部分困难的编码及解码工作都是在SSL库中完成的，所以Web客户端和服务器在使用安全HTTP时无需过多的修改其协议处理逻辑。在大多数情况下，只需要用SSL的输入输出来取代TCP的调用，再增加其他几个调用来配置和管理安全信息就行。 数字加密 密码 对文本加密，使偷窥者无法识别的算法，明文经过密码编码变成密文，再解码为明文 密钥 改变密码行为的数字化参数。 对称密钥加密系统 在对称密钥加密系统，发送端和接收端要共享相同的密钥才能进行通信。 流行的对称密钥加密算法有：DES、Triple-DES、RC2、和RC4 密钥长度和枚举攻击 对于一台服务器，如果有成千上万的客户端进行加密通话，就需要成千上万的秘钥。 为了解决这个问题，可以采用公开密钥加密技术。 不对称密钥加密系统 编/解码使用不同密钥的算法。 公开密钥加密技术 公开密钥加密技术没有为每台主机使用单独的加密/解密密钥，而是使用了两个非对称密钥：一个用来对主机报文编码，另一个用来对主机报文编码。编码密钥是大家都知道的，而主机密钥只有主机知道，也就是只有服务器才知道。 即使你有了下列条件，也无法破解： 公开密钥(市共有的，所有人都可以获得) 一小片拦截下的报文(可通过对网络的嗅探获取) 一条报文及与之相关的密文(对任意一段文本加密即可) 混合加密系统和会话密钥 RSA加密满足了公开加密的技术，但计算的速度可能会很慢，所以比较常见的两个节点的通信采用了混合使用对称和非对称加密。 两个节点通过便捷的公开密钥加密结束建立起安全的通信，然后再用那条安全的通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密。 数字签名 数字签名就是加了密的校验和。 数字签名在数字证书发布的用处就比较大了。 数字证书 发布了的数字证书是需要相关机构认证的。 HTTPS 如果 URL是 HTTP，客户端就会打开一条到服务器端口 80 （默认的HTTP端口）的连接，发送 HTTP 命令。 如果 URL是 HTTPS，客户端就会打开一条到服务器端口443（默认的HTTPS端口）的连接，然后与服务器握手，以二进制的格式与服务器交换一些 SSL 安全参数，握手完成之后 SSL 的初始化就完成了，客户端发送加密的 HTTP 命令。 如果 HTTPS 使用和HTTP 相同的 80端口，那么当加密的 HTTP 命令到达之后，普通的服务器会认为是普通HTTP 命令无法辨认导致错误关闭连接。 但是如果服务器的HTTP层包含了安全HTTP的解析，那么也可以重用80端口而不会引起问题。 SSL握手 内容： * 交换协议版本号 * 选择一个两端都了解的密码 * 对两端的身份进行认证 * 生成临时的会话密钥，用于加密信道 简化版SSL握手：","link":"/2017/12/10/HTTP%E8%AF%86%E5%88%AB%E3%80%81%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%AE%89%E5%85%A8-https/"},{"title":"Levenshtein distance 编辑距离算法","text":"这几天再看virtrual-dom，关于两个列表的对比，讲到了Levenshtein distance距离，周末抽空做一下总结。 # Levenshtein Distance 介绍 在信息理论和计算机科学中，Levenshtein距离是用于测量两个序列之间的差异量（即编辑距离）的度量。两个字符串之间的Levenshtein距离定义为将一个字符串转换为另一个字符串所需的最小编辑数，允许的编辑操作是单个字符的插入，删除或替换。 例子 'kitten'和'sitten'之间的 Levenshtein 距离是3，因为一下三个编辑将一个更改为另一个，并且没有办法用少于三个编辑来执行操作。 k itten sitten =&gt; 用's'代替'k' sitt e n sitt i =&gt; 用'i'代替'e' sittin sittin g 在结尾插入'g' Levenshtein Distance (编辑距离) 算法详解 为了得到编辑距离，我们用 beauty 和 batyu 为例： 图示如 ① 单元位置是两个单词的第一个字符[b]比较得到的值，其的值有它的上方的值(1)、它左方的值(1)和它左上角的值(0)来决定。当单元格所在的行和列所对应的字符相等时，单元格的值为左上方的值。 否则，单元格左上角的值与其上方和左方的值进行比较，它们之间的最小值+1即是单元格的值。 图中 ① 的值由于单元格行和列相等，所以取左上角值0。 图中 ② 的值由于单元格行列不相等，(1, 2, 0)取最小为0， 结果+1， 所以 ② 值为1。 图示 ③ 的值由于单元格行列不相等，(1, 0, 2)取最小0， 结果+1， 所以 ③ 值为1。 算法证明 这个算法计算的是将s[1…i]转换为t[1…j]（例如将beauty转换为batyu）所需最少的操作数（也就是所谓的编辑距离），这个操作数被保存在d[i,j]（d代表的就是上图所示的二维数组）中。 在第一行与第一列肯定是正确的，这也很好理解，例如我们将beauty转换为空字符串，我们需要进行的操作数为beauty的长度（所进行的操作为将beauty所有的字符丢弃）。 我们对字符的可能操作有三种： 将s[1…n]转换为t[1…m]当然需要将所有的s转换为所有的t，所以，d[n,m]（表格的右下角）就是我们所需的结果。 如果我们可以使用k个操作数把s[1…i]转换为t[1…j-1]，我们只需要把t[j]加在最后面就能将s[1…i]转换为t[1…j]，操作数为k+1 如果我们可以使用k个操作数把s[1…i-1]转换为t[1…j]，我们只需要把s[i]从最后删除就可以完成转换，操作数为k+1 如果我们可以使用k个操作数把s[1…i-1]转换为t[1…j-1]，我们只需要在需要的情况下（s[i] != t[j]）把s[i]替换为t[j]，所需的操作数为k+cost（cost代表是否需要转换，如果s[i]==t[j]，则cost为0，否则为1）。 可能的改进 现在的算法复杂度为O(m*n)，可以将其改进为O(m)。因为这个算法只需要上一行和当前行被存储下来就可以了。 如果需要重现转换步骤，我们可以把每一步的位置和所进行的操作保存下来，进行重现。 如果我们只需要比较转换步骤是否小于一个特定常数k，那么只计算高宽宽为2k+1的矩形就可以了，这样的话，算法复杂度可简化为O(kl)，l代表参加对比的最短string的长度。 我们可以对三种操作（添加，删除，替换）给予不同的权值（当前算法均假设为1，我们可以设添加为1，删除为0，替换为2之类的），来细化我们的对比。 如果我们将第一行的所有cell初始化为0，则此算法可以用作模糊字符查询。我们可以得到最匹配此字符串的字符串的最后一个字符的位置（index number），如果我们需要此字符串的起始位置，我们则需要存储各个操作的步骤，然后通过算法计算出字符串的起始位置。 这个算法不支持并行计算，在处理超大字符串的时候会无法利用到并行计算的好处。但我们也可以并行的计算cost values（两个相同位置的字符是否相等），然后通过此算法来进行整体计算。 如果只检查对角线而不是检查整行，并且使用延迟验证（lazy evaluation），此算法的时间复杂度可优化为O(m(1+d))（d代表结果）。这在两个字符串非常相似的情况下可以使对比速度速度大为增加。 字符串比较代码 这一部分的代码，参考了 https://rosettacode.org/wiki/Levenshtein_distance#ES5 123456789101112131415161718192021222324252627282930313233343536373839const ld = (a, b) =&gt; { let t = [], u, i, j, m = a.length, n = b.length; if (!m) return b; if (!n) return a; for (j = 0; j &lt;= m; j++) { t[j] = j; } console.log(t); for (i = 1; i &lt;= n; i++) { for (u = [i], j = 1; j &lt;= m; j++) { u[j] = a[j - 1] === b[i - 1] ? t[j - 1] : Math.min(t[j - 1], t[j], u[j - 1]) + 1 // Levenshtein Distance 算法核心比较部分。 } t = u; console.log(t); } return u[m];}[['beauty', 'batyu', 3],].forEach(function (v) { var a = v[0], b = v[1], t = v[2], d = ld(a, b); if (d !== t) { console.log('levenstein(\"' + a + '\",\"' + b + '\") was ' + d + ' should be ' + t); }});// 打印出来[ 0, 1, 2, 3, 4, 5, 6 ][ 1, 0, 1, 2, 3, 4, 5 ][ 2, 1, 1, 1, 2, 3, 4 ][ 3, 2, 2, 2, 2, 2, 3 ][ 4, 3, 3, 3, 3, 3, 2 ][ 5, 4, 4, 4, 3, 4, 3 ] 还原字符串 上面总结了传统的计算字符串之间的差距，那么当我们怎么能在计算的过程中，记录需要转换的步骤，并且进行还原呢。 这里我们需要对比较的每一位的步骤有一个了解。 为了得到编辑距离，我们用 beauty 和 batyu 为例： 从上面一节的图中可以看到，'beauty' 转换为 '' ，对一个的第一行的 [1，2，3，4，5，6]，每一个步骤都相对与上一个元素新建一个元素，同理 '' 转换为 'batyu'，每一个值都是相对一上一个元素的删除步骤。 那么对角线也显而易见就是先相对于替换操作。那么我们现在需要做的就是，记录下相对应的索引和元素以及需要进行的操作，并将其保存为一个对象，每次新增的对象用数组来保存就可以了。 1234567891011121314const actionType = { TYPE_REPLACE: 'TYPE_REPLACE', TYPE_NEW: 'TYPE_NEW', TYPE_DELETE: 'TYPE_DELETE'}// 生成对象的方法const patchObj = (index, type, item = '') =&gt; { return { index, type, item }} 下面是compare方法： 123456789101112131415161718192021/** * * @param { array } r 替换操作 replace * @param { array } n 新建操作 new * @param { array } d 删除操作 delete * @param { number } i 需要转换元素的 index * @param { number } j 需要删除元素的 index * @param { string } b 比较字符串 */const compare = (r, n, d, i, j, b) =&gt; { const min = Math.min(r.length, n.length, d.length); switch (min) { case r.length: return [...r, patchObj(i, actionType.TYPE_REPLACE, b[i])]; case n.length: return [...n, patchObj(i, actionType.TYPE_NEW, b[i])]; case d.length: return [...d, patchObj(j, actionType.TYPE_DELETE)]; }} 上面需要注意的是，我们一组保存了多个数组对象，不要对原数组进行操作，每一次操作我们都需要拷贝一个新的数组对象。 具体的的diff代码参考diff代码 得到了，patches对象，剩下的我们就需要patch了 123456789101112131415161718192021222324const patch = (a, diffs) =&gt; { let aList = a.split(''); let delCount = 0; // 删除之后，后续的index计算需要加上之前删除的数量 diffs.forEach((diff) =&gt; { switch (diff.type) { case actionType.TYPE_DELETE: aList.splice(diff.index - delCount, 1); delCount++ break; case actionType.TYPE_NEW: aList.splice(diff.index, 0, diff.item); break; case actionType.TYPE_REPLACE: aList.splice(diff.index, 1, diff.item); break; default: break; } }) // console.log(aList.join('')) return aList.join('')} 具体代码参考代码地址 参考资料 http://www.cnblogs.com/zhoug2020/p/4224866.html https://rosettacode.org/wiki/Levenshtein_distance#ES5","link":"/2018/12/08/Levenshtein-distance-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/"},{"title":"JS中排序和搜索算法","text":"看《学习JavaScript数据结构与算法》，总结了下常用的排序，如冒泡排序、选择排序、插入排序、归并排序和快速排序，以及顺序搜索和二分搜索算法。 # 排序算法 排序算法之前，我们需要创建一个数组表示待排序和搜索的数据结构。 123456789function ArrayList(){ var array = []; //{1} this.insert = function(item){ //{2} array.push(item); }; this.toString= function(){ //{3} return array.join(); };} 冒泡排序 冒泡排序最简单，不过它的时间复杂度也是最大的。 冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。 12345678910111213141516171819this.bubbleSort = function(){ var length = array.length; //{1} for (var i=0; i&lt;length; i++){ //{2} for (var j=0; j&lt;length-1; j++ ){ //{3} if (array[j] &gt; array[j+1]){ //{4} swap(array, j, j+1); //{5} } } }};var swap = function(array, index1, index2){ var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux;}; // 一个私有函数，只能用在ArrayList类的内部代码中// 可以用ES6的数组拓展// [array[index1], array[index2]] = [array[index2], array[index1]]; 首先，声明一个名为length的变量，用来存储数组的长度（行{1}）。这一步可选，它能帮助我们在行{2}和行{3}时直接使用数组的长度。接着，外循环（行{2}）会从数组的第一位迭代至最后一位，它控制了在数组中经过多少轮排序（应该是数组中每项都经过一轮，轮数和数组长度一致）。然后，内循环将从第一位迭代至倒数第二位，内循环实际上进行当前项和下一项的比较（行{4}）。如果这两项顺序不对（当前项比下一项大），则交换它们（行{5}），意思是位置为j+1的值将会被换置到位置j处，反之亦然。 改进冒泡算法 如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较。 12345678910this.modifiedBubbleSort = function(){ var length = array.length; for (var i=0; i&lt;length; i++){ for (var j=0; j&lt;length-1-i; j++ ){ if (array[j] &gt; array[j+1]){ swap(j, j+1); } } }}; 最后，这个排序的事件复杂度是O(n²)。 选择排序 选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。 123456789101112131415this.selectionSort = function(){ var length = array.length, //{1} indexMin; for (var i=0; i&lt;length-1; i++){ //{2} indexMin = i; //{3} for (var j=i; j&lt;length; j++){ //{4} if(array[indexMin]&gt;array[j]){ //{5} indexMin = j; //{6} } } if (i !== indexMin){ //{7} swap(i, indexMin); } }}; 首先声明一些将在算法内使用的变量（行{1}）。接着，外循环（行{2}）迭代数组，并控制迭代轮次（数组的第n个值——下一个最小值）。我们假设本迭代轮次的第一个值为数组最小值（行{3}）。然后，从当前i的值开始至数组结束（行{4}），我们比较是否位置j的值比当前最小值小（行{5}）；如果是，则改变最小值至新最小值（行{6}）。当内循环结束（行{4}），将得出数组第n小的值。最后，如果该最小值和原最小值不同（行{7}），则交换其值。 选择排序同样也是一个复杂度为O(n²)的算法。和冒泡排序一样，它包含有嵌套的两个循环，这导致了二次方的复杂度。 插入排序 插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。 12345678910111213this.insertionSort = function(){ var length = array.length, //{1} j, temp; for (var i=1; i&lt;length; i++){ //{2} j = i; //{3} temp = array[i]; //{4} while (j&gt;0 &amp;&amp; array[j-1] &gt; temp){ //{5} array[j] = array[j-1]; //{6} j--; } array[j] = temp; //{7} }}; 算法的第一行用来声明代码中使用的变量（行{1}）。接着，迭代数组来给第i项找到正确的位置（行{2}）。注意，算法是从第二个位置（索引1）而不是0位置开始的（我们认为第一项已排序了）。然后，用i的值来初始化一个辅助变量（行{3}）并将其值亦存储于一临时变量中（行{4}），便于之后将其插入到正确的位置上。下一步是要找到正确的位置来插入项目。只要变量j比0大（因为数组的第一个索引是0——没有负值的索引）并且数组中前面的值比待比较的值大（行{5}），我们就把这个值移到当前位置上（行{6}）并减小j。最终，该项目能插入到正确的位置上。 排序小型数组时，此算法比选择排序和冒泡排序性能要好。 归并排序 归并排序是第一个可以被实际使用的排序算法。，其复杂度为O(nlogⁿ)。 JavaScript的Array类定义了一个sort函数（Array.prototype.sort）用以排序JavaScript数组（我们不必自己实现这个算法）。ECMAScript没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox使用归并排序作为Array.prototype.sort的实现，而Chrome使用了一个快速排序（下面我们会学习的）的变体。 归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。 1234567891011121314this.mergeSort = function(){ array = mergeSortRec(array);};var mergeSortRec = function(array){ var length = array.length; if(length === 1) { //{1} return array; //{2} } var mid = Math.floor(length / 2), //{3} left = array.slice(0, mid), //{4} right = array.slice(mid, length); //{5} return merge(mergeSortRec(left), mergeSortRec(right)); //{6}}; 归并排序将一个大数组转化为多个小数组直到只有一个项。由于算法是递归的，我们需要一个停止条件，在这里此条件是判断数组的长度是否为1（行{1}）。如果是，则直接返回这个长度为1的数组（行{2}），因为它已排序了。 如果数组长度比1大，那么我们得将其分成小数组。为此，首先得找到数组的中间位（行{3}），找到后我们将数组分成两个小数组，分别叫作left（行{4}）和right（行{5}）。left数组由索引0至中间索引的元素组成，而right数组由中间索引至原始数组最后一个位置的元素组成。 下面的步骤是调用merge函数（行{6}），它负责合并和排序小数组来产生大数组，直到回到原始数组并已排序完成。为了不断将原始数组分成小数组，我们得再次对left数组和right数组递归调用mergeSortRec，并同时作为参数传递给merge函数。 12345678910111213141516171819var merge = function(left, right){ var result = [], // {7} il = 0, ir = 0; while(il &lt; left.length &amp;&amp; ir &lt; right.length) { // {8} if(left[il] &lt; right[ir]) { result.push(left[il++]); // {9} } else{ result.push(right[ir++]); // {10} } } while (il &lt; left.length){ // {11} result.push(left[il++]); } while (ir &lt; right.length){ // {12} result.push(right[ir++]); } return result; // {13}}; merge函数接受两个数组作为参数，并将它们归并至一个大数组。排序发生在归并过程中。首先，需要声明归并过程要创建的新数组以及用来迭代两个数组（left和right数组）所需的两个变量（行{7}）。迭代两个数组的过程中（行{8}），我们比较来自left数组的项是否比来自right数组的项小。如果是，将该项从left数组添加至归并结果数组，并递增迭代数组的控制变量（行{9}）；否则，从right数组添加项并递增相应的迭代数组的控制变量（行{10}）。 接下来，将left数组或者right数组所有剩余的项添加到归并数组中（行{11}和行{12}）。最后，将归并数组作为结果返回（行{13}）。 如果执行mergeSort函数，下图是具体的执行过程： 快速排序 快速排序也许是最常用的排序算法了。它的复杂度为O(nlogⁿ)，且它的性能通常比其他的复杂度为O(nlogⁿ)的排序算法要好。和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）。 快速排序比到目前为止你学过的其他排序算法要复杂一些。让我们一步步地来学习。 首先，从数组中选择中间一项作为主元。 创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分操作。 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。 123this.quickSort = function(){ quick(array, 0, array.length - 1);}; 就像归并算法那样，开始我们声明一个主方法来调用递归函数，传递待排序数组，以及索引 0及其最末的位置（因为我们要排整个数组，而不是一个子数组）作为参数。 123456789101112var quick = function(array, left, right){ var index; //{1} if (array.length &gt; 1) { //{2} index = partition(array, left, right); //{3} if (left &lt; index - 1) { //{4} quick(array, left, index - 1); //{5} } if (index &lt; right) { //{6} quick(array, index, right); //{7} } }}; 首先声明index（行{1}），该变量能帮助我们将子数组分离为较小值数组和较大值数组，这样，我们就能再次递归的调用quick函数了。partition函数返回值将赋值给index（行{3}）。 如果数组的长度比1大（因为只有一个元素的数组必然是已排序了的（行{2}），我们将对给定子数组执行partition操作（第一次调用是针对整个数组）以得到index（行{3}）。如果子数组存在较小值的元素（行{4}），则对该数组重复这个过程（行{5}）。同理，对存在较大值得子数组也是如此，如果存在子数组存在较大值，我们也将重复快速排序过程（行{7}）。 1. 划分过程 第一件要做的事情是选择主元（pivot），有好几种方式。最简单的一种是选择数组的第一项（最左项）。然而，研究表明对于几乎已排序的数组，这不是一个好的选择，它将导致该算法的最差表现。另外一种方式是随机选择一个数组项或是选择中间项。 12345678910111213141516171819var partition = function(array, left, right) { var pivot = array[Math.floor((right + left) / 2)], //{8} i = left, //{9} j = right; //{10} while (i &lt;= j) { //{11} while (array[i] &lt; pivot) { //{12} i++; } while (array[j] &gt; pivot) { //{13} j--; } if (i &lt;= j) { //{14} swap(array, i, j); //{15} i++; j--; } } return i; //{16}}; 在本实现中，我们选择中间项作为主元（行{8}）。我们初始化两个指针：left（低——行{9}），初始化为数组第一个元素；right（高——行{10}），初始化为数组最后一个元素。 只要left和right指针没有相互交错（行{11}），就执行划分操作。首先，移动left指针直到找到一个元素比主元大（行{12}）。对right指针，我们做同样的事情，移动right指针直到我们找到一个元素比主元小。 当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大（行{14}），意思是左项比右项大（值比较）。我们交换它们，然后移动两个指针，并重复此过程（从行{11}再次开始）。 在划分操作结束后，返回左指针的索引，用来在行{3}处创建子数组。 2. 快速排序实战 搜索算法 顺序搜索 顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法。 12345678this.sequentialSearch = function(item){ for (var i=0; i&lt;array.length; i++){ if (item === array[i]) return i; } } return -1;}; 二分搜索 二分搜索算法的原理和猜数字游戏类似，就是那个有人说“我正想着一个1到100的数字”的游戏。我们每回应一个数字，那个人就会说这个数字是高了、低了还是对了。 这个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。 1. 选择数组的中间值。 2. 如果选中值是待搜索值，那么算法执行完毕（值找到了）。 3. 如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。 4. 如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找。 12345678910111213141516171819this.binarySearch = function(item){ this.quickSort(); var low = 0, high = array.length - 1, mid, element; while (low &lt;= high){ mid = Math.floor((low + high) / 2); element = array[mid]; if (element &lt; item) { low = mid + 1; } else if (element &gt; item) { high = mid - 1; } else { return mid; } } return -1;}; 开始前需要先将数组排序，我们可以选择快速排序等。","link":"/2018/02/23/JS%E4%B8%AD%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"title":"JavaScript异步处理(一)：Parallel VS Async && Callbacks","text":"总结 JavaScript 中的五种异步方式及比较。 Parallel VS Async Callbacks Thunks Promises Generators/Coroutines Event Reactive （Obervables） CSP (channel-oriented cocurrency) Parallel VS Async 并行编程（parallel programming）的编程语言，大致方向都在 CPU 的多核调用、线程的创建和拆除。JavaScript 则是异步调用的方式。 异步调用（asynchronous） 主要就是避免程序调用中的阻塞发生。举个例子，当你需要对数据库运行查询或从本地磁盘中提取文件，这时通常需要使用异步调用。这个调用将从现存的线程中（例如I/O线程）分离，并在可能的情况下执行它。异步调用可以在同一台电脑上调用，也可以在其他地方的其他电脑上调用（例如访问网上其他服务器的API），它可以有效地防止用户界面不被 “卡住” 或对操作无响应。 在并行编程中，你仍然可以分解工作或者任务，但关键区别在你可以问每个任务块（chunk）启动新的线程，并且每个线程都可以到达公共变量池。在大多数的情况下，并行编程仅在本地计算器上进行，并且永远不会发送到其他计算机。同样，这是因为对并行任务的每次调用都会创建一个和全新的线程来执行。并行编程也可以保持用户界面快速，并且在运行挑战性的任务时不会感到 “卡住” 。 也许你现在觉得并行和异步看起来似乎像在做同一件事，事实上，他们完全是两种机制。使用异步调用意味着你将无法控制线程或者线程池（线程的集合），并且依赖系统来处理请求。使用并行编程，你可以很好的控制任务块，甚至可以创建许多线程，来充分利用处理器中可用核心来处理。然而，每次调用创建和拆除线程都是非常系统密集型的，因此编程的时候都需要十分小心。 最后总结一下，两种模式都是防止阻塞。简单来说，请记住，异步调用使用的是系统已经在使用的线程，并行编程需要开发人员将大的任务打散，注册和拆卸所需线程。 在browser环境下，可以通过使用 Web Workers 来创建新的线程，这样可以不占用 主UI线程。 Callbacks 说到回调编写异步程序 ，一定会谈到的就是 callback hell。 什么是 \"回调地狱\"？ 它就是使用回调来执行的异步 JavaScript ，是很难凭直觉取得正确的执行顺序和结果的。大多数的代码就像这样： 可以看到结尾处的 }) 和类似金字塔的结构。这被称作 回调地狱 。 造成回调地狱的原因是大家试图按照执行的顺序从头到尾的书写 JavaScript 。 JavScript 不像 C ，Ruby，或Python一样需要一行一行的执行代码。 什么是回调？ 回调只是对使用 JavaScript 函数的便利的说法。JavaScript 并没有特殊的称作 “callback” 的东西。函数使用回调在一定时间后产出结果，而不是直接获取函数执行的返回值。异步表达的是，“需要一些时间” 或者是 “在将来发生”。通常使用回调的例子诸如，I/O 操作，下载东西，读文件，访问数据库等、 当你使用一个和正常的函数： 123var result = multiplyTwoNumbers(5, 10)console.log(result)// 50 gets printed out 异步调用 12var photo = downloadPhoto('http://coolcats.com/cat.gif')// photo is \"undefined\"! 上面的例子中，可能这个 gif 图需要很久才能下载下来，你不想你的程序暂停（阻塞）等待图片的下载完成。而是在函数中储存下载完成后应该运行的代码，这就是回调。 12345678downloadPhoto('http://coolcats.com/cat.gif', handlePhoto)function handlePhoto (error, photo) { if (error) console.error('Download error!', error) else console.log('Download finished', photo)}console.log('Download started') 大家试图理解回调最困难的部分就是理解程序执行的顺序。上面下载图片中的例子中，程序执行了三件事，分别是首先打印了 handlePhoto 函数， 然后调用 downloadPhoto 函数，并将 handlePhoto 作为其回调传递，最后打印出 “Download started” 。 我们需要留意到，handlePhoto 并没有被调用，它只是作为回调被创建和传递到 downloadPhoto。它在 downloadPhoto 任务完成之前都不会被调用。它所调用取决的时间依赖于网络的连接速度。 这个例子有两个核心的概念： handlePhoto 回调只是一种在以后存储之后会调用的函数。 事件的执行顺序不是从上到下来理解的，而是根据时间完成的时机来跳转。 如何修复回调地狱 回调地狱来源于编码经验不足所书写的代码，幸运的是书写好的代码并不是很难。你需要遵守下列三点： 避免你的代码过度嵌套 这里有一些混乱的在浏览器中运行的请求代码： 12345678910111213var form = document.querySelector('form')form.onsubmit = function (submitEvent) { var name = document.querySelector('input').value request({ uri: \"http://example.com/upload\", body: name, method: \"POST\" }, function (err, response, body) { var statusMessage = document.querySelector('.status') if (err) return statusMessage.value = err statusMessage.value = body })} 现在让我们给这两个匿名函数命名， 12345678910111213var form = document.querySelector('form')form.onsubmit = function formSubmit (submitEvent) { var name = document.querySelector('input').value request({ uri: \"http://example.com/upload\", body: name, method: \"POST\" }, function postResponse (err, response, body) { var statusMessage = document.querySelector('.status') if (err) return statusMessage.value = err statusMessage.value = body })} 可以看到给具名函数有直观的一些好处： 由于描述性的函数名称，使代码更容易阅读。 当异常发生时，您将获得引用实际函数名称而不是“匿名”的堆栈跟踪。 允许你移动函数并按名称引用它们。 由于函数声明，我们甚至能随意改变函数的位置，放到文件的底部。 12345678910111213141516document.querySelector('form').onsubmit = formSubmitfunction formSubmit (submitEvent) { var name = document.querySelector('input').value request({ uri: \"http://example.com/upload\", body: name, method: \"POST\" }, postResponse)}function postResponse (err, response, body) { var statusMessage = document.querySelector('.status') if (err) return statusMessage.value = err statusMessage.value = body} 模块化 这是最重要的一部分，任何人都能够创建模块（即 库 ）。引用 Isaac Schlueter (node.js项目): 编写小模块来，每个模块都只做一件事，并将它们组装成其他模块来做更大的事。如果你这么做，你永远都不会进入到回调地狱。 我们接着看上面那个例子，然后将其分成多个文件转换成模块。下面将展示适用于浏览器或服务器的模块模式： 123456789101112131415161718/** 新建一个文件 formupload.js */function formSubmit (submitEvent) { var name = document.querySelector('input').value request({ uri: \"http://example.com/upload\", body: name, method: \"POST\" }, postResponse)}function postResponse (err, response, body) { var statusMessage = document.querySelector('.status') if (err) return statusMessage.value = err statusMessage.value = body}module.exports.submit = formSubmit 现在我们能在别处引用代码了： 123var formUpload = require('formuploader')document.querySelector('form').onsubmit = formUploader.submit 我们的主程序调用仅仅只需要两行代码了，而且还有以下的一些好处： 新来的开发者更容易理解，不会因为需要去读冗长的回调代码产生疑惑。 formUploader 可以再其他地方使用而无需复制代码，可以在 github 或 npm 上轻松共享。 处理每一个错误 程序运行中，会产生许多错误：语法错误，运行时错误等等。 前两条准则是保持你的程序更加可读，这条规则则是保证你的程序的可靠性。处理回调时，你可以根据定义处理每一个已分配任务，可以在后台执行某些操作，来监测程序成功完成或者因为错误终止。有经验的开发者常常会告诉你，你不可能知道错误什么时候发生，所以你要做的就是假想他们已经发生。 Node.js 中常用的处理错误的方式就是 error-first 风格，其回调的第一个参数始终为错误保留。 12345678var fs = require('fs')fs.readFile('/Does/not/exist', handleFile)function handleFile (error, file) { if (error) return console.error('Uhoh, there was an error', error) // otherwise, continue on and use `file` in your code} 让第一个参数成为错误是一种简单的约定，鼓励你记住处理错误，如果是第二个参数来作为错误处理，就很容易忘记。 使用一个代码检查工具也能够很好的避免处理错误。 小结 不要嵌套函数，为函数命名并将它们放到程序顶层。 使用 函数提升（function hoisting），有利于你将函数转移到程序底部。 处理回调中 每一个错误 。使用 standard 帮助你来处理。 创建可重用的函数并将它们放在一个模块中，以减少理解代码所需的认知负担。将代码拆分成这样的小块也可以帮助您处理错误，编写测试，强制你为代码创建稳定且记录的公共API，并有助于重构。 避免回调地狱最有效的方式就是将函数分离出来。这样程序流程可以更易于理解，新接手程序的人不必去了解功能的所有模块也能尝试理解函数正在做什么。 你可以将函数移到文件底部，或者创建成模块来引用。 关于创建模块也有一些建议： 将重复使用的代码移到一个函数中。 当你的函数（或者相关的函数）变得足够大时，将它们移到另一个文件并使用 module.exports 公开它们，以便于在其他地方加载它们。 如果你有一些代码需要在多个项目中使用，请为它书写 readme， tests 和 package.json，并将它发布到 github 和 npm 上。 一个好的模块是足够小并且关注于解决一个问题。 模块中的单个文件建议不超过150行。 一个模块最好不具有超过一层以上的 JavaScript 文件的文件夹，如果超过了，或许它做了过多的事情。 了解更多经验丰富的程序员所书写的代码。简洁的模块都是易于理解的。 引用 https://frontendmasters.com/courses/rethinking-async-js/ slides&amp;code asynchronous-versus-parallel-programming http://callbackhell.com/","link":"/2019/04/19/JavaScript%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%861/"},{"title":"JavaScript设计模式与开发实践（一）","text":"全书分为三部分，基础知识，设计模式，设计原则和编程技巧 下面我会简单的总结书中的一些有用的设计模式。 第一部分 基础知识 这一部分，我会快速总结相关的一些知识点，包括 面向对象的JavaScript this,call和apply 闭包和高阶函数 面向对象的JavaScript 首先我们要了解一些基本概念，关于动态类型语言，鸭子类型，原型委托和多态以及原型模式等。 动态类型语言和鸭子模式 所谓动态类型语言，必定是相对于静态类型语言所做的比较。 静态类型语言的优点首先是在编译时就能发现类型不匹配的错误,编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。静态类型语言的缺点首先是迫使程序员依照强契约来编写程序,为每个变量规定数据类型。 动态类型语言的优点是编写的代码数量更少,看起来也更加简洁,程序员可以把精力更多地放在业务逻辑上面。动态类型语言的缺点是无法保证变量的类型,从而在程序的运行期有可能发生跟类型相关的错误。 动态语言对变量类型的宽容建立在 鸭子类型(duck typing) 的概念。 所谓鸭子类型的主要思想就是：我们只需要关注对象的行为，或者叫需要对象实现的功能，而不需要关注对象本身。 多态 多态的实际含义是:同一操作作用于不同的对象上面,可以产生不同的解释和不同的执行结果。换句话说,给不同的对象发送同一个消息的时候,这些对象会根据这个消息分别给出不同的反馈。 静态语言中，多态的实现需要抽象一个超类，通过继承来实现。 多态的思想主要是“做什么”和“谁去做”，这样我们就能消除类型之间的耦合关系，完成多态的实现。 多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性,从而消除这些条件分支语句。 下面来看一段简单的渲染map的代码，实现多态： 1234567891011121314151617181920212223242526272829var googleMap = { show: function(){ console.log( '开始渲染谷歌地图' ); }};var baiduMap = { show: function(){ console.log( '开始渲染百度地图' ); }};var renderMap = function( map ){ if ( map.show instanceof Function ){ map.show(); }};renderMap( googleMap );renderMap( baiduMap );// 我们需要一个添加新的地图渲染，就死添加一个新的对象就行了，避免判断var sosoMap = { show: function(){ console.log( '开始渲染搜搜地图' ); }};renderMap( sosoMap ); 封装 在 JavaScript 或者其他语言中，封装有很多含义，不仅仅限定于封装数据，只要是将数据隐藏的“任何形式的封装”，我们都能够称之为封装。在 JS 中，我们常见的封装的封装形式就是作用域及闭包了。封装失对象之间的耦合变松散，我们只需要关注对象之间暴露的API，来实现所需功能了。 《设计模式》中有一段话用来描述封装 “ 考虑你的设计中哪些地方可能变化,这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变,而是考虑你怎样才能够在不重新设计的情况下进行改变。这里的关键在于封装发生变化的概念,这是许多设计模式的主题。” 这段话的核心也就是封装的本质， “找到变化并封装之”。 原型模式和基于原型继承的 JavaScript 对象系统 如同题目所示，原型模式早就融入到 JavaScript 中了。原型模式不单是一种设计模式,也被称为一种编程泛型。 原型模式是用于创建对象的一种模式。原型模式的核心就是克隆，原型模式的关键也是语言本身是否提供 clone 方法。ECMAScript 5 提供了 Object.create方法,可以用来克隆对象。 12345678910111213var Plane = function(){ this.blood = 100; this.attackLevel = 1; this.defenseLevel = 1;};var plane = new Plane();plane.blood = 500;plane.attackLevel = 10;plane.defenseLevel = 7;var clonePlane = Object.create( plane );console.log( clonePlane );// 输出:Object {blood: 500, attackLevel: 10, defenseLevel: 7} 不支持Object.create 方法的浏览器中,则可以使用以下代码： 123456Object.create = Object.create || function( obj ){ var F = function(){}; F.prototype = obj; return new F();} JavaScript中的原型继承 JavaScript遵循着一些原型编程的基本规则： * 所有的数据都是对象。 * 要得到一个对象,不是通过实例化类,而是找到一个对象作为原型并克隆它。 * 对象会记住它的原型。 * 如果对象无法响应某个请求,它会把这个请求委托给它自己的原型。 所有的数据都是对象 JavaScript 在设计的时候,模仿 Java 引入了两套类型机制:基本类型和对象类型。基本类型包括 undefined 、 number 、 boolean 、 string 、 function 、 object 。从现在看来,这并不是一个好的想法。 按照 JavaScript 设计者的本意,除了 undefined 之外,一切都应是对象。为了实现这一目标,number 、 boolean 、 string 这几种基本类型数据也可以通过“包装类”的方式变成对象类型数据来处理。 我们不能说在 JavaScript 中所有的数据都是对象,但可以说绝大部分数据都是对象。那么相信在 JavaScript 中也一定会有一个根对象存在,这些对象追根溯源都来源于这个根对象。 事实上,JavaScript 中的根对象是 Object.prototype 对象。 Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象,实际上都是从 Object.prototype 对象克隆而来的,Object.prototype 对象就是它们的原型。比如下面的 obj1 对象和 obj2 对象: 12var obj1 = new Object();var obj2 = {}; 可以利用 ECMAScript 5 提供的 Object.getPrototypeOf 来查看这两个对象的原型: 12console.log( Object.getPrototypeOf( obj1 ) === Object.prototype ); // 输出:trueconsole.log( Object.getPrototypeOf( obj2 ) === Object.prototype ); // 输出:true 要得到一个对象,不是通过实例化类,而是找到一个对象作为原型并克隆它 了解下，我们new运算符从构造琦中得到一个对象的过程。 当使用 new 运算符来调用函数时,此时的函数就是一个构造器。 用new 运算符来创建对象的过程,实际上也只是先克隆 Object.prototype 对象,再进行一些其他额外操作的过程。 对象会记住它的原型 就 JavaScript 的真正实现来说，其实不能说对象有原型，而至能说对象的构造器有原型。对于”对象吧把请求委托给它自己的原型“这句话，更好的说法是对象委托给它的构造器的原型。那么队形如何把请求顺利的转交给它的构造器的原型呢？ JavaScript 给对象提供了一个名为 proto 的隐藏属性,某个对象的 proto 属性默认会指向它的构造器的原型对象,即 {Constructor}.prototype 。 123var a = new Object();console.log ( a.__proto__=== Object.prototype );// 输出:true 实际上, proto 就是对象跟“对象构造器的原型”联系起来的纽带。正因为对象要通过__proto__ 属性来记住它的构造器的原型,所以我们用上一节的 objectFactory 函数来模拟用 new创建对象时, 需要手动给 obj 对象设置正确的 proto 指向。 如果对象无法响应某个请求,它会把这个请求委托给它的构造器的原型 这条规则即是原型继承的精髓所在。 在 JavaScript 中,每个对象都是从 Object.prototype 对象克隆而来的,如果是这样的话,我们只能得到单一的继承关系,即每个对象都继承自 Object.prototype 对象,这样的对象系统显然是非常受限的。 实际上,虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的,但对象构造器的原型并不仅限于 Object.prototype 上,而是可以动态指向其他对象。这样一来,当对象 a 需要借用对象 b 的能力时,可以有选择性地把对象 a 的构造器的原型指向对象 b ,从而达到继承的效果。下面的代码是我们最常用的原型继承方式: 1234567var obj = { name: 'sven' };var A = function(){};A.prototype = obj;var a = new A();console.log( a.name ); 我们来看看执行这段代码的时候,引擎做了哪些事情。 首先,尝试遍历对象 a 中的所有属性,但没有找到 name 这个属性。 查找 name 属性的这个请求被委托给对象 a 的构造器的原型,它被 a. proto 记录着并且 指向 A.prototype ,而 A.prototype 被设置为对象 obj 。 在对象 obj 中找到了 name 属性,并返回它的值。 当我们期望得到一个“类”继承自另外一个“类”的效果时,往往会用下面的代码来模拟实现: 12345678var A = function(){};A.prototype = { name: 'sven' };var B = function(){};B.prototype = new A();var b = new B();console.log( b.name ); // 输出:sven 再看这段代码执行的时候,引擎做了什么事情。 首先,尝试遍历对象 b 中的所有属性,但没有找到 name 这个属性。 查找 name 属性的请求被委托给对象 b 的构造器的原型,它被 b. proto 记录着并且指向B.prototype ,而 B.prototype 被设置为一个通过 new A() 创建出来的对象。 在该对象中依然没有找到 name 属性,于是请求被继续委托给这个对象构造器的原型A.prototype 。 在 A.prototype 中找到了 name 属性,并返回它的值。 this 、 call 和 apply 在 JavaScript 的this总是指向一个对象，而具体指向那个对象是运行时 基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this 的指向 除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下四种。 作为对象的方法调用。 作为普通函数调用。 构造器调用。 Function.prototype.call 或 Function.prototype.apply 调用。 1. 作为对象的方法调用 当函数作为对象的方法被调用时，this指向该对象： 123456789var obj = { a: 1, getA: function() { alert(this === obj); // 输出：true alert ( this.a ); // 输出: 1 }};obj.getA(); 2. 作为普通函数调用 当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指 向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。 1234567window.name = 'globalName';var getName = function() { return this.name;};console.log(getName()); // globalName 注意一下，下面这个例子阐释了this在runtime定义： 1234567891011window.name = 'globalName';var myObject = { name: 'sven', getName: function() { return this.name; }};var getName = myObject.getName;console.log(getName()); // globalName 3. 构造器调用 JavaScript 中没有类，但是能通过 new 运算符从构造器中创建对象。 除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象，见如下代码： 123456var MyClass = function() { this.name = 'sven';};var obj = new MyClass();alert(obj.name); // anne 但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this： 123456789var MyClass = function() { this.name = 'sven', return { // 显式地返回一个对象 name: 'anne' }};var obj = new MyClass();alert(obj.name); 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题： 123456var MyClass = function(){ this.name = 'sven' return 'anne'; // 返回 string 类型};var obj = new MyClass();alert ( obj.name ); // 输出：sven 4. Function.prototype.call 或 Function.prototype.apply 调用 跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this： 12345678910111213var obj1 = { name: 'sven', getName: function(){ return this.name; }};var obj2 = { name: 'anne'};console.log( obj1.getName() ); // 输出: svenconsole.log( obj1.getName.call( obj2 ) ); // 输出：anne 丢失的this 何为丢失的this呢？ 其实主要this的指向是runtime的，前面的对象的方法的函数在外部调用也是这个意思哈。 call 和 apply call和apply的区别主要就是在传入的参数形式不同。 1234567var func = function( a, b, c ){ alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]};func.apply( null, [ 1, 2, 3 ] );func.call( null, 1, 2, 3 ); call和apply的用途 1. 改变 this 指向 2. Function.prototype.bind bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 bind, 没错就是一个语法糖。当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。 借用其他对象的方法 借用方法的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果： 1234567891011var A = function( name ){ this.name = name;};var B = function(){ A.apply( this, arguments );};B.prototype.getName = function(){ return this.name;};var b = new B( 'sven' );console.log( b.getName() ); // 输出： 'sven' 1234(function(){ Array.prototype.push.call( arguments, 3 ); console.log ( arguments ); // 输出[1,2,3]})( 1, 2 ); 想把 arguments 转成真正的数组的时候，可以借用 Array.prototype.slice 方法；想截去 arguments 列表中的头一个元素时，又可以借用 Array.prototype.shift 方法。那么这种机制的内 部实现原理是什么呢？我们不妨翻开 V8 的引擎源码，以 Array.prototype.push 为例，看看 V8 引 擎中的具体实现： 123456789function ArrayPush() { var n = TO_UINT32( this.length ); // 被 push 的对象的 length var m = %_ArgumentsLength(); // push 的参数个数 for (var i = 0; i &lt; m; i++) { this[ i + n ] = %_Arguments( i ); // 复制元素 (1) } this.length = n + m; // 修正 length 属性的值 (2) return this.length;}; Array.prototype.slice 实现条件： * 对象本身要可以存取属性 * 对象的 length 属性可读写 闭包和高阶函数 闭包 对于 JavaScript 程序员来说，闭包（closure）是一个难懂又必须征服的概念。闭包的形成与变量的作用域以及变量的生存周期密切相关。下面我们先简单了解这两个知识点。 1. 变量的作用域 当再函数中声明一个变量的时候，如果该变量前面没有带上关键字var，这个变量就会成为全局变量。所以避免变量声明前面不加声明关键词。 2. 变量的生存周期 除了变量的作用域之外，另外一个跟闭包有关的概念是变量的生存周期。 对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。 而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁： 1234567891011121314var func = function() { var a = 1; return function() { a++; alert(a); }};var f = func();f(); // 输出：2f(); // 输出：3f(); // 输出：4f(); // 输出：5 在这里我们推出函数后，局部变量 a 并没有消失，而是似乎一直在某个地方存活着。原因是：当执行 var发= function();时，f返回一个匿名函数的引用，它可以访问到func()被调用是产生的环境，而局部变量a一直处在这个环境里。既然局部变量所在环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里就产生了一个闭包结构，局部变量的生命看起来被延续了。 闭包的一个经典应用是之前var声明的循环遍历中使用。 123456789var func = function() { for (var j = 0; j &lt; 5; j++) { setTimeout((function(i) { console.log(i) })(j), 0) }}func() // 0, 1, 2, 3, 4 #### 闭包的更多作用 封装变量 闭包可以帮助把一些不需要暴露在全局的变量封装乘“私有变量”。假设一个计算乘积的简单函数。 1234567891011121314151617181920var mult = (function() { var cache = {}; var calculate = function() { var a = 1; for( var i = 0, l = arguments.length; i &lt; l; i++) { a = a * arguments[i]; } return a; }; return function() { var args = Array.prototype.join.call(arguments, ','); if ( args in cache ){ return cache[ args ]; } return cache[args] = calculate.apply( null, arguments ); }}) 延续局部变量的寿命 #### 闭包和面向对象设计 过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程,而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能,用闭包也能实现。反之亦然。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 闭包写法var extent = function() { var value = 0; return { call: function() { value++; console.log(value) } }};var extent = extent();extent.call();extent.call();extent.call();// 面向对象写法var extent = { value: 0, call: function() { this.value++; console.log(this.value); }};extent.call();extent.call();extent.call();// 原型写法var Extent = function() { this.value = 0;};Extent.prototype.call = function() { this.value++; console.log(this.value);};var extent = new Extent();extent.call();extent.call();extent.call(); 关于闭包域内存管理，将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时,就会删除这些值并回收它们占用的内存。 高阶函数 高阶函数是指至少满足下列条件之一的函数。 函数可以作为参数被传递; 函数可以作为返回值输出。 函数作为参数传递 把函数当作参数传递,这代表我们可以抽离出一部分容易变化的业务逻辑,把这部分业务逻辑放在函数参数中,这样一来可以分离业务代码中变化与不变的部分。其中一个重要应用场景就是常见的回调函数。 回调函数 Array.prototype.sort 12345[ 1, 4, 3 ].sort( function( a, b ){ return a - b;});// 输出: [ 1, 3, 4 ] 函数作为返回值输出 相比把函数当作参数传递,函数当作返回值输出的应用场景也许更多,也更能体现函数式编程的巧妙。让函数继续返回一个可执行的函数,意味着运算过程是可延续的。 高阶函数实现AOP 这一部分到后面装饰者模式再细讲。 高阶函数的其他应用 currenying 首先我们讨论的是函数柯里化。currying 又称部分求值。一个 currying 的函数首先会接受一些参数,接受了这些参数之后,该函数并不会立即求值,而是继续返回另外一个函数,刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候,之前传入的所有参数都会被一次性用于求值。 uncurrying 在 JavaScript 中，当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点，也是常说的鸭子类型思想。 同理，一个对象也未必只能使用它自身的方法，那么有什么办法可以让对象去借用一个原本不属于它的方法呢？ 这里我们借用了一个泛化this的过程： 12345678910111213141516171819202122232425262728Function.prototype.uncurrying = function() { var self = this; return function() { var obj = Array.prototype.shift.call(arguments); return self.apply(obj, arguments) };};// var push = Array.prototype.push.uncurrying();// (function() {// push(arguments, 4);// console.log(arguments);// })(1,2,3)for (var i = 0, fn, arr = ['push', 'shift', 'forEach']; fn = arr[i++];) { Array[fn] = Array.prototype[fn].uncurrying();};var obj = { 'length': 3, '0': 1, '1': 2, '2': 3}Array.push(obj, 4);console.log(obj.length) 函数节流","link":"/2018/05/02/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Vue-Cnode-Pwa 过程中的小坑","text":"总结下开发过程中的一些小坑。 # 项目概括 线上地址https://brokenbones.xyz ## 页面编写 页面编写主要采用的MVVM框架vue.js开发，是直接用的vue-cli脚手架提供的PWA模板,页面样式采用的是vuetify，数据管理用的是vuex，api通讯采用的axios,页面的路由采用的vue-router，其中我才用了history模式，这种模式更适合PWA。边写文章部分，采用了，Mavon-Editor的markdown编辑器。 PWA部分 主要是自己编写了mainfest.json，sw.js则是利用sw-precahe-webpack-plugin生成。 域名注册 PWA应用必须采用https,这里我用的是腾讯云的免费的SSL证书，配置十分方便，推荐，免费一年。 项目结构 根据路由拆分=&gt;项目的主要page有： 主题列表 全部 精华 分享 问答 招聘 测试 主题详情 文章部分 文章回复列表 回复收藏文章、点赞和回复他人评论 个人中心 最近回复 最近发布 话题收藏 我的消息 已读消息 未读消息 新建主题 Mavon-Editor 关于 项目准备工作 主要是，对常见的字体和ret.styl进行打包下载，也观察了其他一些人做相同的社区的页面的结构。 项目总结 路由部分 这个项目让我对vue-router的认识更加深了一步。 ### HTML5 history模式 vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 当你使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id ，也好看！ 不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。 所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 后端配置见:后端配置 最后，给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。 123456const router = new VueRouter({ mode: 'history', routes: [ { path: '*', component: NotFoundComponent } ]}) 导航守卫和watch路由变化 导航守卫有： * beforeRouteEnter * beforeRouteUpdate (2.2 新增) * beforeRouteLeave 这个项目中，我用了直接的watch路由变化和beforeRouteUpdate 主题详情界面有五个分路由，全部、问答和测试等。在路由设置中，我们保持的keep-alive，这样可以保持组件的状态保持，对于项目的体验比较好。可是页面的路由变化，如果使用的是同一组件的时候，页面的内容就不会变化，像主题的切换和主题详情的内容的变化等，这是我们就需要利用 beforeRouteUpdate或者watch路由的变化。 例如，ListView组件中的: 12345beforeRouteUpdate(to, from, next) { this.postList = [] this.getTabData(to.query.tab) next()} 和TopicDetail中的watch: 12345678910111213watch: { $route(to, from) { // 理解一下to＝＝要去的路由 记录TopicId,避免相同页面再重复加载 // this.topic = [] if (to.name === 'topic' &amp;&amp; to.params.id !== this.topicId) { this.topic = {} this.getDetail(this.$route.params.id) if (from.name === 'topic') { this.setTopicId(from.params.id) } } }} 页面的滚动状态保持 当我们，在主题列表滚动了一段距离之后，我们点击了一个主题，然后我们再次返回的时候，主题列表需要保持原来的滚动状态。 本来我的主题列表想要添加better-scroll的。但是每次页面滚动之后，点击新主题，再返回的时候，页面总会跳转到顶端，这样的话，浏览体验就非常不好。然后我了解了一下 better-scroll 的滚动原理： 绿色部分为 wrapper，也就是父容器，它会有固定的高度。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。 这里，我们了解到了，better-scroll 的滚动原理中，我们需要一个固定的wrapper，这样的话，我们的内容在我们的页面中的话，就是在一个固定的窗口下。 vue-router 中有一个scrollBehavior ，滚动行为，使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。 我们需要记录scrollTop属性，上面采用 better-scroll 的话，我们的窗口是固定的，也就是，这里的scrollTop是相对于我们wrapper，而wrapper在页面中的位置是固定的就是没有scrollTop，这样的话，我们记录的scrollTop没有用。 如果用 better-scroll ，我们就需要页面跳转的话每次将scrollTop的值手动传给组件，十分麻烦，最后我放弃了并采用了原生的scroll。 vue-router懒加载 没什么好说的，为了加载高效肯定要用的。 其他一些 mavonEditor 论坛的文章编辑，现在大部分写文章的都是md了，所以我找了找，最好的还是这个，安装好npm包，加一个标签再加上一点配置接好了。地址：mavonEditor 多处用的登录验证 没有登录的时候，很多地方都需要登录验证。因为有路由跳转逻辑，需要 js ，有了 mixin 就很好了。我们写好了 mixin 后，在我们需要添加登录页面的地方添加 mixin 和添加登录页面的组件。 最后，还想到什么有需要总结的还是会更新文章的。","link":"/2018/02/21/Vue-Cnode-Pwa-%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9D%91/"},{"title":"babel使用","text":"babel-handbook 介绍 Babel 是一个通用的多用途 JavaScript 编译器。通过 Babel 你可以使用（并创建）下一代的 JavaScript，以及下一代的 JavaScript 工具。 作为一种语言，JavaScript 在不断发展，新的标准／提案和新的特性层出不穷。 在得到广泛普及之前，Babel 能够让你提前（甚至数年）使用它们。 Babel 把用最新标准编写的 JavaScript 代码向下编译成可以在今天随处可用的版本。 这一过程叫做“源码到源码”编译， 也被称为转换编译（transpiling，是一个自造合成词，即转换＋编译。以下也简称为转译）。 安装 Babel 由于 JavaScript 社区没有统一的构建工具、框架、平台等等，因此 Babel 正式集成了对所有主流工具的支持。 从 Gulp 到 Browserify，从 Ember 到 Meteor，不管你的环境设置如何，Babel 都有正式的集成支持。 本手册的目的主要是介绍 Babel 内建方式的安装，不过你可以访问交互式的安装页面来查看其它的整合方式。 babel-cli Babel 的 CLI 是一种在命令行下使用 Babel 编译文件的简单方法。 让我们先全局安装它来学习基础知识。 1$ npm install --global babel-cli 我们可以这样编译我们的第一个文件 1$ babel my-file.js 这将把编译后的结果直接输出至终端。使用 --out-file 或着 -o 可以将结果写入到指定的文件。 123$ babel example.js --out-file compiled.js# 或$ babel example.js -o compiled.js 如果我们想要把一个目录整个编译成一个新的目录，可以使用 --out-dir 或者 -d。 123$ babel src --out-dir lib# 或$ babel src -d lib 在项目内运行 Babel CLI 尽管你可以把 Babel CLI 全局安装在你的机器上，但是按项目逐个安装在本地会更好。 有两个主要的原因。 在同一台机器上的不同项目或许会依赖不同版本的 Babel 并允许你有选择的更新。 这意味着你对工作环境没有隐式依赖，这让你的项目有很好的可移植性并且易于安装。 要在（项目）本地安装 Babel CLI 可以运行： 1$ npm install --save-dev babel-cli 注意: 因为全局运行 Babel 通常不是什么好习惯所以如果你想要卸载全局安装的 Babel 的话，可以运行： 1$ npm uninstall --global babel-cli 安装完成后，你的 package.json 应该如下所示： 1234567{ \"name\": \"my-project\", \"version\": \"1.0.0\", \"devDependencies\": { \"babel-cli\": \"^6.0.0\" }} 现在，我们不直接从命令行运行 Babel 了，取而代之我们将把运行命令写在 npm scripts 里，这样可以使用 Babel 的本地版本。 只需将 \"scripts\" 字段添加到你的 package.json 文件内并且把 babel 命令写成 build 字段。. 12345678910 { \"name\": \"my-project\", \"version\": \"1.0.0\",+ \"scripts\": {+ \"build\": \"babel src -d lib\"+ }, \"devDependencies\": { \"babel-cli\": \"^6.0.0\" } } 现在可以在终端里运行： 1npm run build 这将以与之前同样的方式运行 Babel，但这一次我们使用的是本地副本。 babel-register 下一个常用的运行 Babel 的方法是通过 babel-register。这种方法只需要引入文件就可以运行 Babel，或许能更好地融入你的项目设置。 但请注意这种方法并不适合正式产品环境使用。 直接部署用此方式编译的代码不是好的做法。 在部署之前预先编译会更好。 不过用在构建脚本或是其他本地运行的脚本中是非常合适的。 让我们先在项目中创建 index.js 文件。 1console.log(\"Hello world\") 如果我们用 node index.js 来运行它是不会使用 Babel 来编译的。所以我们需要设置 babel-register。. 首先安装 babel-register。 1$ npm install --save-dev babel-register 接着，在项目中创建 register.js 文件并添加如下代码： 12require(\"babel-register\");require(\"./index.js\"); 这样做可以把 Babel 注册到 Node 的模块系统中并开始编译其中 require 的所有文件。 现在我们可以使用 register.js 来代替 node index.js 来运行了。 1$ node register.js 注意：你不能在你要编译的文件内同时注册 Babel，因为 node 会在 Babel 编译它之前就将它执行了。 123require(\"babel-register\");// 未编译的：console.log(\"Hello world!\"); babel-node 如果你要用 node CLI 来运行代码，那么整合 Babel 最简单的方式就是使用 babel-node CLI，它是 node CLI 的替代品。 但请注意这种方法并不适合正式产品环境使用。 直接部署用此方式编译的代码不是好的做法。 在部署之前预先编译会更好。 不过用在构建脚本或是其他本地运行的脚本中是非常合适的。 首先确保 babel-cli 已经安装了。 1$ npm install --save-dev babel-cli 然后用babel-node 来替代node运行所有的代码。 如果用 npm script 的话只需要这样做： 123456 { \"scripts\": {- \"script-name\": \"node script.js\"+ \"script-name\": \"babel-node script.js\" } } 要不然的话你需要写全 babel-node 的路径。 12- node script.js+ ./node_modules/.bin/babel-node script.js 提示：你可以使用 npm-run babel-core 如果你需要以编程的方式来使用 Babel，可以使用 babel-core 这个包。 首先安装 babel-core。 1$ npm install babel-core 1var babel = require(\"babel-core\"); 字符串形式的 JavaScript 代码可以直接使用 babel.transform 来编译。 12babel.transform(\"code();\", options);// =&gt; { code, map, ast } 如果是文件的话，可以使用异步 api： 123babel.transformFile(\"filename.js\", options, function(err, result) { result; // =&gt; { code, map, ast }}); 或者是同步 api： 12babel.transformFileSync(\"filename.js\", options);// =&gt; { code, map, ast } 要是已经有一个 Babel AST（抽象语法树）了就可以直接从 AST 进行转换。 12babel.transformFromAst(ast, code, options);// =&gt; { code, map, ast } 对于上述所有方法，options 指的都是 http://babeljs.io/docs/usage/options/ 配置 Babel 你或许已经注意到了，目前为止通过运行 Babel 自己我们并没能“翻译”代码，而仅仅是把代码从一处拷贝到了另一处。 这是因为我们还没告诉 Babel 要做什么。 由于 Babel 是一个可以用各种花样去使用的通用编译器，因此默认情况下它反而什么都不做。你必须明确地告诉 Babel 应该要做什么。 你可以通过安装插件（plugins）或预设（presets，也就是一组插件）来指示 Babel 去做什么事情。 .babelrc 在我们告诉 Babel 该做什么之前，我们需要创建一个配置文件。你需要做的就是在项目的根路径下创建 .babelrc 文件。然后输入以下内容作为开始： 1234{ \"presets\": [], \"plugins\": []} 这个文件就是用来告诉Babel做你要他做的事情的配置文件。 注意:尽管你也可以用其他方式给 Babel 传递选项，但 .babelrc 文件是约定也是最好的方式。 babel-preset-es2015 我们先从让 Babel 把 ES2015（最新版本的 JavaScript 标准，也叫做 ES6）编译成 ES5（现今在大多数 JavaScript 环境下可用的版本）开始吧。 我们需要安装 \"es2015\" Babel 预设： 1$ npm install --save-dev babel-preset-es2015 我们修改 .babelrc 来包含这个预设。 123456 { \"presets\": [+ \"es2015\" ], \"plugins\": [] } babel-preset-stage-x JavaScript 还有一些提案，正在积极通过 TC39（ECMAScript 标准背后的技术委员会）的流程成为标准的一部分。 这个流程分为 5（0－4）个阶段。 随着提案得到越多的关注就越有可能被标准采纳，于是他们就继续通过各个阶段，最终在阶段 4 被标准正式采纳。 以下是4 个不同阶段的（打包的）预设： babel-preset-stage-0 babel-preset-stage-1 babel-preset-stage-2 babel-preset-stage-3 注意 stage-4 预设是不存在的因为它就是上面的 es2015 预设。 以上每种预设都依赖于紧随的后期阶段预设。例如，babel-preset-stage-1 依赖 babel-preset-stage-2，后者又依赖 babel-preset-stage-3。. 使用的时候只需要安装你想要的阶段就可以了： 1$ npm install --save-dev babel-preset-stage-2 然后添加进你的 .babelrc 配置文件。 1234567 { \"presets\": [ \"es2015\",+ \"stage-2\" ], \"plugins\": [] } 执行 Babel 生成的代码 即便你已经用 Babel 编译了你的代码，但这还不算完。 babel-polyfill Babel 几乎可以编译所有时新的 JavaScript 语法，但对于 APIs 来说却并非如此。 比方说，下列含有箭头函数的需要编译的代码： 123function addAll() { return Array.from(arguments).reduce((a, b) =&gt; a + b);} 最终会变成这样： 12345function addAll() { return Array.from(arguments).reduce(function(a, b) { return a + b; });} 然而，它依然无法随处可用因为不是所有的 JavaScript 环境都支持 Array.from。 Uncaught TypeError: Array.from is not a function 为了解决这个问题，我们使用一种叫做 Polyfill（代码填充，也可译作兼容性补丁） 的技术。 简单地说，polyfill 即是在当前运行环境中用来复制（意指模拟性的复制，而不是拷贝）尚不存在的原生 api 的代码。 能让你提前使用还不可用的 APIs，Array.from 就是一个例子。 Babel 用了优秀的 core-js 用作 polyfill，并且还有定制化的 regenerator 来让 generators（生成器）和 async functions（异步函数）正常工作。 要使用 Babel polyfill，首先用 npm 安装它： 1$ npm install --save babel-polyfill 然后只需要在文件顶部导入 polyfill 就可以了： 1import \"babel-polyfill\"; babel-runtime 为了实现 ECMAScript 规范的细节，Babel 会使用“助手”方法来保持生成代码的整洁。 由于这些助手方法可能会特别长并且会被添加到每一个文件的顶部，因此你可以把它们统一移动到一个单一的“运行时（runtime）”中去。 通过安装 babel-plugin-transform-runtime 和 babel-runtime 来开始。 12$ npm install --save-dev babel-plugin-transform-runtime$ npm install --save babel-runtime 然后更新 .babelrc： 123456 { \"plugins\": [+ \"transform-runtime\", \"transform-es2015-classes\" ] } 现在，Babel 会把这样的代码： 123class Foo { method() {}} 编译成： 123456789101112131415import _classCallCheck from \"babel-runtime/helpers/classCallCheck\";import _createClass from \"babel-runtime/helpers/createClass\";let Foo = function () { function Foo() { _classCallCheck(this, Foo); } _createClass(Foo, [{ key: \"method\", value: function method() {} }]); return Foo;}(); 这样就不需要把 _classCallCheck 和 _createClass 这两个助手方法放进每一个需要的文件里去了。 配置 Babel（进阶） 大多数人使用 Babel 的内建预设就足够了，不过 Babel 提供了更多更细粒度的能力。","link":"/2017/10/22/babel%E4%BD%BF%E7%94%A8/"},{"title":"webpack 基础(三)： 核心概念","text":"这篇主要谈一下Webpack核心概念 Entry entry会根据入口文件分析依赖生成依赖关系图。 webpack_entry Ouput 告诉 Webpack 如何及在哪里分发 bundles (编译后文件)，和 Entry 一起工作。 webpack_output Loader+Rules loaders Webpack 4.0 中将每一个依赖都当作一个JavaScript Module处理。所以我们需要定义一个规则，如何把一个文件当作JavaScript文件处理。Webpack处理文件依赖的时候，遇到这些文件就会去rules中寻找相对应的loader，处理后将文件加入依赖关系图。 1234567891011121314151617181920module: { rules: { {test: /\\.ts$/, use: 'ts-loader'}, {test: /\\.js$/, use: 'babel-loader'}, {test: /\\.css$/, use: 'css-loader'} }}// module: {// rules: [ { test: regex, use: (Array|String|Function), include: RegExp[], exclude: RegExp[], issuer: (RegExp|String)[], enforce: \"pre\"|\"post\" }// ]// } test: 一个正则表达式，指定compiler运行loader的文件格式 use: 使用loader对象的array/string/function enforce: 可以是\"pre\"or\"post\"，告诉Webpack这条规则在所有其他规则前面或者后面。 include: 一个正则表达式数组，用来指示compiler哪些文件或者文件夹被包含。complier将仅搜索提供的路径。 exclude: 一个正则表达式数组，用来指示compiler哪些文件或者文件夹被忽略。 (链式loaders)chaining loaders 12345678rules: [ { test: /\\.less$/, use: ['style', 'css', 'less'] }]// 调用方法顺序展示// style(css(less())) 假设我们有一个style.less文件，那么它的调用顺序就是 style.less =&gt; less-loader =&gt; css-loader =&gt; style-loader =&gt; inlineStyleBrowser.js。 当然Webpack能通过loader处理大量的文件，如下所示： 12345678910111213141516171819son, hson, raw, val, to-string, imports, exports, expose, script, apply, callback, ifdef-loader, source-map, sourceMappingURL,checksum, cowsay, dsv, glsl, glsl-template, render-placement, xml, svg-react, svg-url, svg-as-symbol, symbol, base64, ng-annotate,node, required, icons, markup-inline, block-loader, bundler-configuration, console, solc, .sol, web3, includes, combine,regexp-replace, file, url, extract, worker, shared-worker, serviceworker, bundle, require.ensure, promise, async-module, bundle,require.ensure, react-proxy, react-hot, image, file, url, img, base64-image, responsive, srcset, svgo, svg-sprite, symbol,svg-fill, fill, line-art, baggage, polymer, uglify, html-minify, vue, tojson, zip-it, file, lzstring, modernizr, s3, path-replace,react-intl, require.ensure, font-subset, w3c-manifest, web-app-manifest, manifest-scope, coffee, coffee-jsx, coffee-redux, json5,es6, esnext, babel, regenerator, livescript, sweetjs, traceur, ts, typescript, awesome-typescript, webpack-typescript, purs, oj,elm-webpack, miel, wisp, sibilant, ion, html, dom, riot, pug, jade-html, jade-react, virtual-jade, virtual-dom, template-html,handlebars, handlebars-template-loader, dust, ractive, jsx, react-templates, em, ejs, ejs-html, mustache, yaml, yml,react-markdown, front-matter, markdown, remarkable, markdown-it, markdownattrs, ng-cache, ngtemplate, hamlc, haml, jinja, nunjucks,soy, smarty, swagger, template-string, ect, tmodjs, layout, swig, twig, mjml-, bootstrap-webpack, font-awesome-webpack,bootstrap-sass, bootstrap, bootstrap, font-awesome, style, isomorphic-style, style-loader, css, cess, less, sass, stylus, csso,rework, postcss, autoprefixer, namespace-css, fontgen, classnames, theo, bulma, css-to-string, css-loader, po, po2mo,format-message, jsxlate, angular-gettext, json, angular-gettext, webpack-angular-translate, angular-gettext-extract, .pot,gettext, preprocessor, amdi18n-loader, .json, .js, .coffee, sprockets-preloader, properties, transifex, mocha, coverjs,istanbul-instrumenter, ibrik-instrumenter, eslint, jshint, jscs, standard, inject, transform, falafel, image-size, csslint,coffeelint, tslint, parker, sjsp, amdcheck, manifest, gulp-rev, html-test, stylelint, stylefmt, scsslint, htmlhint, documentation,sassdoc, performance-loader Plugins 首先Plugin是一个带有apply属性的对象，它能允许挂载到整个编译生命周期。Webpack本身拥有丰富的内置插件。 首先来看一个插件例子： 123456789101112131415161718192021// webpack 3.0 apifunction BellOnBundlerErrorPlugin () { }BellOnBundlerErrorPlugin.prototype.apply = function(compiler) { if (typeof(process) !== 'undefined') { // Compiler events that are emitted and handled compiler.plugin('done', function(stats) { if (stats.hasErrors()) { process.stderr.write('\\x07'); } }); compiler.plugin('failed', function(err) { process.stderr.write('\\x07'); }); }}module.exports = BellOnBundlerErrorPlugin; 我们需要做的就是 new 一个新的实例放到plugins里面。这样有一些基础的插件也能够被复用和修改。 下面是调用的例子： 1234567891011121314var BellOnBundlerErrorPlugin = require(‘bell-on-error’);var webpack = require(‘webpack’);module.exports = { //... plugins: [ new BellOnBundlerErrorPlugin(), // Just a few of the built in plugins new webpack.optimize.CommonsChunkPlugin(‘vendors’), new webpack.optimize.UglifyJsPlugin() ] //...} Webpack的80%都是由它自己的插件系统构成的。相较于loader知识处理文件转换成模块，plugin能做的更多。它能访问ComplierAPI，在编译期间做一些事情。 总结 Entry: 告诉 Webpack 哪些文件需要加载到浏览器；编译输出到 output 属性中。 Output: 告诉 Webpack 如何及在哪里分发 bundles (编译后文件)，和 Entry 一起工作。 Loaders: 告诉Webpack如何解释和翻译文件。再将文件添加到依赖关系图之前，对每个文件进行转换。 Plugins: 为编译过程添加更多的功能模块。又有更强大的访问ComplierAPI的能力。","link":"/2019/04/07/Webpack%E5%9F%BA%E7%A1%803/"},{"title":"canvas的简单了解及应用","text":"这个星期抽空看了下canvas，之前一直就对这两个东西望而却步，连简单的api和应用都没有了解。 工作中看到了html2canvas这个简单的工具可以根据DOM生成截图，于是抽空将MDN上的canvas教程撸了一遍。 # canvas基本概念 &lt;canvas&gt;是HTML5新增的元素，可以通过JavaScript中的脚本来绘制图形。例如，它可以绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或渲染。时间太短，没有看canvas的3d部分，下面的介绍都是关于canvas的2d部分的。 首先需要知道的是canvas的绘图栅格，canvas和svg一样，坐标都是一样的，坐标都是从左上角起始： 绘制相关 方法 功能 fillRect(x, y, width, height) 绘制一个填充的矩形 strokeRect(x, y, width, height) 绘制一个矩形的边框 clearRect(x, y, width, height) 清除指定矩形区域，让清除部分完全透明 beginPath() 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径 closePath() 闭合路径之后图形绘制命令又重新指向到上下文中 stroke() 通过线条来绘制图形轮廓 moveTo(x, y) 将笔触移动到指定的坐标x以及y上 lineTo(x, y) 绘制一条从当前位置到指定x以及y位置的直线 arc(x, y, radius, startAngle, endAngle, anticlockwise) 画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成 arcTo(x1, y1, x2, y2, radius) 根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点 quadraticCurveTo(cp1x, cp1y, x, y) 绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) 绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点 rect(x, y, width, height) 绘制一个左上角坐标为（x,y），宽高为width以及height的矩形 Path2D.addPath(path [, transform])​ 添加了一条路径到当前路径（可能添加了一个变换矩阵） fillStyle = color 设置图形的填充颜色 strokeStyle = color 设置图形轮廓的颜色 globalAlpha = transparencyValue 这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0 lineWidth = value 设置线条宽度 lineCap = type 设置线条末端样式(butt，round和square) lineJoin = type 设定线条与线条间接合处的样式(round，bevel和miter) miterLimit = value 限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度 getLineDash() 返回一个包含当前虚线样式，长度为非负偶数的数组 setLineDash(segments) 设置当前虚线样式 lineDashOffset = value 设置虚线样式的起始偏移量 createLinearGradient(x1, y1, x2, y2) createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2) createRadialGradient(x1, y1, r1, x2, y2, r2) createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆 gradient.addColorStop(position, color) addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等） createPattern(image, type) 该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat shadowOffsetX/Y = float shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0 shadowBlur = float shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0 shadowColor = color shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色 fillText(text, x, y [, maxWidth]) 在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的 strokeText(text, x, y [, maxWidth]) 在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的 font = value 当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif textAlign = value 文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start textBaseline = value 基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic direction = value 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit 绘制和使用图片 canvas具有图像操作能力，可以用于动态的图像合成或者作为图像的背景，已经游戏界面等等。 引入图像到canvas需要下面两个操作 1. 获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片 2. 使用drawImage()函数将图片绘制到画布上 可获取图片类型 HTMLImageElement 这些图片是由Image()函数构造出来的，或者任何的 &lt;img&gt; 元素 HTMLVideoElement 用一个HTML的 &lt;video&gt; 元素作为你的图片源，可以从视频中抓取当前帧作为一个图像 HTMLCanvasElement 可以使用另一个 &lt;canvas&gt; 元素作为你的图片源 ImageBitmap 这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成 使用图像 我们可以创建一个新的HTMLImageElement元素，或者直接使用相同页面的图片。如果是其他域的图片，图片需要使用crossOrigin属性，需要图片的服务器允许跨域访问这个图片。 12345var img = new Image(); // 创建img元素img.onload = function(){ // 执行drawImage语句}img.src = 'myImage.png'; // 设置图片源地址 新建的图片中，如果图片还没有加载，我们调用drawImage()什么都不会发生，所以我们的drawImage需要在img.onload里面执行，确保图片加载完毕。 还有一种方法就是通过data:url方式嵌入图片，可以使用base64格式。 使用视频帧 12345678function getMyVideo() { var canvas = document.getElementById('canvas'); if (canvas.getContext) { var ctx = canvas.getContext('2d'); return document.getElementById('myvideo'); }} 绘制图片 我们获取了源图对象，可以使用drawImage方法将它渲染到canvas里。 方法 描述 drawImage(image, x, y) 其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标 drawImage(image, x, y, width, height) 这个方法多了2个参数：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小 drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数最好是参照右边的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。 canvas变形 变形之前，了解两个状态的保存和恢复save()和restore()。 save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。 每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。在做变形之前先保存状态是一个良好的习惯，变形也是相对于整个画板的。 方法 描述 translate(x, y) translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量 rotate(angle) 这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值 scale(x, y) scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有 transform(m11, m12, m21, m22, dx, dy) 这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵 setTransform(m11, m12, m21, m22, dx, dy) 这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。如果任意一个参数是无限大，那么变形矩阵也必须被标记为无限大，否则会抛出异常。从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。 resetTransform() 重置当前变形为单位矩阵 合成和裁切 globalCompositeOperation 属性设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上。 源图像 = 您打算放置到画布上的绘图。 目标图像 = 您已经放置在画布上的绘图。 值 描述 source-over 默认。在目标图像上显示源图像。 source-atop 在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。 source-in 在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。 source-out 在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。 destination-over 在源图像上方显示目标图像。 destination-atop 在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。 destination-in 在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。 destination-out 在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。 lighter 显示源图像 + 目标图像。 copy 显示源图像。忽略目标图像。 xor 使用异或操作对源图像与目标图像进行组合。 裁切路径 clip()裁切路径和普通的 canvas 图形差不多，不同的是它的作用是遮罩，用来隐藏不需要的部分。如右图所示。红边五角星就是裁切路径，所有在路径以外的部分都不会在 canvas 上绘制出来。 canvas动画 首先了解一下，canvas动画的基本步骤： 1. 清空canvas 除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。 保存canvas状态 如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。 绘制动画图形 这一步是重画动画帧。 回复canvas状态 如果已经保存了canvas的状态，可以先恢复它，然会重绘下一帧。 操作动画 实现动画，我们需要一些定时重绘的方法。简单的有两个方法setInterval和setTimeout方法来控制在设定的时间点上执行重绘。 可以用window.setInterval(), window.setTimeout(),和window.requestAnimationFrame()来设定定期执行一个指定函数 setInterval(function, delay) 当设定好间隔时间后，function会定期执行。 setTimeout(function, delay) 在设定好的事件之后执行函数。 requestAnimationFrame(callback) 告诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。 如果不需要和用户互动，可以使用setInterval()方法，它可以定期的执行指定代码。如果我们需要做一个游戏，我们可以使用键盘或者鼠标事件配合setTimeout()方法来实现。通过设置事件监听，我们可以捕捉用户的交互，并执行相应的动作。 window.requestAnimationFrame()实现动画效果。这个方法提供了更加平滑更加有效率的方式来执行动画，当系统准备好了重绘条件的时候，才调用绘制动画帧。一般每秒钟回调函数执行60次，也有可能会被降低。 还有一个window.cancelAnimationFrame()用于取消动画。 像素操作 执行像素操作，我们需要了解一下ImageData对象。 ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性： width 图片宽度，单位是像素 height 图片高度，单位是像素 data Uint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255） data属性返回一个Uint8ClampedArray,它可以被使用作为查看初始像素数据。每个像素用四个1bytes值（按照red，green，blue和alpha），rgba的顺序来排列。 每个部分的颜色值部分用0至255来表示，每个部分被分配到一个数组内连续的索引，左上角像素的红色部分在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。 如要读取，第50行，第200列的像素的蓝色部分，你会写以下代码： 1blueComponent = imageData.data[((50*(imageData.width*4)) + (200*4)) + 2]; 创建一个ImageData对象 去创建一个新的，空白的ImageData对象，你应该会使用createImageData()方法。 12345var myImageData = ctx.createImageData(width, height);// 创建了一个新的具体特定尺寸的ImageData对象。所有像素被预设为透明黑var myImageData = ctx.createImageData(anotherImageData)// 尺寸相同，依旧是透明黑 得到场景像素数据 12// 获取指定区域的画布对象var myImageData = ctx.getImageData(left, top, width, height) 下面看一个颜色选择器的代码 12345678910111213141516171819var img = new Image();img.src = './cat.jpg';var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d');img.onload = function() { ctx.drawImage(img, 0, 0); img.style.display = 'none';};var color = document.getElementById('color');function pick(event) { var x = event.layerX; var y = event.layerY; var pixel = ctx.getImageData(x, y, 1, 1); var data = pixel.data; var rgba = 'rgba(' + data[0] + ',' + data[1] + ',' + data[2] + ',' + (data[3] / 255) + ')'; color.style.background = rgba; color.textContent = rgba;}canvas.addEventListener('mousemove', pick); 在场景中写入数据 可以利用putImageData()方法对场景进行像素数据的写入。 ctx.putImageData(myImageData, dx, dy); dx和dy参数表示你希望在场景内左上角绘制的像素数据得到的设备坐标。 缩放和反锯齿 imageSmoothingEnabled默认是启用的，想要关闭需要添加不同的浏览器前缀来手动关闭。 保存图片 HTMLCanvasElement提供一个toDataURL()方法，此方法在保存图片的时候有用。 方法 描述 canvas.toDataURL('image/png') 默认设定。创建一个PNG图片。 canvas.toDataURL('image/jpeg', quality) 创建一个JPG图片。你可以有选择地提供从0到1的品质量，1表示最好品质，0基本不被辨析但有比较小的文件大小。 canvas.toBlob(callback, type, encoderOptions) 这个创建了一个在画布中的代表图片的Blob对象 性能优化 在离屏canvas上预渲染相似的图形或重复的对象 避免浮点数的坐标点，用整数取而代之 不要在用drawImage时缩放图像 使用多层画布去画一个复杂的场景 用CSS设置大的背景图 用CSS transforms特性缩放画布 使用moz-opaque属性(仅限Gecko) 更多贴士 将画布的函数调用集合到一起（例如，画一条折线，而不要画多条分开的直线） 避免不必要的画布状态改变 渲染画布中的不同点，而非整个新状态 尽可能避免 shadowBlur特性 尽可能避免text rendering 使用不同的办法去清除画布(clearRect() vs. fillRect() vs. 调整canvas大小) 有动画，请使用window.requestAnimationFrame() 而非window.setInterval() 请谨慎使用大型物理库 用JSPerf测试性能","link":"/2018/07/28/canvas%E4%B8%8Esvg%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/"},{"title":"css世界之内联元素&&流的破坏","text":"这一部分总结了两处，一处是内联元素，其实内联元素这里主要让我重新认识了下vertical-align和line-height。另一处就是关于流的破坏，主要就是介绍了下float和absolute这些属性一些知识点了。最后国庆节快乐哈哈。 # 内联元素与流 在内联盒子中，涉及到垂直方向的排版或者对齐，都离不开基线。而字母x的下边缘就是我们的基线（baseline）。 vertical-align: middle对齐为字母x的中心，因为各种字体不同，所以不是绝对的垂直居中。内联元素垂直居中是对文字，而非外部的块级元素。 ex是CSS一个相对单位，指的是小写字母x的高度，就是指x-height。 内联元素的高度 line-height 对于非替换元素的纯内联元素，其可视高度完全由line-height决定。 由于上下半间距的存在，与设计师的文字上下边距的计算一般不同，需要我们重新计算下，文字一般偏下，所以文字下边距向上取整，文字上边距向上取整。在有内联替换元素的时候，line-height不能影响替换元素的高度，内联替换元素和内联元素混排的的时候。line-height只能决定行高的最小高度。 line-height让内联元素“垂直居中” 要让单行文字垂直居中，其实不用设置height，只需要设置好line-height的高度就好了。 多行文字居中的话也有办法，嵌套的div，使用inline-block来表示。 1234567891011.box { line-height: 120px; background: #f0f3f9;}.content { display: inline-block; line-height: 20px; margin: 0 20px; vertical-align: middle;} 为什么上面的代码能垂直居中呢，全凭内联盒子前面那个宽度为0的“幽灵空白节点”。 line-height的属性值 line-height: normal是默认值。不同字体下的line-height的属性值normal计算量都是不一样的： 字体 Chrome Firefox IE 微软雅黑 1.32 1.321 1.32 宋体 1.141 1.142 1.141 line-height有三种计算方式： 1. 数值。如line-height: 1.5，与当前font-size相乘后的值。 百分比值。如line-height: 150%，与当前font-size相乘后的值。 长度值。如line-height:21px或者者 line-height:1.5em。 使用数值的计算，和其他两种方式在继承方面有所不同。使用数值的话，那么所有的子元素继承的都是这个值；使用百分比值或者长度值作为属性值，所有 的子元素继承的是最终的计算值。 这里推荐的继承设置： 1234567body { line-height: 1.5;}input, button { line-height: inherit;} 内联元素line-height的“大值特性” 12345678910111213141516.box { line-height: 96px;}.box span { line-height: 20px;}/* 另一个 */.box { line-height: 20px;}.box span { line-height: 96px;} 一个子元素的行高是20px，一个是96px，假如一行文字，.box元素的高度是多少。答案是都是96px。 原因是，里层96px直接撑开，外层96px，“幽灵空白节点”继承96px，最终撑开。设置独立的inline-block避免“幽灵空白节点”影响。 vertical-align 首先要知道，line-height的高度并不是元素的最终高度。 vertical-align分为下面四大类： 线类，如baseline、top、middle、bottom。 文本类，如text-top、text-bottom。 上标下标类，如sub、super。 数值百分比。如20px、2em、20%等。 默认是baseline，如果设置10px这样，就会往baseline往上偏移10px。负值设置则是往下偏移。 vertical-align作用的前提 verticl-align作用的前提是，只能应用于内联元素以及display值为table-cell的元素。 这里举一个图片的vertical-align没有效果的例子。 123456789101112131415161718192021/* 无效果 */.box { height: 128px;}.box &gt; img { height: 96px; vertical-align: middle;}/* 设置line-height */.box { height: 128px; line-height: 128px;}.box &gt; img { height: 96px; vertical-align: middle;} vertical-align和line-height 阐述一下容器高度不等于行高的例子 1234567.box { line-height: 32px;}.box &gt; span { font-size: 24px;} 因为“幽灵空白节点”的字体大小不等于span，所以字号不一样的参差位移导致的。如果在父元素设置好字体大小和子元素一样就不会有这样的情况啦。 图片底部存在间隙也是“幽灵空白节点”、line-height和vertical-align共同导致的。解决方法： 图片块状化。 容器line-height足够小。 容器font-size足够小。 图片设置其他vertical-align属性值。 关于图片的margin-top: -200无效这样的效果，原因是“幽灵空白节点”因为默认的vertical-align: baseline固定死在父级容器内。 vertical-align线性类属性值 inline-block与baseline vertical-align 属性的默认值 baseline 在文本之类的内联元素那里就是字符 x 的下边缘，对于替换元素则是替换元素的下边缘。但是，如果是 inline-block 元素，则规则要复杂了：一个 inline-block 元素，如果里面没有内联元素，或者 overflow 不是 visible，则该元素的基线就是其 margin 底边缘；否则其基线就是元素里面最后一行内联元素的基线。 inline-block和baseline的利用，删除icon，&lt;i class=\"icon-delete\"&gt;删除&lt;/i&gt;和&lt;i class=\"icon-delete\"&gt;&lt;/i&gt;这里面一个有文字，一个没文字,由于有文字的一般设置为overflow：hidden但是他们的元素基线都是margin底边缘。下面是小技巧，将inline-block和文字对齐。 图标高度和行高一样。一般设定一个固定的宽高。 图标标签里面永远有字符。可以借助::before或者::after伪元素生成一个空格字符串。 图标CSS不使用overflow: hidden保证基线为里面字符的基线，但是要让里面潜在的字符不可见。 流的破坏与保护 float float的特性： * 包裹性。 * 块状化并格式化上下文。 * 破坏文档流。 * 没有任何margin合并。 元素设置float，会让父元素坍塌。使用浮动元素的时候，最好采用采用一些手段干净地清除浮动带来的影响。 float的克星clear 语法如下： clear: none | left | right | both clear的官方解释是“元素盒子的边不能和前面的浮动元素相邻”。 none: 默认值，左右浮动都有。 left: 左侧康浮动。 right: 右侧抗浮动。 both: 两侧抗浮动。 一般使用，clear: both。clear: both的本质是让自己不和float元素在一行显示，并不是真正意义上的清除浮动。 如果clear: both元素前面的元素就是float元素，则margin-top负值即使设置-9999px也没有效果。 clear: both 后面的元素一九可能发生文字环绕的现象。 BFC BFC全称block formatting context，中文是“块级格式化上下文”。与之对应的还有IFC，“内联格式化上下文”。 触发BFC的条件： &lt;html&gt;根元素。 float的值不为none。 overflow的值auto、scroll或hidden。 display的值table-cell、table-caption和inline-block中任何一个。 position的值不为relative和static。 BFC特点是及最重要用途是，实现更健壮、更智能的自适应布局。而不仅仅是去margin和清除float影响。 BFC的表现规则是，具有BFC特性的元素的子元素不会受外部元素影响，也不会影响外部元素。 overflow 最适合产生BFC的属性就是overflow: hidden。当子元素内容超出容器高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。 介绍下overflow属性经典的不兼容问题。在chrome浏览器下，如果浏览器能滚动（假设是垂直滚动），则padding-bottom也算在滚动尺寸内，IE和Firefox浏览器忽略padding-bottom。 overflow-x和overflow-y visible：默认值。 hidden：剪裁。 scroll：滚动条区域一直在。 auto：不足以滚动时没有滚动条，可以滚动时滚动条出现。 关于overflow-x和overflow-y的设置，如果一个值设置visible而另一个值设置为scroll、auto和hidden，则visible会当成auto来解析。但是scroll、auto和hidden可以共存。 PC端的默认滚动条来自&lt;html&gt;，而不是&lt;body&gt;标签，移动端就不是这样啦。 PC端滚动条会占用容器的可用宽度和高度。移动端滚动条一般是悬浮的就不会。 overflow与锚点定位 下面两种情况可以触发锚点定位: 锚点定位行为触发条件 URL地址中的锚链与锚点元素对应并有交互行为。 可focus的锚点元素处于focus状态。 锚点定位作用的本质 锚点定位作用的发生，本质上是通过改变容器滚动高度或者宽度来实现的。 锚点定位可以发生在普通元素，而且定位行为的发生是由内而外的。“由内而外”指的是，普通元素和窗体同时可滚动的时候，会由内而外触发所有可滚动窗体的锚点定位行为。 设置overflow: hidden的元素也是可以滚动的，只是没有滚动条，如内部的scrollTop依旧可以使用。 position: absolute 当一个元素同时拥有absolute和float的时候，float属性没有任何效果。具有块状话，一旦设置了absolute或者fixed，其元素display就变成block。 关于元素的宽度的详细计算规则： 根元素（很对场景下可以看成&lt;html&gt;）被称为“初始包含块”，其尺寸等于浏览器可视窗口的大小。 对于其它元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box边界形成。 如果元素position: fixed，则包含块是“初始包含块”。 如果元素的position: absolute，则“包含块”由最近的position不为static的祖先元素建立。 如果该祖先元素是纯inline元素，则规则略复杂： 假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包围盒就是内联元素的“包围块”。 如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范没有明确定义，浏览器自行发挥。 与常规元素相比，absolute绝对定位元素的“包含块”有以下3个差异 1. 内联元素也可以作为“包含块”所在的元素。 2. “包含块”所在的元素不是父级块元素，而是最近position不为static的祖先元素或者根元素。 3. 边界是padding box而不是content box。 内联元素一般不做“包含块”。 1. 一般使用absolute绝对定位都适合布局有关，而内联元素主要是图文展示。 理解和学习成本高。内联元素的“包含块”不能按照常规块级元素的“包含块”来理解。 兼容性问题。无论内联元素是单行还是跨行都存在兼容性问题。单行的兼容性问题存在于“包含块”是一个空的内联元素的时候。 提示信息一行使用absolute定位的时候，利用white-space: nowrap让信息单行显示。 具有相对特性的无依赖absolute绝对定位 absolute是非常独立的CSS属性，其样式和行为表现不依赖其他任何CSS属性就可以完成。 absolute定位效果完全不需要父元素设置position为relative或者其他属性就能实现。这种情况下，子元素也不要设置left/top/right/bottom的属性值。其实这种“无依赖绝对定位”本质上就是“相对定位”，仅仅是不占据CSS流的尺寸空间而已。 简单的例子 图标的的定位 超越常规布局的排版 下拉列表的定位 12345678910.datalist { position: absolute;}.search-result { display: none;}input:focus ~ .search-result { display: block;} 虽然“无依赖绝对定位”好处多多，但建议只用在静态交互效果上，比方说，导航二级菜单的显示与定位。如果是动态呈现的列表，建议还是使用 JavaScript 来计算和定位。 absolute与overflow overflow与absolute元素的裁剪规则用一句话表述就是：绝对定位元素不总是被父级 overflow 属性剪裁，尤其当 overflow 在绝对定位元素及其包含块之间的时候。 转述就是：如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute元素经行剪裁。 12345678910111213141516171819&lt;!-- 不会剪裁 --&gt;&lt;div style=\"overflow: hidden;\"&gt; &lt;img src=\"1.jpg\" style=\"position: absolute;\"&gt;&lt;/div&gt;&lt;div style=\"position: relative;\"&gt; &lt;div style=\"overflow: hidden;\"&gt; &lt;img src=\"1.jpg\" style=\"position: absolute;\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 会剪裁 --&gt;&lt;div style=\"overflow: hidden; position: relative;\"&gt; &lt;img src=\"1.jpg\" style=\"position: absolute;\"&gt;&lt;/div&gt;&lt;div style=\"overflow: hidden;\"&gt; &lt;div style=\"position: relative;\"&gt; &lt;img src=\"1.jpg\" style=\"position: absolute;\"&gt; &lt;!-- 剪裁 --&gt; &lt;/div&gt;&lt;/div&gt; 当元素出现transform属性的时候，近似于添加了“定位元素”。所以需要检查，absolute元素是否会被剪裁，fixed定位失效。 absolute与clip CSS 世界中有些属性或者特性必须和其他属性一起使用才有效，比如clip。 clip: rect(top, right, bottom, left)表示据每个边缘的距离开始剪裁。作用有： fixed固定定位的剪裁。 最佳可访问性隐藏。例如隐藏一些文字之类的。 clip 隐藏仅仅是决定了哪部分是可见的，非可见部分无法响应点击事件等；然后，虽然视觉上隐藏，但是元素的尺寸依然是原本的尺寸，在 IE 浏览器和 Firefox 浏览器下抹掉了不可见区域尺寸对布局的影响，Chrome 浏览器却保留了。 absolute流体特性 绝对定位元素在“对立方向同时发生定位的时候”。 当绝对定位元素处于流体状态的时候，各个盒模型相关属性的解析和普通流体元素都是一模一样的，margin 负值可以让元素的尺寸更大，并且可以使用 margin:auto 让绝对定位元素保持居中。 123456.element { width: 300px; height: 200px; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto;} position: relative relative的定位有两点值得一提： * 相对定位元素的left/top/right/bottom的百分比计算值是相对包含块计算的，而不是本身。所以如果包含块的高度是auto，那么计算值是0，便宜无效。 * 相对元素同时应用对立方向定位值的时候，按照默认文档流，自上而下、从左往右，top 、left作用大。 relative最小化影响原则 尽量不适用relative，想定位某些元素，首先看能否使用“无依赖的绝对定位”。 如果场景受限，一定要使用relative，则该relative务必最小化。 原因有，一个普通元素变成相对定位元素，元素的层叠顺序提高了。“relative 的最小化影响原则”不仅规避了复杂场景可能出现样式问题的隐患，从日后的维护角度讲也更方便。 position: fixed固定定位 position:fixed 固定定位元素的“包含块”是根元素，我们可以将其近似看成&lt;html&gt;元素。","link":"/2018/10/01/css%E4%B8%96%E7%95%8C%E4%B9%8B%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0-%E6%B5%81%E7%9A%84%E7%A0%B4%E5%9D%8F/"},{"title":"css世界之层叠规则","text":"这是关于css世界我总结的最后一篇。层叠规则 # z-index只是一小部分 CSS世界中，z-index属性只有和定位元素（position不为static的元素）在一起的时候才有作用，可以是正数也可以是负数。在CSS3中，flex盒子的子元素也可以设置z-index属性。 理解层叠上下文和层叠水平 层叠上下文，英文称作stacking context，是HTML中的一个三维概念。 位于最下面的 background/border 特指层叠上下文元素的边框和背景色。每一个层叠顺序规则仅适用于当前层叠上下文元素的小世界。 inline 水平盒子指的是包括 inline/inline-block/inline-table 元素的“层叠顺序”，它们都是同等级别的。 单纯从层叠水平上看，实际上 z-index:0 和 z-index:auto 是可以看成是一样的。注意这里的措辞—“单纯从层叠水平上看”，实际上，两者在层叠上下文领域有着根本性的差异。 层叠准则 谁大谁上：当具有明显的层叠水平标识的时候，如生效的 z-index 属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。 后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。 层叠上下文特性 层叠上下文的层叠水平要比普通元素高。 层叠上下文可以阻断元素的混合模式。 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。 每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。 每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。 层叠上下文的创建 天生派: 页面根元素天生具有层叠上下文，称之为根层叠上下文。 正统派: z-index值为数值的定位元素的传统“层叠上下文”。 对于 position 值为 relative/absolute 以及 Firefox/IE 浏览器（不包括 Chrome 浏览器）下含有 position:fixed 声明的定位元素，当其 z-index 值不是 auto 的时候，会创建层叠上下文。需要注意下，当两个相邻div的z-index为auto，将直接比较里面元素的z-index，当两个相邻div的层级都为相同数值的时候，父级的层级“后来居上”。Chrome 等 WebKit 内核浏览器下，position:fixed 元素天然层叠上下文元素，无须 z-index为数值。 扩招派: 其他CSS3属性。 元素为 flex 布局元素（父元素 display:flex|inline-flex），同时 z-index值不是 auto。 元素的 opacity 值不是 1。 元素的 transform 值不是 none。 元素 mix-blend-mode 值不是 normal。 元素的 filter 值不是 none。 元素的 isolation 值是 isolate。 元素的 will-change 属性值为上面 2～6 的任意一个（如 will-change:opacity、will-chang:transform 等）。 元素的-webkit-overflow-scrolling 设为 touch。 z-index“不犯2”准则 对于非浮层元素，避免设置z-index值，z-index值没有任何道理需要超过2。 定位元素一旦设置z-index值，就从普通定位元素变成了层叠上下文元素，相互间的层叠顺序就发生了根本的变化，很容易出现设置了巨大的 z-index 值也无法覆盖其他元素的问题。 避免 z-index“一山比一山高”的样式混乱问题。","link":"/2018/10/02/css%E4%B8%96%E7%95%8C%E4%B9%8B%E5%B1%82%E5%8F%A0%E8%A7%84%E5%88%99/"},{"title":"css世界之流体布局","text":"这将会把看到的css世界里面的知识点提取出来，可能会有5到6篇文章来做总结。 这是第一篇文章，css世界之流体布局。 # 文档流 想要了解文档流，我们需要关注普通元素默认的布局是怎样的。 在MDN中normal flow章节中有所描述。 单个元素我们需要关注于它们的盒子模型，首先获取元素的content，然后是它们的padding，最后是border和margin。 默认来说，块级元素的content是父级元素宽度的100%，高度是元素content的高度。内联元素的高度是content的高度，宽度也是content的宽度。你不能直接设置一个内联元素的高度或者宽度，内联元素的高度仅仅是坐落在块级元素的内容中。如果你想要控制内联元素的高度和宽度，你需要将它们设置为 display: block; 或 display: inline-block; 上面解释了单个元素。如果有多个元素，他们会怎么交互呢？在正常的浏览器布局中，默认来说，块级元素会根据文档的书写方式有关。每一个块级元素将会占据一个新行，他们还会根据所设置的margin值来分离。在英语中，或者其他水平，自上而下的书写的语言中，块级元素会根据垂直布局。 内联元素的表现方式就有所不同，它们不会在新的一行出现，它们会在同一行一个接一个的排列，直到它们的长度超过父级元素的宽度就会换行。 width或height作用的具体细节 由于块级元素的流体特性主要体现在水平上，所以首先讨论的就是宽度。 width: auto width的默认值就是auto。它有以下四种表现： 充分利用可用空间。常见就是&lt;div&gt;&lt;p&gt;元素宽度是100%默认于父级容器的。 收缩于包裹。常见于浮动、绝对定位、inline-block元素或table元素。 收缩到最小。常见于table-layout为auto的表格中。 超出容器限制。上面三种元素都不会使元素超出容器宽度，除非设置了white-space: nowrap。 上述四种宽度情况中，除了第一种是由外部尺寸确定的宽度，其他都是内部尺寸决定的宽度。 外部尺寸与流体特性 正常流宽度。宽度会自动填充满父级容器。 格式化宽度。出现在‘绝对定位模型中’，也就是position为 absolute 和 fixed 元素中， 对于非替换元素，当left/right或者top/bottom对立方位的属性值同时存在的时候，元素的宽度表现为格式化宽度。同样的设置了宽度就会破坏了这种流体性。 内部尺寸与流体特性 这里我仅仅记录了一个关于包裹性的利用，页面中某个文字内容是动态的，可能是几个字或多很多字，几个字的时候居中显示，多个字的时候居左显示。 12345678.box { text-align: center;}.content { display: inline-block; text-align: left;} height: auto 如果父级元素的高度是100%，那么只要子元素在文档流之中，其百分比值完全被忽略。为什么高度的百分比计算会被忽略呢。在w3c规范中在就给出了答案，如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为 auto 。父级容器的高度解释为了auto自然没法与百分比相乘了。 如何让元素支持height: 100% 设定显式的高度值。给html和body设定100%也是也可以的。 使用绝对定位。绝对元素的宽高百分比计算是相对于 padding box 计算的，非绝对定位的高度百分比计算则是相对于 content box 计算的。 css min-width/max-width和min-height/max-height 下面简述一下min/max-width/height与width和height的不一样的地方。 关于初始值 既然是总结，直接放出来好了，max-*的初始值是none，min-*的初始值是auto。 覆盖规则 当max-width小于width设置的时候，即使width加上了!important也没有用，max-width大于width的设置。 当min-width大于max-width的时候，会以min-width为准则。 根据覆盖原则，我们可以实现任意高度的展开收起技术。由于设置height为auto无法计算值，过渡和动画效果也无法完成。所以我们可以利用max-height实现。 123456789.element { max-height: 0; overflow: hidden; transition: max-height .25s;}.element.active { max-height: 666px; /* 一个足够大的最大高度值 */} 内联盒模型和幽灵空白节点 内联盒模型的简易版 内容区域。内容区域指一种围绕文字看不见的盒子，可以理解为em盒。 内联盒子。“内联盒子”不会让内容成块显示，而是排成一行。需要注意的是一段单独的文本不一定是“匿名内联盒子”，还有可能是“匿名块级盒子”，主要是看其前后标签是内联还是块级。 行框盒子。每一行就是一个行框盒子，每个行框盒子又是一个一个“内联盒子”组成的。 包含盒子。又称包含块，包括父级标签。 幽灵空白节点 “幽灵空白节点”是内联盒子模型的一个非常重要的概念。具体指，在HTML5的文档声明中，内联元素的所有解析盒渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个节点永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但是又确确实实存在。","link":"/2018/09/23/css%E4%B8%96%E7%95%8C%E4%B9%8B%E6%B5%81%E4%BD%93%E5%B8%83%E5%B1%80/"},{"title":"css世界之盒子模型","text":"这是这个总结系列的第二篇文章，关于content、padding、margin、border的。 # content 什么是替换元素 简单的来说，通过修改某个属性值，呈现的内容就可以被替换的元素就称之为替换元素。 内容的外观不受页面的css影响。也就是说样式表现在css作用域之外，如何修改替换元素本身的外观呢。需要利用浏览器提供行的一些样式接口，如：::-ms-check{}，直接修改样式是不起作用的。 有自己的尺寸。很多替换元素在没有明确尺寸的时候，其默认尺寸（不包括边框）为300像素×150像素。 很多css属性有自己的一套表现方式。比如vertical-align属性，对于非替换内联元素来说，其一般是字符x的下边缘，而对于替换元素来说，一般来说是元素的下边缘。 替换元素的display值 替换元素都是内联元素，但是它们的display值却是有所不同。 元素 Chrome Firefox IE &lt;img&gt; inline inline inline &lt;iframe&gt; inline inline inline &lt;video&gt; inline inline inline &lt;select&gt; inline-block inline-block inline-block &lt;input&gt; inline-block inline inline-block range(or)file &lt;input&gt; inline-block inline-block inline-block hidden &lt;input&gt; none none none &lt;button&gt; inline-block inline-block inline-block &lt;video&gt; inline-block inline inline-block 替换元素的尺寸计算规则 固有尺寸。这个固有尺寸指的是替换内容的原本尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。这个宽度和高度的大小就是“固有尺寸”。 HTML尺寸。“HTML尺寸”只能通过HTML原生属性改变，这些原生属性包括&lt;img&gt;的width和height属性、&lt;input&gt;的size属性、&lt;textarea&gt;的cols和rows属性等。 CSS尺寸特指可以通过CSS的width和height。 css尺寸 &gt; HTML尺寸 &gt; 固有尺寸。即使替换元素设置display: block，尺寸规则仍然和内联状态一样，这也是为什么图片或者其他表单元素设置display:block却没有达到100%容器的原因。 如果一个图片没有src，那么其将不会有网络请求，这一点可以用在图片懒加载上面。而在Firefox中，这种没有src的img元素将会表现为一个普通的内联元素，所以宽高设置无效，所以需要将其设置为display: inline-block。 关于图片的width和height设置，影响图片的方式。图片的默认填充方式是fill，也就是说，你说设置的宽度和高度都会被默认填充满，所以尺寸的变化，改变的不是图片的固有尺寸，只是改变了图片填充的外部尺寸。CSS3中，替换元素的适配方式，可以通过object-fit来修改。 替换元素和非替换元素的区别 观点1： 替换元素和非替换元素之间只隔了一个src属性。 这里举了一个小例子，利用到了伪元素的图片生成技术。 不能有src属性（证明观点所在） 不能使用content属性生成图片（针对Chrome） 需要有alt属性并有值（针对Chrome） Firefox下::before伪元素的content值会被无视，::after不会发生这种问题。 这里有一个展示的链接，http://demo.cssworld.cn/4/1-2.php 。这里可以演示图片没加载成功的时候，hover提示图片信息的技术。 观点2：替换元素和非替换元素之间只隔了一个CSS content 属性 替换元素之可替换的部分是content box，对应css属性是content。所以从理论来说content熟悉决定了是替换元素或者非替换元素。直接添加了content属性的元素我们可以称之为“匿名替换元素”。 在MDN中对于content的介绍中，也直接说明了使用content 属性插入的内容都是匿名的可替换元素。 关于content的利用，这里放一个三个点动态加载以及counter()。计数器可以说也主要是生成文档的时候来用一下。最后最后，content能够混合的，也就是像这种形式content: \"(\" attr(href) \")\"。 padding 奇怪的首选最小宽度 关于padding里面有几个点需要注意的，即使设置了box-sizing: border-box，当padding计算值大于width时，width也会无效，最终宽度呈现为padding计算值，内容则表现为“首选最小宽度”。而且加了文字也不会变，一般来说是0吧。 内联元素的padding 内联元素的padding，会发生层叠，就是说，对上下元素的原本布局没有任何影响，却发生了层叠。 css中有很多不影响其他元素布局的层叠现象。如，relative元素的定位、盒阴影box-shadow以及outline等。 纯视觉层叠。不影响外部尺寸，如box-shadow以及outline等。 会影响视觉的层叠。inline元素的padding就是这种。 区分的方式也很简单，如果父容器设置为overflow: auto，层叠区域超出父元素的时候，没有滚动条出现，则是纯视觉的；如果有滚动条出现，则会影响尺寸，影响布局。 内联padding的一点小应用 利用内联padding实现高度可控的“管道分隔符” 查看链接 1234567a + a::before { content: ''; font-size: 0; padding: 10px 3px 1px; margin-left: 6px; border-left: 1px solid gray;} padding的百分比值及应用 块级元素的话，有一个纯css实现宽高5:1的头图， 效果图 123456789101112.box { padding: 10% 50%; position: relative;}.box &gt; img { position: absolute; width: 100%; height: 100%; left: 0; top: 0;} 这里在讨论一下内联元素的padding百分比。 同样的相对宽度计算。 默认的高度和宽度细节有差异。 padding会断行。 内联元素的padding首先计算的是左边，那么左边的长度够了的话，元素就会换行，换行之后，新的padding会形成背景，如果是背景色不是transparent的话，就会根据先来后到的产生层叠现象，而且层叠等级比较高。会产生相应的奇怪的现象，一般的开发过程中，遇到这种情况的概率比较小。 空白的内联元素的表现也会有不同的表现，因为内联元素前面有一个宽度为0高度自适应的“幽灵空白节点元素”，所以，设置padding: 50%最终的变现为一个长方形，这种现象，在我们知道了“幽灵空白节点元素”的存在就不会显得那么难以理解了。 padding与图形绘制 padding属性和background-clip属性配合，可以在有限的标签下实现一些css图形绘制效果。 不使用伪元素，仅一层标签实现菜单图标。下面是十倍大小模拟。 双层圆心选中效果也可以直接模拟。 123456789101112131415161718192021.icon-menu { display: inline-block; width: 140px; height: 10px; padding: 35px 0; border-top: 10px solid; border-bottom: 10px solid; background-color: currentColor; background-clip: content-box;}.icon-dot { display: inline-block; width: 100px; height: 100px; padding: 10px; border: 10px solid; border-radius: 50%; background-color: currentColor; background-clip: content-box;} 效果图 margin 元素尺寸的相关概念 元素尺寸：对应jQuery的$().outerWidth()和$().outerHeight()方法，是元素的border box尺寸。在原生DOM API中写作offsetWidth和offsetHeight，所以有时也称作“元素偏移尺寸”。 元素内部尺寸：对应jQuery的$().innerWidth()和$().innerHeight()，就是元素的padding box的尺寸。在原生DOM API中写作clientWidth和clientHeight。 元素外部尺寸：对应jQuery的$().outerWidth(true)和$(true).outerHeight(true)，是元素的margin box的尺寸。原生DOM API中没有对应的。 当元素的尺寸表现为充分利用可利用空间的时候，margin会影响元素的尺寸。对于普通流体元素，margin只能改变元素水平方向尺寸。对于具有可拉伸的绝对定位元素，则水平和垂直方向都可以。 margin合并 margin合并的三种场景： 相邻兄弟元素margin合并。 父级和第一个、最后一个子元素。 空块级元素的margin合并。块级元素为空，上下margin会合并。 margin合并规则，“正正取最大”“正负相加”“负负取最负”。 margin合并的意义主要是为了文档的展示，即css2的主要内容。 v ## margin: auto 平分规则： 如果一侧定值，一侧为auto，则auto为剩余空间大小。 如果两侧均是auto，则平分剩余空间。 这里让某个元素右对齐就可以用，margin-left：auto这个属性啦。 这里介绍一下水平垂直同时居中的一个方法。容器尺寸固定且，position: relative。 12345678910.son { position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 200px; height: 100px; margin: auto;} 在这种格式化的流体布局中，margin的自动分配剩余空间就起作用啦，所以最后会垂直水平居中。 margin无效情况 display计算值为inline的非替换元素的垂直margin是无效的。对于内联替换元素的垂直margin有效。 表格的 和 元素设置display值是table-cell或table-row的margin无效。如果计算值是tab-caption、inline-table，可以通过margin控制外边距，甚至::first-letter伪元素也可以解析margin。 margin合并时候，margin小于合并值设置无效。 绝对定位元素非定位方位的margin值“无效”。绝对定位元素无法影响兄弟元素，所以看起来无效。 定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。正常流的情况下，margin-top和margin-left有效，而margin-bottom和margin-right则会无效。虽然有，但是影响不到自己，只会影响兄弟元素的定位。 float鞭长莫及的margin。float: right和margin-right: 20px这里20px小于元素的宽度的时候，就会无效。 内联特性导致的margin无效。 border border和padding与margin不同，border-width不支持百分比的数值。border相当于盒子的宽度，包装盒哪里有根据内部容器变大的情况呢。其他诸如outline、box-shadow、text-shadow等都是不支持百分比的数值的。 border-width还支持若干关键字。thin、medium、thick等。 border-style有几个点，关于border-style: none为默认值。border-style: double表现规则记录一下：双线宽度永远相等，中间间隔±1。 借助border也能实现菜单menu啦。 123456.icon { width: 120px; height: 20px; border-top: 60px double; border-bottom: 20px solid;} border三角形绘制。 等腰三角形的绘制： 12345div { width: 0; border: 10px solid; border-color: #f30 transparent transparent;} 首先我们需要知道border的绘制过程： 123456div { width: 100px; height: 100px; border: 100px solid; border-color: #f30 #00f #396 #0f0;} 所以其他三边透明和宽高为0的等宽三角想也就出来了： 12345678910111213141516/* 梯形 */div { width: 100px; height: 100px; border: 100px solid; border-color: #f30 transparent transparent;}/* 三角形 */div { width: 0; border: 100px solid; border-color: #f30 transparent transparent;} 其他一些其他的三角形利用，则是利用两个倾斜度不同的三角形叠加。","link":"/2018/09/27/css%E4%B8%96%E7%95%8C%E4%B9%8B%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"},{"title":"css揭秘总结(四)","text":"主要是CSS揭秘的最后一章，过渡与动画。 # 过渡和动画 ## 42. 缓动效果 &gt; 背景知识：基本的 CSS 过渡，基本的 CSS 动画 难题 给过渡和动画加上缓动效果（比如具有回弹效果的过渡过程）是一种流行的表现手法，可以让界面显得更加生动和真实：在现实世界中，物体从 A点到 B 点的移动往往不是完全匀速的。所以我们主要要讨论的就是回弹效果。这里主要要讲的就是贝塞尔曲线。 常见需要回弹的效果体验： * 尺寸变化（比如：元素在 :hover 时变大，弹出框从 transform:scale(0) 的状态开始放大显示，柱状图中的每根柱子动态地冒出来，等等） * 角度变化（比如：元素的旋转动作，饼图中的各个扇区以动画的方式从 0°开始展开为实际大小，等等） 弹跳动画 常见的内置缓动曲线： ease-out 是 ease-in 是反向版本。这一对组合正好是实现回弹效果所需要的：每当小球的运动方向相反时，我们希望调速函数也是相反的。 123456789101112@keyframes bounce { 60%, 80%, to { transform: translateY(400px); animation-timing-function: ease-out; } 70% { transform: translateY(300px); } 90% { transform: translateY(360px); }}.ball { /* 其余样式写在这里 */ animation: bounce 3s ease-in;} cubic-bezier() 函数 把控制锚点的水平坐标和垂直坐标互换，就可以得到任何调速函数的反向版本。 cubic-bezier.com 弹性过渡 假设有一个文本输入框，每当它被聚焦时，都需要展示一个提示框。 如果我们需要一个文本框先慢慢扩大至1.1倍，再回弹至1倍，那么收缩的时候，会有一个scale(-0.1)的收缩，而不是scale(1.1)。 这里我们需要单独设置，盖 transition-duration,可以用 transition 这个简写属性来覆盖所有的值，就不需要显式指定 ease，因为它本来就是初始值。再指定一下transition-property就可以了。 12345678input:not(:focus) + .callout { transform: scale(0); transition: .25s transform;}.callout { transform-origin: 1.4em -.4em; transition: .5s cubic-bezier(.25,.1,.3,1.5) transform;} 43. 逐帧动画 在很多时候，我们需要一个很难（或不可能）只通过某些 CSS 属性的过渡来实现的动画。比如一段卡通影片，或是一个复杂的进度指示框。在这种场景下，基于图片的逐帧动画才是完美的选择；不过想在网页中以一种灵活的方式来实现这种动画，可谓是一项惊人的挑战。 GIF动画短板 GIF 图片的所能使用的颜色数量被限制在 256 色。 GIF 不具备 Alpha 透明的特性。当我们不确定 GIF 动画的下层是什么时，这往往是一个大问题。 我们无法在 CSS 层面修改动画的某些参数，比如动画的持续时间、循环次数、是否暂停等。 2004 年，Mozilla 发起了一个建议：在 PNG 格式中增加对逐帧动画的支持，就像 GIF 格式同时支持静态图像和动画一样。这种格式被称作APNG。 解决方案 假设我们已经把动画中的所有帧全部拼合到一张 PNG 图片中了，如图: 动画平滑特性恰恰毁掉了我们想实现的逐帧动画效果。此时我们需要steps() ： 1&lt;div class=\"loader\"&gt;Loading...&lt;/div&gt; 123456789101112@keyframes loader { to { background-position: -800px 0; }}.loader { width: 100px; height: 100px; background: url(img/loader.png) 0 0; animation: loader 1s infinite steps(8); /* 把文本隐藏起来 */ text-indent: 200%; white-space: nowrap; overflow: hidden;} 44. 闪烁效果 背景知识：基本的 CSS 动画，“逐帧动画” 难题 就是通过数次闪烁（不超过三次）来提示用户界面中有某处发生了变化，或者用来凸显出当前链接的目标。 解决方案 50%循环动画 ， 将动画的起点，调整到50%来避免生硬的跳转。 1234@keyframes blink-smooth { 50% { color: transparent } }.highlight { animation: 1s blink-smooth 3;} alternate动画（alternate-reverse动画） 1234@keyframes blink-smooth { to { color: transparent } }.highlight { animation: .5s blink-smooth 6 alternate;} 普通闪烁效果 steps(1)本质上等同于 steps(1, end)。如果直接从0开始跳转，那么感觉就是没有任何效果。颜色值的切换只会发生在动画周期的末尾。因此，我们会看到起始值贯穿于整个动画周期，而终止值只在动画结尾的无限短的时间点处出现。 唯一的解决方案是调整动画的关键帧，让切换动作发生在 50% 处。 1234@keyframes blink { 50% { color: transparent } }.highlight { animation: 1s blink 3 steps(1); /* 或用step-end */} 45. 打字动画 背景知识：基本的 CSS 动画，“逐帧动画”，“闪烁效果” 难题 有些时候，我们希望一段文本中的字符逐个显现，模拟出一种打字的效果。这个效果在技术类网站中尤为流行，用等宽字体可以营造出一种终端命令行的感觉。 解决方案 核心思路就是让容器的宽度成为动画的主体：把所有文本包裹在这个容器中，然后让它的宽度从 0 开始以步进动画的方式、一个字一个字地扩张到它应有的宽度。你可能已经察觉到了，这个方法是有局限的：它并不适用于多行文本 。然而幸运的是，在绝大多数情况下，我们把这种效果应用在类似标题的单行文本上。 另外一件需要注意的事情是，动画的持续时间越长，动画效果越差：持续时间较短的动画会让界面显得更加精致，在某些场景下还是有益于可用性的。反之，动画的持续时间越长，越容易让用户感到厌烦。因此，即使这个技巧可以用在大段文本身上，也不一定是个好主意。 中间需要解决的问题有： * 宽度的变化需要steps，所以steps()来修复。 * 我们已经用 em 单位指定了宽度，虽然它比像素单位要好一些，但仍然不够理想。通过 ch 单位来缓解。取值就是字符的数量。 123456789@keyframes typing { from { width: 0; }}h1 { width: 15ch; /* 文本的宽度 */ overflow: hidden; white-space: nowrap; animation: typing 6s steps(15);} 最后添加上一个闪烁的光标 1234567891011121314@keyframes typing { from { width: 0 }}@keyframes caret { 50% { border-color: transparent; }}h1 { width: 15ch; /* 文本的宽度 */ overflow: hidden; white-space: nowrap; border-right: .05em solid; animation: typing 6s steps(15), caret 1s steps(1) infinite;} 46. 状态平滑的动画 背景知识: 基本的 CSS 动画，animation-direction（在“闪烁效果”中曾简要提及） 不是所有动画都是在页面一加载好就立即播放的。更常见的情况是，我们想通过动画来响应用户的动作，比如用户的鼠标悬停在某个元素上（:hover），或者按住鼠标（:active），等等。在这种场景下，我们将无法控制动画实际的循环次数，因为用户的动作会随时中断动画，而此时动画不可能刚好插放到我们事先指定的循环次数。举例来说，用户的鼠标可能会触发一个华丽的:hover 动画，而在动画还没有播完的时候，鼠标就从元素上移走了。在这种情况下，你觉得动画会如何收场呢？ animation-play-state 暂停和继续一个一直存在的动画，重要的属性。 12animation-play-state: paused;animation-play-state: running; 沿环形路径平移的动画 背景知识：CSS 动画，CSS 变形，“平行四边形”，“菱形图片”，“闪烁效果” 难题 123&lt;div class=\"path\"&gt; &lt;img src=\"lea.jpg\" class=\"avatar\" /&gt;&lt;/div&gt; 1234567@keyframes spin { to { transform: rotate(1turn); }}.avatar { animation: spin 3s infinite linear; transform-origin: 50% 150px; /* 150px = 路径的半径 */} 它不仅让头像沿着环形路径转动，同时还会让头像自身旋转 这里我只放出两个div方案。 需要两个元素的解决方案 用内层的变形来抵消外层的变形效果。 抵消作用是贯穿于整个动画的每一帧的 12345&lt;div class=\"path\"&gt; &lt;div class=\"avatar\"&gt; &lt;img src=\"lea.jpg\" /&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213@keyframes spin { to { transform: rotate(1turn); }}@keyframes spin-reverse { from { transform: rotate(1turn); }}.avatar { animation: spin 3s infinite linear; transform-origin: 50% 150px; /* 150px = 路径的半径 */}.avatar &gt; img { animation: spin-reverse 3s infinite linear;} 利用一套动画css 1234567891011@keyframes spin { to { transform: rotate(1turn); } }.avatar { animation: spin 3s infinite linear; transform-origin: 50% 150px; /* 150px = 路径的半径 */}.avatar &gt; img { animation: inherit; animation-direction: reverse;}","link":"/2018/01/05/css%E6%8F%AD%E7%A7%98%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"title":"css揭秘总结(三)","text":"主要总结了书里的字体排版，用户体验，结构与布局。字体排版由于介绍英文比较多，这里就直接跳过了几个段落。 # 字体排印 ## 20. 连字符断行 CSS 文本（第三版）引入了一个新的属性 hyphens。它接受三个值：none、manual 和 auto。manual 是它的初始值，其行为正好对应了现有的工作方式：我们可以在任何时候手工插入软连字符，来实现断词折行的效果。 1hyphens: auto; 21. 插入换行 通过 CSS 来插入换行的需求通常与定义列表有关。 利用伪类。 12345dd + dd::before { content: ', '; margin-left: -.25em; font-weight: normal;} 22. 文本行的斑马条纹 背景知识: CSS 渐变，background-size，“条纹背景”，“灵活的背景定位” 难题 123tr:nth-child(even) { background: rgba(0,0,0,.2);} 表格的“斑马条纹”，只需要一个伪类的选择就可以了。而文本呢。 解决方案 我们可以在CSS 中用渐变直接生成背景图像，为了让背景自动跟着内边距的宽度走，我们需要在解析 background-position时以 content box 的外沿作为基准。 1234567padding: .5em;line-height: 1.5;background: beige;background-size: auto 3em;background-origin: content-box;background-image: linear-gradient(rgba(0,0,0,.2) 50%, transparent 0); 23. 调整 tab 的宽度 难题 调整网页code的宽度。 利用新属性。 123pre { tab-size: 2;} 24. 连字 font-variant-ligatures来控制启用所有可能连字。 123font-variant-ligatures: common-ligatures discretionary-ligatures historical-ligatures; 25. 华丽的 &amp; 符号 背景知识: 通过 @font-face 规则实现基本的字体嵌入我们通常会在 font-family 声明中同时指定多个字体（即字体队列）。这样，即使我们指定的最优先字体不可用，浏览器还可以回退到其他符合整体设计风格的字体。 在这个规则之下，如果有一款字体只包含一个字符（你肯定猜到是哪个了吧），那这款字体将只用于显示这个字符，其他字符会由字体队列中排在第二位、第三位或更后面的字体来显示。 1234567@font-face { font-family: Ampersand; src: url(\"fonts/ampersand.woff\");}h1 { font-family: Ampersand, Helvetica, sans-serif;} 还需要一个描述符，unicode-range，要查出你想指定的这些字符的十六进制码位。 1234567891011@font-face { font-family: Ampersand; src: local('Baskerville'), local('Goudy Old Style'), local('Palatino'), local('Book Antiqua'); unicode-range: U+26;}h1 { font-family: Ampersand, Helvetica, sans-serif;} 26. 自定义下划线 背景知识: CSS 渐变，background-sizetext-shadow，“条纹背景” 难题 默认太丑，text-decoration: underline;。 border-bottom，会阻止正常的文本换行行为。box-shadow: 0 -1px gray inset;类似一样的会产生上述问题。 解决方案 最佳方案来自于background-image 及其相关属性。 123background: linear-gradient(gray, gray) no-repeat;background-size: 100% 1px;background-position: 0 1.15em; 新增： * text-decoration-color 用于自定义下划线或其他装饰效果的颜色。 * text-decoration-style 用于定义装饰效果的风格（比如实线、虚线、波浪线等）。 * text-decoration-skip 用于指定是否避让空格、字母降部或其他对象。 * text-underline-position 用于微调下划线的具体摆放位置。 27. 现实中的文字效果 背景知识：基本的 text-shadow 凸版印刷效果 123background: hsl(210, 13%, 40%);color: hsl(210, 13%, 75%);text-shadow: 0 -1px 1px black; 空心字效果 1234background: deeppink;color: white;text-shadow: 1px 1px black, -1px -1px black, 1px -1px black, -1px 1px black; 文字外发光效果 123background: #203;color: #ffc;text-shadow: 0 0 .1em, 0 0 .3em; 文字凸起效果 12345678910111213@mixin text-3d($color: white, $depth: 5) { $shadows: (); $shadow-color: $color; @for $i from 1 through $depth { $shadow-color: darken($shadow-color, 10%); $shadows: append($shadows, 0 ($i * 1px) $shadow-color, comma); } color: $color; text-shadow: append($shadows, 0 ($depth * 1px) 10px black, comma);}h1 { @include text-3d(#eee, 4); } 复古风格的排印效果 12345678910111213@function text-retro($color: black, $depth: 8) { $shadows: (1px 1px $color,); @for $i from 2 through $depth { $shadows: append($shadows, ($i*1px) ($i*1px) $color, comma); } @return $shadows;}h1 { color: white; background: hsl(0,50%,45%); text-shadow: text-retro();} 28. 环形文字 背景知识：基本的 SVG 解决方案 在 SVG 中，让文本按照路径排列的基本方法就是用一个 元 素 来 包 裹 住 这 段 文 本， 再 把 它 们 装 进 一 个 元 素 中。 这 个 元素还需要在它的 ID 属性中引用一个 元素，然后就可以用这个 元素来定义我们想要的路径。 123456789101112131415161718$$('.circular').forEach(function(el) { var NS = \"http://www.w3.org/2000/svg\"; var xlinkNS = \"http://www.w3.org/1999/xlink\"; var svg = document.createElementNS(NS, \"svg\"); var circle = document.createElementNS(NS, \"path\"); var text = document.createElementNS(NS, \"text\"); var textPath = document.createElementNS(NS, \"textPath\"); svg.setAttribute(\"viewBox\", \"0 0 100 100\"); circle.setAttribute(\"d\", \"M0,50 a50,50 0 1,1 0,1z\"); circle.setAttribute(\"id\", \"circle\"); textPath.textContent = el.textContent; textPath.setAttributeNS(xlinkNS, \"xlink:href\", \"#circle\"); text.appendChild(textPath); svg.appendChild(circle); svg.appendChild(text); el.textContent = ''; el.appendChild(svg);}); 用户体验 29. 选用合适的鼠标光标 难题 通过 cursor 属性来指定光标类型，比如 pointer 光标可以提示某个元素是可点击的，而 help 光标用来暗示这里有提示信息。 解决方案 提示禁用状态 123:disabled, [disabled], [aria-disabled=\"true\"] { cursor: not-allowed;} 隐藏鼠标光标 1234video { cursor: url(transparent.gif); cursor: none;} 30. 扩大可点击区域 难题 其可点击区域（热区）向外扩张往往也可以带来可用性的提升。没有人愿意对一个狭小的按钮尝试点按很多次。 解决方案 首先cursor: pointer，然后伪元素。 12345678910button { position: relative; /* [其余样式] */}button::before { content: ''; position: absolute; top: -10px; right: -10px; bottom: -10px; left: -10px;} 31. 自定义复选框 解决方案 当 元素与复选框关联之后，也可以起到触发开关的作用。 由于 label 不是复选框那样的替换元素，我们可以为它添加生成性内容（伪元素），并基于复选框的状态来为其设置样式。然后，就可以把真正的复选框隐藏起来（但不能把它从 tab 键切换焦点的队列中完全删除），再把生成性内容美化一番，用来顶替原来的复选框！ 试一试 12&lt;input type=\"checkbox\" id=\"awesome\" /&gt;&lt;label for=\"awesome\"&gt;Awesome!&lt;/label&gt; 123456789101112input[type=\"checkbox\"] + label::before { content: '\\a0'; /* 不换行空格 */ display: inline-block; vertical-align: .2em; width: .8em; height: .8em; margin-right: .2em; border-radius: .2em; background: silver; text-indent: .15em; line-height: .65;} 12345678910111213141516171819input[type=\"checkbox\"]:checked + label::before { content: '\\2713'; background: yellowgreen;}/* 把原来的复选框以一种不损失可访问性的方式隐藏起来 */input[type=\"checkbox\"] { position: absolute; clip: rect(0,0,0,0);}/* 聚焦或禁用时改变它的样式 */input[type=\"checkbox\"]:focus + label::before { box-shadow: 0 0 .1em .1em #58a;}input[type=\"checkbox\"]:disabled + label::before { background: gray; box-shadow: none; color: #555;} 开关式按钮 其实只需要把 label 设置为按钮的样式即可，并不需要用到伪元素。 123456789101112131415161718192021input[type=\"checkbox\"] { position: absolute; clip: rect(0,0,0,0);}input[type=\"checkbox\"] + label { display: inline-block; padding: .3em .5em; background: #ccc; background-image: linear-gradient(#ddd, #bbb); border: 1px solid rgba(0,0,0,.2); border-radius: .3em; box-shadow: 0 1px white inset; text-align: center; text-shadow: 0 1px 1px white;}input[type=\"checkbox\"]:checked + label,input[type=\"checkbox\"]:active + label { box-shadow: .05em .1em .2em rgba(0,0,0,.6) inset; border-color: rgba(0,0,0,.3); background: #bbb;} 32. 通过阴影来弱化背景 背景知识：RGBA 颜色 设置一个足够大的box-shadow 1box-shadow: 0 0 0 50vmax rgba(0,0,0,.8); 然而没啥用，不能js交互。 作者推荐有限度地应用这个技巧，比如配合固定定位来使用，或者当页面没有滚动条时再用。 通过模糊来弱化背景 mask添加filter 34. 滚动提示 背景知识：CSS 渐变，background-size 给个网址： https://www.w3cplus.com/css3/css-secrets/scrolling-hints.html 35. 交互式的图片对比控件 https://www.w3cplus.com/css3/css-secrets/interactive-image-comparison.html 结构与布局 36. 自适应内部元素 min-content 这个关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽的单词、图片或具有固定宽度的盒元素 123456figure { max-width: 300px; max-width: min-content; margin: auto;}figure &gt; img { max-width: inherit; } 37. 精确控制表格列宽 只需： 1234table { table-layout: fixed; width: 100%;} 38. 根据兄弟元素的数量来设置样式 难题 在某些场景下，我们需要根据兄弟元素的总数来为它们设置样式。最常见的场景就是，当一个列表不断延长时，通过隐藏控件或压缩控件等方式来节省屏幕空间，以此提升用户体验。 ### 解决方法 利用两次伪类选择。 12345678910111213/* 定义mixin */@mixin n-items($n) { &amp;:first-child:nth-last-child(#{$n}), &amp;:first-child:nth-last-child(#{$n}) ~ &amp; { @content; }}/* 调用时是这样的： */li { @include n-items(4) { /* 属性与值写在这里 */ }} 根据兄弟元素的数量范围来匹配元素 变量方式。 1234li:first-child:nth-last-child(n+4),li:first-child:nth-last-child(n+4) ~ li { /* 当列表至少包含四项时，命中所有列表项 */} 假设我们希望在列表包含 2 ～ 6 个列表项时命中所有的列表项，可以 这样写： 1234li:first-child:nth-last-child(n+2):nth-last-child(-n+6),li:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ li { /* 当列表包含2～6项时，命中所有列表项 */} 39. 满幅的背景，定宽的内容 难题 在过去的几年间，有一种网页设计手法逐渐流行起来，我将它称作背景宽度满幅，内容宽度固定 解决方法 利用算术表达式 1234.wrapper { max-width: 900px; margin: 1em calc(50% - 450px);} 如果我们将长度值应用到父元素的padding上。 12345678910111213footer { max-width: 900px; padding: 1em calc(50% - 450px); background: #333;}.wrapper {}/* 回退机制 */footer { padding: 1em; padding: 1em calc(50% - 450px); background: #333;} 40. 垂直居中 基于绝对定位的解决方案 123456main { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);} 基于视口单位的解决方案 123456main { width: 18em; padding: 1em 1.5em; margin: 50vh auto 0; transform: translateY(-50%);} 基于 Flexbox 的解决方案 1234567main { display: flex; align-items: center; justify-content: center; width: 18em; height: 10em;} 41. 紧贴底部的页脚 背景知识：视口相关的长度单位（参见“垂直居中”），calc() calc() 函数 我们可以把 和 元素包在一个容器里，然后在算式中就只需要考虑页脚的高度了： 123#wrapper { min-height: calc(100vh - 7em);} 更灵活的解决方案flex 123456body { display: flex; flex-flow: column; min-height: 100vh;}main { flex: 1; } 这 个 flex 属性实际上是flex-grow、flex-shrink 和flex-basis 的简写语法。 任何元素只要设置了一个大于 0 的flex 值，就将获得可伸缩的特性；flex 的值负责控制多个可伸缩元素之间的尺寸分配比例。举例来说，在我们眼前的这个例子中， 如 果 &lt;main&gt; 是 flex: 2 而&lt;footer&gt; 是 flex: 1，那么内容区块的高度将是页脚高度的两倍。如果把它们的值从 2 和 1 改为 4 和 2，结果也是一样的，因为真正起作用的是它们的数值比例。","link":"/2018/01/03/css%E6%8F%AD%E7%A7%98%E6%80%BB%E7%BB%93%E4%B8%89/"},{"title":"express后续篇","text":"模板引擎 在 Express 中使用模板引擎 需要在应用中设置模板文件目录views，设置模板引擎view engine * views, 放模板文件的目录，比如： app.set('views', './views') * view engine, 模板引擎，比如： app.set('view engine', 'jade') 如上例，我们用了jade模板语言，那么我们对应的需要npm相关的软件包 1npm install jade --save 和 Express 兼容的模板引擎，比如 Jade，通过 res.render() 调用其导出方法 __express(filePath, options, callback) 渲染模板。 有一些模板引擎不遵循这种约定，Consolidate.js 能将 Node 中所有流行的模板引擎映射为这种约定，这样就可以和 Express 无缝衔接。 一旦 view engine 设置成功，就不需要显式指定引擎，或者在应用中加载模板引擎模块，Express 已经在内部加载，如下所示。 1app.set('view engine', 'jade'); 现在我们在views目录下创建名字为index.jade的Jade模板文件，内容如下： 12345html head title!= title body h1!= message 然后创建一个路由来渲染index.jade文件。如果没有设置 view engine，您需要指明视图文件的后缀，否则就会遗漏它。 123app.get('/', function (req, res) { res.render('index', { title: 'Hey', message: 'Hello there!'});}); 此时向主页发送请求，“index.jade” 会被渲染为 HTML。 错误处理 错误处理的函数形式相当于其他的中间件的callback(req, res, next)，它需要四个参数(err, req, res, next),例如： 1234app.use(function(err, req, res, next) { console.error(error.stack) res.status(500).send('Something broke!')}) 它的位置则在app.use()和路由调用后，最后定义错误处理中间件，比如： 123456789var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());// ...路由app.use(function(err, req, res, next) { // 业务逻辑}) 中间件返回的响应是随意的，可以响应一个HTML错误页面、一句简单的话、一个JSON字符串、或者其他你想要的任何东西，这也就加强了对于错误的自己定义化的做法。 为了便于组织，可能会想定义常规中间件一样定制多个错误处理中间件，加强项目的逻辑性。 比如你想为使用XHR的请求定义一个，还想为没有使用的定义一个，那么： 12345678var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(logErrors);app.use(clientErrorHandler);app.use(errorHndler); logErrors会将请求和错误信息写入标准错误输出、日志或类似服务： 1234function logErrors(err, req, res, next) { console.error(err.stack); next(err);} clientErrorHandler 的定义如下（注意这里将错误直接传给了 next）： 1234567function clientErrorHandler(err, req, res, next) { if (req.xhr) { res.status(500).send({ error: 'Something blew up!' }); } else { next(err); }} errorHandler 能捕获所有错误，其定义如下： 1234function errorHandler(err, req, res, next) { res.status(500); res.render('error', { error: err });} 错误处理的next() 传入参数（除了 ‘route’ 字符串），express会认为当前请求有错误的输出，会跳到下一个错误处理的中间件。 如下节所示。 如果路由句柄有多个回调函数，可使用 ‘route’ 参数跳到下一个路由句柄。比如： 12345678910111213app.get('/a_route_behind_paywall', function checkIfPaidSubscriber(req, res, next) { if(!req.user.hasPaid) { // 继续处理该请求 next('route'); } }, function getPaidContent(req, res, next) { PaidContent.find(function(err, doc) { if(err) return next(err); res.json(doc); }); }); 在这个例子中，句柄 getPaidContent 会被跳过，但 app 中为 /a_route_behind_paywall 定义的其他句柄则会继续执行。 next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄。 缺省错误处理句柄 Express 内置了一个错误处理句柄，它可以捕获应用中可能出现的任意错误。这个缺省的错误处理中间件将被添加到中间件堆栈的底部。 如果你向 next() 传递了一个 error ，而你并没有在错误处理句柄中处理这个 error，Express 内置的缺省错误处理句柄就是最后兜底的。最后错误将被连同堆栈追踪信息一同反馈到客户端。堆栈追踪信息并不会在生产环境中反馈到客户端。 设置环境变量 NODE_ENV 为 “production” 就可以让应用运行在生产环境模式下。 如果你已经开始向 response 输出数据了，这时才调用 next() 并传递了一个 error，比如你在将向客户端输出数据流时遇到一个错误，Express 内置的缺省错误处理句柄将帮你关闭连接并告知 request 请求失败。 因此，当你添加了一个自定义的错误处理句柄后，如果已经向客户端发送包头信息了，你还可以将错误处理交给 Express 内置的错误处理机制。 1234567function errorHandler(err, req, res, next) { if (res.headersSent) { return next(err); } res.status(500); res.render('error', { error: err });} 调试 Express Express 内部使用 debug 模块记录路由匹配、使用到的中间件、应用模式以及请求-响应循环。 debug 有点像改装过的 console.log，不同的是，您不需要在生产代码中注释掉 debug。它会默认关闭，而且使用一个名为 DEBUG 的环境变量还可以打开。 在启动应用时，设置 DEBUG 环境变量为 express:*，可以查看 Express 中用到的所有内部日志。 1DEBUG=express:* node index.js 在由 express 应用生成器 生成的默认应用中执行，会打印出如下信息： 12345678910111213141516171819202122232425&gt; test-express@1.0.0 test /home/hdd/练习/express&gt; node app.js express:application set \"x-powered-by\" to true +0ms express:application set \"etag\" to 'weak' +4ms express:application set \"etag fn\" to [Function:generateETag] +1ms express:application set \"env\" to 'development' +1ms express:application set \"query parser\" to 'extended' +0ms express:application set \"query parser fn\" to [Function: parseExtendedQueryString] +0ms express:application set \"subdomain offset\" to 2+0ms express:application set \"trust proxy\" to false +0ms express:application set \"trust proxy fn\" to [Function: trustNone] +1ms express:application booting in development mode+0ms express:application set \"view\" to [Function: View] +0ms express:application set \"views\" to '/home/hdd/练习/express/views' +0ms express:application set \"jsonp callback name\" to 'callback' +0ms express:application set \"view engine\" to 'jade'+0ms express:router use '/' query +1ms express:router:layer new '/' +0ms express:router use '/' expressInit +1ms express:router:layer new '/' +0ms express:router:route new '/' +0ms express:router:layer new '/' +0ms express:router:route get '/' +1ms express:router:layer new '/' +0ms 当应用收到请求时，能看到Express代码中打印出的日志。 12345678910express:router dispatching GET / +5s express:router query : / +1ms express:router expressInit : / +1ms express:view require \"jade\" +2ms express:view lookup \"index.jade\" +564ms express:view stat \"/home/hdd/练习/express/views/index.jade\" +1ms express:view render \"/home/hdd/练习/express/views/index.jade\" +0ms express:router dispatching GET /favicon.ico +245ms express:router query : /favicon.ico +0ms express:router expressInit : /favicon.ico +1ms 设置 DEBUG 的值为 express:router，只查看路由部分的日志；设置 DEBUG 的值为 express:application，只查看应用部分的日志，依此类推。 通过 express 生成应用 将命名空间限制其中 需要添加DEBUG=ITEM-NAME 详见 调试指南 数据库集成 为 Express 应用添加连接数据库的能力，只需要加载相应数据库的 Node.js 驱动即可。 介绍下常见数据库驱动 * Cassandra * CouchDB * LevelDB * MySQL * MongoDB * Neo4j * PostgreSQL * Redis * SQLite * ElasticSearch","link":"/2017/11/12/express%E5%90%8E%E7%BB%AD%E7%AF%87/"},{"title":"css揭秘总结(二)","text":"主要总结了下CSS３的形状，视觉效果。 # 形状 ## 9. 自适应的椭圆 &gt; 背景知识：border-radius属性的基本用法 难题 一个圆很容易生成，设置一个足够大的border-radius就可以了,如果我们希望一个自适应的椭圆呢，根据内容自动调整并适应。如果它的宽高相等，就显示为一个圆；如果宽高不等，就显示为一个椭圆。 解决方案 border-radius，可以单独指定水平和垂直半径，只要用一个斜杠分开。 123border-radius: 50% 50%;/* 简写 */border-radius: 50%; 其他椭圆 我们可以为所有四个角提供完全不同的水平和垂直半径，方法是在斜杠前指定 1~4 个值，在斜杠后指定另外 1~4 个值。 123456/* 半椭圆 */border-radius: 50% / 100% 100% 0 0;/* 沿纵轴劈开的半椭圆 */border-radius: 100% 0 0 100% / 50%;/* 四分之一椭圆 */border-radius: 100% 0 0 0; 10. 平行四边形 背景知识：基本的CSS 变形 难题 平行四边形可以通过skew()的变形属性来对这个矩形进行斜向拉伸，这导致它的内容也发生了斜向变形，这很不好看，而且难读，有没有办法只让容器的形状倾斜，而保持其内容不变呢？ 嵌套元素方案 我们可以对内容再应用一次反向的 skew() 变形，从而抵消容器的变形效果, 缺点：需要添加一层层额外的 HTML 元素来包裹内容。 伪元素方案 123456789101112.button { position: relative; /* 其他的文字颜色、内边距等样式…… */}.button::before { content: ''; /* 用伪元素来生成一个矩形 */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: -1; background: #58a; transform: skew(45deg);} 适用于其他任何变形样式，当我们想变形一个元素而不想变形它的内容时就可以用到它 11. 菱形图片 背景知识: CSS 变形，“平行四边形” 难题 在视觉设计中，把图片裁切为菱形是一种常见的设计手法，但在 CSS中还没有一种简单直观的方法来实现它。事实上，直到最近，这种效果才基本成为可能。当网页设计师想要实现这种设计风格时，他们通常不希望在图像处理软件中预先把图片裁好。显然不用说你也知道，这个方法的可维护性并不好。如果未来有人想修改图片风格，将很难增加其他效果，而且最终往往会搞得一团糟。 基于变形的方案 主要的思路与前一篇攻略“平行四边形”中讨论的第一个解决方案一致：需要把图片用一个 包裹起来，然后对其应用相反的 rotate()变形样式，这个方法不是推荐的方法。 裁切路径方案 它的主要思路是使用 clip-path 属性。这个特性也是从 SVG 那里借鉴而来，已经可以应用在 HTML 元素上了（至少对于支持的浏览器来说是这样的）。 我们将会使用 polygon()（多边形）函数来指定一个菱形。实际上，它允许我们用一系列（以逗号分隔的）坐标点来指定任意的多边形。 123456789img { clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%); transition: 1s clip-path;}img:hover { clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);} 12. 切角效果 背景知识: CSS 渐变，background-size，“条纹背景” 难题 最常见的形态是把元素的一个或多个角切成 45°的缺口（也称作斜面切角）。 解决方案 第一种方案来自于无所不能的 CSS 渐变。 1234567891011121314background: #58a;background: linear-gradient(135deg, transparent 15px, #58a 0) top left, linear-gradient(-135deg, transparent 15px, #58a 0) top right, linear-gradient(-45deg, transparent 15px, #58a 0) bottom right, linear-gradient(45deg, transparent 15px, #58a 0) bottom left;background-size: 50% 50%;/* 如果不设置的话，背景会相互覆盖 */background-repeat: no-repeat;/* 如果不设置，每层渐变图案各自平铺了两次 */ 现在我们会得到，切了四个角的div。不过可维护性并不高。 1234567891011121314151617@mixin beveled-corners($bg, $tl:0, $tr:$tl, $br:$tl, $bl:$tr) { background: $bg; background: linear-gradient(135deg, transparent $tl, $bg 0) top left, linear-gradient(225deg, transparent $tr, $bg 0) top right, linear-gradient(-45deg, transparent $br, $bg 0) bottom right, linear-gradient(45deg, transparent $bl, $bg 0) bottom left; background-size: 50% 50%; background-repeat: no-repeat;}// 调用 传入 2~5 个参数：@include beveled-corners(#58a, 15px, 5px); 弧形切角 很多人也把这种效果称为“内凹圆角”，因为它看起来就像是圆角的反向版本。用径向渐变来替代上述线性渐变： 123456789101112background: #58a;background: radial-gradient(circle at top left, transparent 15px, #58a 0) top left, radial-gradient(circle at top right, transparent 15px, #58a 0) top right, radial-gradient(circle at bottom right, transparent 15px, #58a 0) bottom right, radial-gradient(circle at bottom left, transparent 15px, #58a 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat; 内联 SVG 与 border-image 方案 12345678border: 20px solid transparent;border-image: 1 url('data:image/svg+xml,\\ &lt;svg xmlns=\"http://www.w3.org/2000/svg\"\\ width=\"3\" height=\"3\" fill=\"%2358a\"&gt;\\ &lt;polygon points=\"0,1 1,0 2,0 3,1 3,2 2,3 1,3 0,2\"/&gt;\\ &lt;/svg&gt;');background: #58a;background-clip: padding-box; 裁切路径方案 利用clip-path属性。 123456background: #58a;clip-path: polygon( 20px 0, calc(100% - 20px) 0, 100% 20px, 100% calc(100% - 20px), calc(100% - 20px) 100%, 20px 100%, 0 calc(100% - 20px), 0 20px); ### 补充多边形裁剪 https://www.w3cplus.com/preprocessor/creat-css-polygon-wiht-border-and-clip-path-property.html 13. 梯形标签页 背景知识: 基本的 3D 变形，“平行四边形” 难题 一直以来，梯形都是众所周知难以用 CSS 生成的形状，尽管它也十分常用，尤其是对于标签页来说。 解决方案 利用 CSS 中用 3D 旋转来模拟出这个效果transform: perspective(.5em) rotateX(5deg);。 对元素使用了 3D变形之后，其内部的变形效应是“不可逆转”的, 这里我们像上一节利用伪类就好了。而给元素应用变形效果会让这个元素以它自身的中心线为轴进行空间上的旋转。所以我们需要设置transform-origin属性。transform-origin:bottom;，当它在 3D 空间中旋转时，可以把它的底边固定住。 123456789101112131415161718192021nav &gt; a { position: relative; display: inline-block; padding: .3em 1em 0;}nav &gt; a::before { content: ''; position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: -1; background: #ccc; background-image: linear-gradient( hsla(0,0%,100%,.6), hsla(0,0%,100%,0)); border: 1px solid rgba(0,0,0,.4); border-bottom: none; border-radius: .5em .5em 0 0; box-shadow: 0 .15em white inset; transform: perspective(.5em) rotateX(5deg); transform-origin: bottom;} 14. 简单的饼图 背景知识: CSS 渐变，基本的 SVG，CSS 动画，“条纹背景”，“自适应的椭圆” 难题 饼图在网页中的运用极为普遍，比如简单的统计图表、进度指示器、定时器等。 基于 transform 的解决方案 简单来说就是三个遮罩层的互相重叠，这里直接放代码。 123456789101112131415161718192021222324252627282930.pie { position: relative; width: 100px; line-height: 100px; border-radius: 50%; background: yellowgreen; background-image: linear-gradient(to right, transparent 50%, #655 0); color: transparent; text-align: center;}@keyframes spin { to { transform: rotate(.5turn); }}@keyframes bg { 50% { background: #655; }}.pie::before { content: ''; position: absolute; top: 0; left: 50%; width: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: inherit; transform-origin: left; animation: spin 50s linear infinite, bg 100s step-end infinite; animation-play-state: paused; animation-delay: inherit;} SVG 解决方案 一个圆形： 123&lt;svg width=\"100\" height=\"100\"&gt;&lt;circle r=\"30\" cx=\"50\" cy=\"50\" /&gt;&lt;/svg&gt; 基本样式 1234567circle { fill: yellowgreen; stroke: #655; /* stroke: 描边颜色 */ stroke-width: 30; /* stroke-width：描边宽度 */} 这里我们还需要了解一个属性stroke-dasharray，它是为虚线描边而准备的。stroke-dasharray，第一个参数是线段长度，第二个是间隙长度。当我们把这个虚线描边的线段长度指定为 0，并且把虚线间隙的长度设置为等于或大于整个圆周的长度时，答案就会浮出水面了。（这里做个简单的计算，圆形的周长 C = 2πr，因此在这里C= 2π × 30 ≈ 189。） 这里直接放出优化版本。 我们可以给这个圆形指定一个特定的半径，从而让它的周长无限接近 100，这样就可以直接把比率的百分比值指定为 strokedasharray的长度，不需要做任何计算了。 123&lt;svg viewBox=\"0 0 32 32\"&gt; &lt;circle r=\"16\" cx=\"16\" cy=\"16\" /&gt;&lt;/svg&gt; 123456789101112svg { width: 100px; height: 100px; transform: rotate(-90deg); background: yellowgreen; border-radius: 50%;}circle { fill: yellowgreen; stroke: #655; stroke-width: 32; stroke-dasharray: 38 100; /* 可得到比率为38%的扇区 */} 视觉效果 15. 单侧投影 难题 如何只在元素的一侧（偶尔是两侧）设置投影。 单侧投影 上图演示了投影生成的过程。 最终的解决方案来自 box-shadow 鲜为人知的第四个长度参数, 这是我们需要了解的。这个参数会根据你指定的值去扩大或（当指定负值时）缩小投影的尺寸。 1box-shadow: 0 5px 4px -4px black; 邻边投影 一层藏起来，另一侧自然漏出。 1box-shadow: 3px 3px 6px -3px black; 双侧投影 12box-shadow: 5px 0 5px -5px black, -5px 0 5px -5px black; 16. 不规则投影 背景知识: box-shadow 难题 当我们想给一个矩形或其他能用 border-radius 生成的形状（在“自适应的椭圆”一节中可以看到一些示例）加投影时，box-shadow 的表现都堪称完美。但是，当元素添加了一些伪元素或半透明的装饰之后，它就有些力不从心了，因为 border-radius 会无耻地忽视透明部分。 解决方案 滤镜效果规范（http://w3.org/TR/filter-effects）为这个问题提供了一个解决方案。filter就是我们需要的属性，我们甚至可以用多个滤镜。 drop-shadow() 滤镜可接受的参数基本上跟 box-shadow 属性是一样的，不包括 inset 关键字，也不支持逗号分割的多层投影语法。 我们需要知道的就是，任何非透明的部分都会被一视同仁地打上投影。小心文本的两层阴影。 17. 染色效果 背景知识: HSL 色彩模型，background-size 难题 为一幅灰度图片（或是被转换为灰度模式的彩色图片）增加染色效果（color tint），是一种流行且优雅的方式，可以给一系列风格迥异的照片带来视觉上的一致性。 常见的解决方法就是给图层上面添加一层半透明的实色背景，但减少了图片的对比度。 基于滤镜的方案 多种滤镜组合。 https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter 基于混合模式的方案 “混合模式”控制了上层元素的颜色与下层颜色进行混合的方式。要对一个元素设置混合模式，有两个属性可以派上用场：mix-blendmode可以为整个元素设置混合模式，background-blend-mode 可以为每层背景单独指定混合模式。 缺点： * 图片的尺寸需要在 CSS 代码中写死。 * 在语义上，这个元素并不是一张图片，因此并不会被读屏器之类的设备读出来。 18. 毛玻璃效果 背景知识: RGBA/HSLA 颜色 难题 半透明颜色最初的使用场景之一就是作为背景。将其叠放在照片类或其他花哨的背层之上，可以减少对比度，确保文本的可读性。这种效果确实很有视觉冲击力，但仍然可能导致文字很难阅读。 解决方案 123456789101112131415body, main::before { background: url(\"tiger.jpg\") 0 / cover fixed;}main { position: relative; background: hsla(0,0%,100%,.3); overflow: hidden;}main::before { content: ''; position: absolute; top: 0; right: 0; bottom: 0; left: 0; filter: blur(20px); margin: -30px;} 问题： * 伪元素现在就覆盖在内容元素之上。可以用 z-index: -1; 来修正这个问题。 * blur模糊效果在中心区域看起来非常完美，但在接近边缘处会逐渐消退。为了补偿这种情况，我们需要让伪元素相对其宿主元素的尺寸再向外扩大至少 20px（即它的模糊半径）。这里取30px。 * 上一个解决方法会导致一圈模糊效果超出了容器。只要对 main 元素应用overflow: hidden;，就可以把多余的模糊区域裁切掉了。 最终得到上述代码。 19. 折角效果 背景知识: CSS 变形，CSS 渐变，“切角效果“ 难题 把元素的一个角（通常是右上角或右下角）处理为类似折角的形状，再配上或多或少的拟物样式。 45°折角的解决方案 我们会从一个右上角具有斜面切角的元素开始，这个切角是由“切角效果”一节中的渐变方案实现的。 123background: #58a; /* 回退样式 */background: linear-gradient(-135deg, transparent 2em, #58a 0); 接下来所需要做的就是增加一个暗色的三角形来实现翻折效果。注意长度斜的。 1234567background: #58a; /* 回退样式 */background: linear-gradient(to left bottom, transparent 50%, rgba(0,0,0,.4) 0) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg, transparent 1.5em, #58a 0); 其他角度的解决方案 直接放mixin 1234567891011121314151617181920212223242526272829@mixin folded-corner($background, $size, $angle: 30deg) {position: relative;background: $background; /* 回退样式 */background: linear-gradient($angle - 180deg, transparent $size, $background 0);border-radius: .5em;$x: $size / sin($angle);$y: $size / cos($angle);&amp;::before { content: ''; position: absolute; top: 0; right: 0; background: linear-gradient(to left bottom, transparent 50%, rgba(0,0,0,.2) 0, rgba(0,0,0,.4)) 100% 0 no-repeat; width: $y; height: $x; transform: translateY($y - $x) rotate(2*$angle - 90deg); transform-origin: bottom right; border-bottom-left-radius: inherit; box-shadow: -.2em .2em .3em -.1em rgba(0,0,0,.2);}}/* 当调用时... */.note { @include folded-corner(#58a, 2em, 40deg);}","link":"/2018/01/02/css%E6%8F%AD%E7%A7%98%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"title":"css揭秘总结(－)","text":"引言 这个总结，基本主要记录作者给的解决方法和主要的code。思路的确很重要。共有47个小难题。 CSS3的诸多模块 CSS2(原有模块)=&gt;CSS3 CSS语法(http://w3.org/TR/css-syntax-3) CSS层叠与继承(http://w3.org/TR/css-cascade-3) CSS颜色(http://w3.org/TR/css3-color) 选择符(http://w3.org/TR/selectors) CSS背景与边框(http://w3.org/TR/css3-background) CSS值与单位(http://w3.org/TR/css-values-3) CSS文本排版(http://w3.org/TR/css-text-3) CSS文本装饰效果(http://w3.org/TR/css-text-decor-3) CSS字体(http://w3.org/TR/css3-fonts) CSS基本UI特性(http://w3.org/TR/css3-ui) CSS3新增 CSS变形(http://w3.org/TR/css-transforms-1) 图像混合效果(http://w3.org/TR/compositing-1) 滤镜效果(http://w3.org/TR/filter-effects-1) CSS遮罩(http://w3.org/TR/css-masking-1) CSS伸缩盒布局(http://w3.org/TR/css-flexbox-1) CSS网格布局(http://w3.org/TR/css-grid-1) 浏览器前缀的由来 刚开始学习css的时候，只是看教学的说需要添加前缀，可是前缀的由来记得不是很清楚。其实，在一条规范正式添加到规范中，会有一些实验性的特性。网页开发者可以根据浏览器给的前缀自由的添加相关特性，并将试用结果返还给工作组。结果开发者发现，这些有了前缀的特性能轻易的实现以前需要大费周折所实现的效果，所以，这些特性就被滥用。后来发现只写出当前适用的新特性时，还需要时不时回来打补丁，后来干脆将所有可能的浏览器前缀添加上去变成： 12345-moz-border-radius: 10px;-ms-border-radius: 10px;-o-border-radius: 10px;-webkit-border-radius: 10px;border-radius: 10px; 后来出现的预处理器成功解决了这些问题，不用写这么丑的代码了。 CSS编码技巧 尽量减少代码重复 在实践中，代码可维护性的最大要素是尽量减少改动时要编辑的地方。最简单的例如字体，用em表示，line-height与字体相关等。所以我们需要审视到底哪些效果是需要动态的变化的，哪一些又是固定不变的。 代码易维护 vs 代码量少 有时候，代码易维护和代码量少不可兼得。如下：我们为一个元素添加一道10px宽的边框，但左侧不加边框。 12345/* 方法一 */border-width: 10px 10px 10px 0;/* 方法二 */border-width: 10px;border-left-width: 0; 方法一的代码只需要一条声明就能完成，可日后我们需要改动变宽的宽度的时候需要同时改动三个地方。如果如方法二，改动起来就容易多了。 currentColor 这个值是CSS中有史以来的第一个变量，很多属性，例如border-color、outline-color等的初始值就是这个，它自动从文本获得颜色。 继承inherit 大多数人知道inherit这个关键字，但很容易遗忘。inherit可以用在任何CSS属性中，而且他还总是绑定到父元素的计算值，对于伪元素来说则会取得生成该伪元素的宿主元素。 相信你的眼睛，而不是数字 关于，垂直居中稍微往上一点看起来更居中。内边距顶部和底部的内边距需要稍微比左右的小一点，这样看起来更整齐等。主要是视觉上的错觉。 关于响应式网页设计 媒体查询的端点不应该由具体的设备来决定。 使用百分比长度来取代固定长度。或于是口相关的单位（vw、vh、vmin和vmax）。 需要在较大设备获得固定宽度，使用max-width而不是width,前者可以使用较小的分辨率。 为替换元素(img、objuct、video、iframe等)设置一个max-width。 背景图片background-size: cover可以铺满，但大图缩小带宽会消耗。 图片或其他元素行列式布局时，display: inline-block或flexbox来布局。 多列文本，指定column-width（列宽）而不是指定column-count（列数）。 合理使用简写 12background: rebeccapurple;background-color: rebeccapurple 前者简写可以确保，你获得rebeccapurple的纯色背景，而后者，可能是一个图案，因为可能有一条background-image在起作用。你也许能将所有的展开式属性全部设置一遍，但你可能会漏几个；又或者，未来CSS工作组会引入更多的展开式属性。所以合理的使用简写是一种良好的防卫性编码方式，可以抵御未来的风险。如果我们需要明确的覆盖某个具体的展开式属性，就需要使用展开式属性，如前面的border-width。 怪异的简写语法 =&gt; 可能会产生歧义的属性值用'/'分隔。 背景与边框 １．半透明边框 背景知识: RGBA/HSLA颜色 难题 也许我们会写出这样的代码来实现半透明边框： 12border: 10px solid hsla(0,0%,100%,.5);background: white; 然而半透明边框却没有实现半透明边框？ 解决方案 其实我们的边框是存在的，然而我们所需要做的是，将body的背景从半透明的白色边框透出来。我们可以通过background-clip来调整上述的特性，这个属性的初始值是border-box,意味着背景会被元素的border-box（即边框的外沿框）裁切掉。我们修改为padding-box就可以用内边距的外沿来把背景裁切掉。 123border: 10px solid hsla(0,0%,100%,.5);background: white;bcakground-clip: padding-box; 2. 多重边框 背景知识：box-shadow的基本用法 难题 有时我们需要建立多个边框。 box-shadow 方案 我们需要了解box-shadow的第四个参数，称为\"扩张半径\",可以让投影面积变大或者变小。 优点：它的支持逗号分隔，我们可以创建任意数量的投影。适用于多层边框需求 12background: yellowgreen;box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink; box-shadow是层层叠加的，第一层投影位于最顶端，以此类推。 缺点： 1. 投影的行为和边框不一致。 2. 假投影出现在元素外圈，不会影响相关事件。 outline 方案 当我们只需要两层边框的时候，可以在设置常规的边框后添加outline描边。优点是outline十分灵活，而box-shadow只能模拟实现边框。 123background: yellowgreen;border: 10px solid #655;outline: 5px solid deeppink; 缺点： 1. 只适用于双层边框。 2. 边框不一定贴合border-radius产生的圆角。 3. 尽管说描边可以不是矩形，但大多数情况需要测试。 3. 灵活的背景定位 难题 很多时候，我们想针对容器的某个角对背景图案做偏移定位,例如想要类似内边距的效果怎么做呢。 background-position的扩展语法方案 123456background: url(...) no-repeat #58a;background-position: right 20px bottom 10px;/* 退回方案 */background: url(...) no-repeat bottom right #58a;background-position: right 20px bottom 10px; background-origin 方案 需要图片的偏移量和内边距相同时。 123padding: 10px;background: url(...) no-repeat #58a;background-position: right 10px bottom 10px; 代码很繁琐，一个改动需要改三处。 默认情况下background-position是以padding box 为准的，即left top等是以padding box为准的。每个元素有三个矩形框，boeder box, padding box和content box。 123padding: 10px;background: url(...) no-repeat #58a bottom right;background-origin: content-box; calc 方案 12background: url(...) no-repeat;background-position: calc(100% - 20px) calc(100% - 10px) 4. 边框内圆角 背景知识：box-shadow, outline \"多重边框\" 难题 有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外部依然保持矩形的形状。这里放弃两个div元素的方案。 解决方案 两个div的确很优秀，如果我们只是需要纯色的边框，只需要一个元素的方法呢。 12345background: tan;border-radius: .8em;padding: 1em;box-shadow: 0 0 0 .6em #655outline: .6em solid #655 主要就是利用box-shadow的扩展半径填充元素与outline之间的缝隙。 根据勾股定理大约取值为半径的一半。 5. 条纹背景 背景知识：CSS线性渐变， background-size 难题 简单的条纹背景，我们用CSS自己创建。 解决方案 水平条纹 12background: linear-gradient(#fb3 33.3%, #58a 0, #58a 66.6%, yellowgreen 0);background-size: 100% 45px 避免每次修改条纹宽度的捷径： &gt; 如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。 垂直条纹 12linear-gradient(to right, /* 或 90deg*/ #fb3 50%, #58a 0);background-size: 30px 100%; 斜向条纹 由于贴片问题，我们需要设置四个色块。贴片的面积也需要重新计算相当于1.4倍的需要的半径。 12background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0);background: 42px 42px; 更好的斜向条纹 linear-gradient() 和 radial-gradient()还有循环加强版：repeating-linear-gradient() 和 repeating-radial-gradient() 1background: repeating-linear-gradient(60deg, #fb3, #fb3 15px, #58a 0, #58a 30px); 灵活的同色系条纹 12background: #58a;background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1), hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px) 利用transparent实现条纹的深色，直接显示背景。 6. 复杂的背景图案 背景知识：CSS渐变，“条纹背景” 难题 不仅仅有各种条纹图案，一些稍复杂的几何图案，CSS也能实现。 网格 12345678910background: white;background-image: linear-gradient(90deg, rgba(200,0,0,05) 50%, transparent 0),linear-gradient(rgba(200,0,0,05) 50%, transparent 0);background-size: 30px 30px;/* 长度单位线条 */background: #58a;background-image: linear-gradient(white 1px, transparent 0), linear-gradient(90deg, white 1px, transparent 0);background-size: 30px 30px;/* 上面会形成网格图案，网格的长度还可以用长度来表示，线条的宽度可以控制 */ 波点 直接放上波点的mixin, 波点需要两个贴片重叠。 12345678910@mixin polka($size, $dot, $base, $accent) { background: $base; background-image: radial-gradient($accent $dot, transparent 0), radial-gradient($accent $dot, transparent 0); background-size: $size $size; background-position: 0 0, $size/2 $size/2;}// 调用例子@include polka(30px, 30%, #655, tan) 棋盘 这里我们也只放上mixin, 它也需要贴片的重叠。 1234567891011121314@mixin checkerboard($size, $base, $accent: rgba(0,0,0,.25)) { background: $base; background-image: linear-gradient(45deg, $accent 25%, transparent 0, transparent 75%, $accent 0) linear-gradient(45deg, $accent 25%, transparent 0, transparent 75%, $accent 0) background-position: 0 0, $size $size, background-size: 2*$size 2*$size;}// 调用@include checkerboard(15px, #58a, tan); 7. 伪随机背景 背景知识：CSS渐变，“条纹背景”，“复杂的背景图案” 难题 其实自然界的事物都不是以无限平铺的方式存在的。CSS本身没有提供随机功能。 解决方案 通过质数来增加随机真实性，多个质数的话，那么只有经过这几个质数相乘才会重复一次。 8. 连续的图像边框 背景知识：CSS渐变，基本的border-image，“条纹背景”，基本的CSS动画 难题 有时我们想把一副图案或者图片应用为边框，而不是背景。 解决方案 也许两个元素，一个做背景一个做内容很容易做到，但我们CSS方案，尽量，每个html元素和内容不重叠, 主要思路：在石雕背景图案之上，再叠加一层纯色的实色背景。给两层背景指定不一样的background-clip值，实色用css渐变来实现。 方法一： 123456789101112131415161718192021222324/* background-origin 消除拼接效果。 */padding: 1em;border: 1em solid transparent;background: linear-gradient(white, white), url(...);background-size: cover;background-clip: padding-box, border-box;background-origin: border-box;/* 简写 */padding: 1em;border: 1em solid transparent;background: linear-gradient(white, white) padding-box, url(...) border-box 0 / cover;/* 信封边框图案 */padding: 1em;border: 16px solid transparent;border-image: 16 repeating-linear-gradient(-45deg, red 0, red 1em, transparent 0, transparent 2em, #58a 0, #58a 3em, transparent 0, transparent 4em); 如果利用动画还能形成蚂蚁行军效果。即选中不停转动的虚线框。 123456789101112@keyframes ants {to {background-position: 100%}}.marching-ants { padding: 1em; border: 1px solid transparent; background: linear-gradient(white, white) padding-box, repeating-linear-gradient(-45deg, black 0, black 25%, white 0, white 50% ) 0 / .6em .6em; animation: ants 12s linear infinite;}","link":"/2017/12/31/css%E6%8F%AD%E7%A7%98%E6%80%BB%E7%BB%93%EF%BC%8D/"},{"title":"mongodb用法初识","text":"mongoDB 什么是mongodb 中文官网首页是这么介绍的:mongoDB基于分布式文件储存的数据库高性能、可拓展、易部署、易使用，存储数据非常方便 NoSQL简介 NoSQL(NoSQL = Not Only SQL )，意即\"不仅仅是SQL\"。 在现代的计算系统上每天网络上都会产生庞大的数据量。 这些数据有很大一部分是由关系数据库管理系统（RDMBSs）来处理。 1970年 E.F.Codd's提出的关系模型的论文 \"A relational model of data for large shared data banks\"，这使得数据建模和应用程序编程更加简单。 通过应用实践证明，关系模型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。 NoSQL 是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。 MongoDB 简介 什么是MongoDB ? MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。 MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 1234{ name: \"hdd\", age: 22,} 主要特点 MongoDB的提供了一个面向文档存储，操作起来比较简单和容易。 你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=\"Sameer\",Address=\"8 Gandhi Road\")来实现更快的排序。 你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。 Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。 MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。 Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。 Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。 Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。 GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。 MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。 MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。 MongoDB安装简单。 安装mongoDB Linux平台Ubuntu安装MongoDB社区版 第一步：导入包管理系统使用的公钥 Ubuntu软件包管理工具（即dpkg和apt）通过要求分销商使用GPG密钥对软件包进行签名来确保软件包的一致性和真实性。发出以下命令导入 MongoDB公共GPG密钥： 1sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 第二步：为MongoDB创建一个列表文件 /etc/apt/sources.list.d/mongodb-org-3.4.list使用适合您的Ubuntu版本的命令创建列表文件： Ubuntu 1echo \"deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list 第三步：重新加载本地包数据库 发出以下命令重新加载本地软件包数据库： 1sudo apt-get update 第四步：安装MongoDB包 安装最新的稳定版本的MongoDB 发出以下命令： 1sudo apt-get install -y mongodb-org 运行MongoDB社区版 第一步：启动MongoDB 发出以下命令开始mongod： 1sudo service mongod start 第二步：验证MongoDB已经成功启动 验证MongoDB已经成功启动 mongod通过检查日志文件的内容进行/var/log/mongodb/mongod.log 读取，验证进程是否成功启动 1[initandlisten] waiting for connections on port &lt;port&gt; 其中被配置为在该端口/etc/mongod.conf，27017默认情况下。 第三步：停止MongoDB 根据需要，您可以mongod通过发出以下命令来停止进程： 1sudo service mongod stop 第四步：重新启动MongoDB 发出以下命令重新启动mongod： 1sudo service mongod restart 第五步：开始使用MongoDB 为了帮助您开始使用MongoDB，MongoDB提供了各种驱动程序版本中的入门指南。有关可用版本，请参阅 入门。 在生产环境中部署MongoDB之前，请考虑 生产备注文档。 稍后，要停止MongoDB，请Control+C在mongod实例运行的终端上 按。 NodeJS中MongoDB驱动 虽然说在NodeJS下连接MongoDB用Mongoose的较多，但作为其基础的mongodb库了解一下还是很有必要的。 安装 一如既往的通过npm安装，命令 1npm install mongodb ### 连接数据库 通过MongoClient.connect连接数据库，在回调中会返回db对象以供之后使用。 1234567891011var MongoClient = require('mongodb').MongoClient;var url = 'mongodb://localhost:27017/dbname';MongoClient.connect(url, function(err, db) { if(err){ console.error(err); return; }else{ console.log(\"Connected correctly to server\"); db.close(); }}); 获得Collection 调用db对象的collection获得collection 1var collection = db.collection('collectionName'); 添加记录 调用collection的insert|insertMany方法添加记录。 12345678collection.insert[|insertMangy]({name:\"myName\",age:\"myAge\"},function(err,result){ if(err){ console.error(err); }else{ console.log(\"insert result:\"); console.log(result); }}) 更新记录 调用collection的updateOne方法更新单个记录。 12345678collection.updateOne({ a : 2 }, { $set: { b : 1 } }, function(err, result) { if(err){ console.error(err); }else{ console.log(\"update result:\"); console.log(result); }}); 删除记录 调用collection的deleteOne方法更新单个记录。 12345678collection.deleteOne({ a : 3 }, function(err, result) { if(err){ console.error(err); }else{ console.log(\"delete result:\"); console.log(result); } }); ### 查询记录 调用collection的find方法查找记录,find方法的参数为查找条件。 12345678collection.find({}).toArray(function(err, docs) { if(err){ console.error(err); }else{ console.log(\"find result:\"); console.log(result); } }); 仅仅写了基础的CRUD,详情参考 http://mongodb.github.io/node-mongodb-native/2.0","link":"/2017/10/29/mongodb%E7%94%A8%E6%B3%95%E5%88%9D%E8%AF%86/"},{"title":"headless chrome Puppeteer 无头or无界面 ","text":"概述Puppeteer Puppeteer 是一个用来控制无界面Chrome的Node库，它提供了很多高级的api来使我们跟好的控制无界面的Chrome。这个headless可以叫无头，也可以叫无界面吧 ## 我们能做什么？ 大多数我们能在浏览器上做的都能用Puppeteer来做！ * 生成页面的截图和PDF文件。 * 抓取spa并生成预渲染内容（即“SSR”）。 * 从网页爬取内容。 * 自动化表单提交、UI测试、键盘输入等。 * 自动化更新表格创建，自动化测试环境。 * 捕获站点的时间线跟踪，以帮助诊断性能问题。 了解这么多，我主要是从爬虫知道的这个工具。 因为这个工具相关的几个类似的工具(像PhantomJS)也大多停止更新了，谷歌真厉害。。 ## shotscreens 和 PDF实例 ### 截图 page.screenshot([options]) 这个api 可以 12345678910const puppeteer = require('puppeteer');(async () =&gt; { const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto('https://example.com'); await page.screenshot({path: 'example.png'}); await browser.close();})(); PDF page.pdf(options)这个api来打印，也有一些options可以设置 比较常用的format：A4 之类的 12345678910const puppeteer = require('puppeteer');(async () =&gt; { const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto('https://news.ycombinator.com', {waitUntil: 'networkidle2'}); await page.pdf({path: 'hn.pdf', format: 'A4'}); await browser.close();})(); 获取页面上下文 page.evaluate(pageFunction, ...args)， 这个api， 来解析 1234567891011121314151617181920const puppeteer = require('puppeteer');(async () =&gt; { const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto('https://example.com'); // Get the \"viewport\" of the page, as reported by the page. const dimensions = await page.evaluate(() =&gt; { return { width: document.documentElement.clientWidth, height: document.documentElement.clientHeight, deviceScaleFactor: window.devicePixelRatio }; }); console.log('Dimensions:', dimensions); await browser.close();})(); Puppeteer常用api分类 概览 Puppeteer 使用开发者工具和浏览器通信 Browser 拥有多个界面的实例 Page 至少有一个框架：主框架。可能还有其他由iframe和frame标签创建的frames Frame 至少有一个执行上下文，默认的上下文是JavaScript的执行框架。框架可能有与执行相关联的附加执行上下文。 环境变量 由npm config设置proxy代理，或关于下载的Url和版本之类的。 类：Puppeteer Puppeteer模块提供了一种方法来登录Chromium实例。 类：Browser 一个Browser 在Puppeteer连接到Chromium实例时被创建,通过puppeteer.launch 或 puppeteer.connect. 常用browser.newPage()新界面 ,browser.close()关闭browser和browser.wsEndpoint()断点打开。 类：Page Page提供了于Chromium单选项交互的方法。一个Browser有多个Page实例 基础的方法有： 一些原生的事件，还有page.$(selector)，page.$$(selector)来进行页面的元素选择，page.$eval(selector, pageFunction[, ...args])和page.$$eval(selector, pageFunction[, ...args]) 123const searchValue = await page.$eval('#search', el =&gt; el.value);const preloadHref = await page.$eval('link[rel=preload]', el =&gt; el.href);const html = await page.$eval('.main-container', e =&gt; e.outerHTML); page.click(selector[, options])鼠标点击，相关的点击事件也可以通过options来设置。 page.content()返回整个HTML的page内容，包括doctype。 page.cookies(...urls), page.deleteCookie(...cookies) page.emulate(options)媒体设置。 1234567891011const puppeteer = require('puppeteer');const devices = require('puppeteer/DeviceDescriptors');const iPhone = devices['iPhone 6'];puppeteer.launch().then(async browser =&gt; { const page = await browser.newPage(); await page.emulate(iPhone); await page.goto('https://www.google.com'); // other actions... await browser.close();}); page.evaluate(pageFunction, ...args)对页面的上下文进行操作。 123const bodyHandle = await page.$('body');const html = await page.evaluate(body =&gt; body.innerHTML, bodyHandle);await bodyHandle.dispose(); page.goto(url, options),page.goForward(options)和page.goBack(options)。 还可以对页面的js,css,html进行行管的操作。 page.setUserAgent(userAgent), page.setViewport(viewport)亦可以进行相关操作。 类：Keyboard 键盘相关输入， 12345678910await page.keyboard.type('Hello World!');await page.keyboard.press('ArrowLeft');await page.keyboard.down('Shift');for (let i = 0; i &lt; ' World'.length; i++) await page.keyboard.press('ArrowLeft');await page.keyboard.up('Shift');await page.keyboard.press('Backspace');// Result text will end up saying 'Hello!' 类：Mouse 鼠标点击拖住事件。和键盘事件类似。 类: Touchscreen 点击屏幕位置。 touchscreen.tap(x, y) 类：Dialog 弹出框确认，取消以及相关的信息，输入都客气取得。 类：ConsoleMessage 页面的console信息获取。 类：Frame 大部分page都有Frame的方法，相当于 page.mainFrame()。 frame.childFrame()， frame.name()， frame.parentFrame()相关操作。属于frame的。 类：ExecutionContext 类表示JavaScript执行的上下文。 类：JSHandle JSHandle表示页面中的JavaScript对象。JSHandles可以由page.evaluateHandle方法创建。 类：ElementHandle elementhandle代表一个页面的DOM元素。elementhandles可以 page.$由方法。 elementHandle.getProperties() elementHandle.getProperty(propertyName) 获取元素的属性值, 爬取页面的url可用。 elementHandle.screenshot([options])， 这个会将页面滚动到可以显示元素的地方，来截图。 elementHandle.uploadFile(...filePaths)上出文件。 类：Request 当一个页面发送一个request，puppeteer's page会派发一下以下几个事件 * 'request'当页面发出请求时发出。 * 'response' 当响应请求接收到响应时发出。 * 'requestfinished' 当响应体被下载并请求完成时发出。 类： Response 响应类表示由页面接收的响应。 api详情 Overview Environment Variables class: Puppeteer puppeteer.connect(options) puppeteer.executablePath() puppeteer.launch([options]) class: Browser event: 'disconnected' event: 'targetchanged' event: 'targetcreated' event: 'targetdestroyed' browser.close() browser.disconnect() browser.newPage() browser.pages() browser.targets() browser.version() browser.wsEndpoint() class: Page event: 'console' event: 'dialog' event: 'error' event: 'frameattached' event: 'framedetached' event: 'framenavigated' event: 'load' event: 'metrics' event: 'pageerror' event: 'request' event: 'requestfailed' event: 'requestfinished' event: 'response' page.$(selector) page.$$(selector) page.$$eval(selector, pageFunction[, ...args]) page.$eval(selector, pageFunction[, ...args]) page.addScriptTag(options) page.addStyleTag(options) page.authenticate(credentials) page.bringToFront() page.click(selector[, options]) page.close() page.content() page.cookies(...urls) page.deleteCookie(...cookies) page.emulate(options) page.emulateMedia(mediaType) page.evaluate(pageFunction, ...args) page.evaluateHandle(pageFunction, ...args) page.evaluateOnNewDocument(pageFunction, ...args) page.exposeFunction(name, puppeteerFunction) page.focus(selector) page.frames() page.goBack(options) page.goForward(options) page.goto(url, options) page.hover(selector) page.keyboard page.mainFrame() page.metrics() page.mouse page.pdf(options) page.queryObjects(prototypeHandle) page.reload(options) page.screenshot([options]) page.select(selector, ...values) page.setContent(html) page.setCookie(...cookies) page.setExtraHTTPHeaders(headers) page.setJavaScriptEnabled(enabled) page.setOfflineMode(enabled) page.setRequestInterception(value) page.setUserAgent(userAgent) page.setViewport(viewport) page.tap(selector) page.title() page.touchscreen page.tracing page.type(selector, text[, options]) page.url() page.viewport() page.waitFor(selectorOrFunctionOrTimeout[, options[, ...args]]) page.waitForFunction(pageFunction[, options[, ...args]]) page.waitForNavigation(options) page.waitForSelector(selector[, options]) class: Keyboard keyboard.down(key[, options]) keyboard.press(key[, options]) keyboard.sendCharacter(char) keyboard.type(text, options) keyboard.up(key) class: Mouse mouse.click(x, y, [options]) mouse.down([options]) mouse.move(x, y, [options]) mouse.up([options]) class: Touchscreen touchscreen.tap(x, y) class: Tracing tracing.start(options) tracing.stop() class: Dialog dialog.accept([promptText]) dialog.defaultValue() dialog.dismiss() dialog.message() dialog.type class: ConsoleMessage consoleMessage.args consoleMessage.text consoleMessage.type class: Frame frame.$(selector) frame.$$(selector) frame.$$eval(selector, pageFunction[, ...args]) frame.$eval(selector, pageFunction[, ...args]) frame.addScriptTag(options) frame.addStyleTag(options) frame.childFrames() frame.evaluate(pageFunction, ...args) frame.executionContext() frame.isDetached() frame.name() frame.parentFrame() frame.select(selector, ...values) frame.title() frame.url() frame.waitFor(selectorOrFunctionOrTimeout[, options[, ...args]]) frame.waitForFunction(pageFunction[, options[, ...args]]) frame.waitForSelector(selector[, options]) class: ExecutionContext executionContext.evaluate(pageFunction, ...args) executionContext.evaluateHandle(pageFunction, ...args) executionContext.queryObjects(prototypeHandle) class: JSHandle jsHandle.asElement() jsHandle.dispose() jsHandle.executionContext() jsHandle.getProperties() jsHandle.getProperty(propertyName) jsHandle.jsonValue() class: ElementHandle elementHandle.$(selector) elementHandle.$$(selector) elementHandle.asElement() elementHandle.boundingBox() elementHandle.click([options]) elementHandle.dispose() elementHandle.executionContext() elementHandle.focus() elementHandle.getProperties() elementHandle.getProperty(propertyName) elementHandle.hover() elementHandle.jsonValue() elementHandle.press(key[, options]) elementHandle.screenshot([options]) elementHandle.tap() elementHandle.toString() elementHandle.type(text[, options]) elementHandle.uploadFile(...filePaths) class: Request request.abort([errorCode]) request.continue([overrides]) request.failure() request.headers request.method request.postData request.resourceType request.respond(response) request.response() request.url class: Response response.buffer() response.headers response.json() response.ok response.request() response.status response.text() response.url class: Target target.page() target.type() target.url()","link":"/2017/11/20/headless-chrome-Puppeteer-%E6%97%A0%E5%A4%B4or%E6%97%A0%E7%95%8C%E9%9D%A2/"},{"title":"mongoose常用用法","text":"参考链接 讲的非常好，推荐！ # 初识mongoose ## install mongoose 安装mongodb可以看一下另一篇文章mongodb用法初识 这里我们开启mongodb服务 1sudo service mongod start 接下来下载安装mongoose 1npm install mongoose --save connect mongoose 下载好之后，我们需要连接database.在js文件写入: 123456789101112131415'use strict';const mongoose = require('mongoose');mongoose.connect('mongodb://localhost:27017/test', { useMongoClient: true // 新版本需要使用解决旧版本升级问题，可以查阅官网});const db = mongoose.connection;db.on('error', () =&gt; { console.log('连接失败')});con.once('open', () =&gt; { console.log('连接成功')}) 如果不出什么问题，我们的第一次连接会在命令行上显示连接成功。 Mongoose的基本概念 Schema: 相当于一个数据库的模板. Model可以通过mongoose.model 集成其基本属性内容. 当然也可以选择不继承. Model: 基本文档数据的父类,通过集成Schema定义的基本方法和属性得到相关的内容. instance: 这就是实实在在的数据了. 通过 new Model()初始化得到. mongoose demo: 1234567891011121314151617181920212223242526272829303132333435'use strict';const mongoose = require('mongoose');mongoose.connect('mongodb://localhost:27017/test', { useMongoClient: true});const db = mongoose.connection;db.on('error', console.error.bind(console, '连接数据库失败'));db.once('open',()=&gt;{ //定义一个schema let Schema = mongoose.Schema({ category: String, name: String }); Schema.methods.eat = function(){ console.log(\"I've eatten one \"+this.name); } //继承一个schema let Model = mongoose.model(\"fruit\",Schema); //生成一个document let apple = new Model({ category:'apple', name:'apple' }); //存放数据 apple.save((err,apple)=&gt;{ if(err) return console.log(err); apple.eat(); //查找数据 Model.find({name:'apple'},(err,data)=&gt;{ console.log(data); }) });}) 深入浅出mongoose 从三个基本概念深入展开 ## Schema 这实际上是,mongoose中最重要的一个theroy. schema 是用来定义 documents的基本字段和集合的. 在mongoose中,提供了Schema的类。 我们可以通过实例化他, 来实现创建 Schema的效果. 而不需要每次调用 mongoose.Schema()这个丑陋的API. 12345678910111213141516// from mongoose authorvar mongoose = require('mongoose');var Schema = mongoose.Schema;var blogSchema = new Schema({ title: String, author: String, body: String, comments: [{ body: String, date: Date }], date: { type: Date, default: Date.now }, hidden: Boolean, meta: { votes: Number, favs: Number }}); Schema 之所以能够定义documents, 是因为他可以限制你输入的字段及其类型. mongoose支持的基本类型有: * String * Number * Date * Buffer * Boolean * Mixed * ObjectId * Array 其中, Mixed和ObjectId是mongoose中特有的,ObjectId实际上就是_id的一个映射. 同样,mongoose里面有着和所有大众数据库一样的东西. 索引 – indexs mongoose 设置索引 这里设置索引分两种,一种设在Schema filed, 另外一种设在 Schema.index 里. 123456789var animalSchema = new Schema({ name: String, type: String, tags: { type: [String], index: true }});// 在Schema.index中设置.animalSchema.index({ name: 1, type: -1 });// 1 表示正序, -1 表示逆序 实际上,两者效果是一样的. 看每个人的喜好了. 不过推荐直接在Schema level中设置, 这样分开能够增加可读性. 不过,官方给出了一个建议, 因为在创建字段时, 数据库会自动根据自动排序(ensureIndex)排序. 有可能严重拖慢查询或者创建速度,所以一般而言,我们需要将该option 关闭. 1234567mongoose.connect('mongodb://user:pass@localhost:port/database', { config: { autoIndex: false } }); //真心推荐// ormongoose.createConnection('mongodb://user:pass@localhost:port/database', { config: { autoIndex: false } }); //不推荐// oranimalSchema.set('autoIndex', false); //推荐// ornew Schema({..}, { autoIndex: false }); //懒癌不推荐 另外, Schema 另一大特色就是其methods. 我们可以通过定义其methods,访问到实际上的所有内容. 定义Schema.methods 使用的方法很简单,就是使用 .methods即可. 12345678910// 定义一个schemavar freshSchema = new Schema({ name: String, type: String });// 添加一个fn.animalSchema.methods.findSimilarTypes = function (cb) { //这里的this指的是具体document上的this return this.model('Animal').find({ type: this.type }, cb);}// 实际上,我们可以通过schema绑定上,数据库操作的所有方法.// 该method实际上是绑定在 实例的 doc 定义完methods和property之后, 就到了生成Model的阶段了. ### 实例Model 这里同样很简单,只需要 mongoose.model() 即可. 123// 生成,model 类. 实际上就相当于我们的一个collectionvar Animal = mongoose.model('Animal', animalSchema);var dog = new Animal({ type: 'dog' }); 但是, 这里有个问题. 我们在Schema.methods.fn 上定义的方法,只能在 new Model() 得到的实例中才能访问. 那如果我们想,直接在Model上调用 相关的查询或者删除呢？ 绑定Model方法 同样很简单,使用 statics 即可. 12345678910// 给model添加一个findByName方法animalSchema.statics.findByName = function (name, cb) { // 这里的this 指的就是Model return this.find({ name: new RegExp(name, 'i') }, cb);}var Animal = mongoose.model('Animal', animalSchema);Animal.findByName('fido', function (err, animals) { console.log(animals);}); Mongoose 还有一个super featrue-- virtual property 该属性是直接设置在Schema上的. 但是,需要注意的是,VR 并不会真正的存放在db中. 他只是一个提取数据的方法. 12345678910111213141516171819202122232425//schema基本内容var personSchema = new Schema({ name: { first: String, last: String }});// 生成Modelvar Person = mongoose.model('Person', personSchema);//现在我们有个需求,即,需要将first和last结合输出.//一种方法是,使用methods来实现//schema 添加方法personSchema.methods.getName = function(){ return this.first+\" \"+this.last;}// 生成一个docvar bad = new Person({ name: { first: 'jimmy', last: 'Gay' }});//调用bad.getName(); 但是,像这样,仅仅这是为了获取一个属性, 实际上完全可以使用虚拟属性来实现. 123456// schema 添加虚拟属性personSchema.virtual('fullName').get(function(){ return this.first+\" \"+this.last;})// 调用bad.fullName; // 和上面的方法的结果是完全一致的 而且,经过测试, 使用fn实现的返回,比VR 要慢几十倍. 一下是测试结果: 12345678910console.time(1); bad.getName(); console.timeEnd(1); console.time(2); bad.fullName; console.timeEnd(2); //结果为: 1: 4.323ms; // method 2: 0.253ms // VR 最后再补充一下,Schema中初始化的相关参数. Schema参数 在 new Schema([options]) 中,我们需要设置一些相关的参数. * safe: 用来设置安全模式. 实际上,就是定义入库时数据的写入限制. 比如写入时限等. 1234567// 使用安全模式. 表示在写入操作时,如果发生错误,也需要返回信息.var safe = true;new Schema({ .. }, { safe: safe });// 自定义安全模式. w为写入的大小范围. wtimeout设置写入时限. 如果超出10s则返回errorvar safe = { w: \"majority\", wtimeout: 10000 };new Schema({ .. }, { safe: safe }); toObject: 用来表示在提取数据的时候, 把documents 内容转化为Object内容输出. 一般而言只需要设置getters为true即可. 12345schema.set('toObject', { getters: true });var M = mongoose.model('Person', schema);var m = new M({ name: 'Max Headroom' });//实际打印出来的就是一个Object类型console.log(m); // { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' } toJSON: 该是和toObject一样的使用. 通常用来把 documents 转化为Object. 但是, 需要显示使用toJSON()方法,否则,不会起作用。实际上,没什么卵用… 看一下总结图谱: 看完schema之后,我们需要了解一下 model的内容. Model 实际上,Model才是操作数据库最直接的一块内容. 我们所有的CRUD就是围绕着Model 展开的. ok. 还记得,我们是怎样创建一个model的吗？ 123//from mongoosejsvar schema = new mongoose.Schema({ name: 'string', size: 'string' });var Tank = mongoose.model('Tank', schema); 这里,我们一定要搞清楚一个东西. 实际上, mongoose.model里面定义的第一个参数,比如’Tank’, 并不是数据库中的, collection. 他只是collection的单数形式, 实际上在db中的collection是’Tanks’. ok, 我们现在已经有了一个基本的Model. 但并没有什么x用. 接下来, 正式到了 dry goods(干货) 时间. model 的子文档操作 这个就厉害了. 本来mongodb是没有关系的. 但是, mongoose提供了children字段. 让我们能够轻松的在表间建立关系. 现在,我们来创建一个子域: 12345678910var childSchema = new Schema({ name: 'string' });var parentSchema = new Schema({ children: [childSchema] //指明sub-doc的schema});//在创建中指明docvar Parent = mongoose.model('Parent', parentSchema);var parent = new Parent({ children: [{ name: 'Matt' }, { name: 'Sarah' }] })parent.children[0].name = 'Matthew';parent.save(callback); 现在, 我们就已经创建了3个table. 一个parent 包含了 两个child 另外,如果我们想要查询指定的doc。 则可以使用 id()方法 1var doc = parent.children.id(id); 子文档的CRUD, 实际上就是数组的操作, 比如push,unshift,remove,pop,shift等 1parent.children.push({ name: 'Liesl' }); mongoose还给移除提供了另外一个方法–remove: 1var doc = parent.children.id(id).remove(); 如果你忘记添加子文档的话，可以在外围添加, 但是字段必须在Schema中指定 1var newdoc = parent.children.create({ name: 'Aaron' }); model的CRUD操作 model的创建 关于model的创建,有两种方法, 一种是使用实例创建,另外一种是使用Model类创建. 1234567891011121314var Tank = mongoose.model('Tank', yourSchema);var small = new Tank({ size: 'small' });//使用实例创建small.save(function (err) { if (err) return handleError(err); // saved!})//使用Model类创建Tank.create({ size: 'small' }, function (err, small) { if (err) return handleError(err); // saved!}) 上面已经完美的介绍创建的方法了. 另外,官方给出一个提醒: 由于mongoose, 会自身连接数据库并断开. 如果你手动连接, 则创建model的方式需要改变. 1234567// 自己并没有打开连接:// 注意,这里只是连接,并没有创建connectionmongoose.connect('mongodb://localhost:27017/test');// 手动创建连接:var connection = mongoose.createConnection('mongodb://localhost:27017/test');var Tank = connection.model('Tank', yourSchema); 然后, 下面的API还是一样的. 实际上,我们一般常用的写法为: 123456789101112const mongoose = require('mongoose');const Schema = mongoose.Schema;//设置连接位置mongoose.connect('mongodb://localhost:27017/test');var schema = new mongoose.Schema({ name: 'string', size: 'string' });var Tank = mongoose.model('Tank', schema);var small = new Tank({ size: 'small' });//使用实例创建small.save(function (err) { if (err) return handleError(err); console.log('创建成功');}) 这样,就不用自己去手动管连接的问题了. 如果你,在后面想手动添加字段的话,可以使用.set方法. 123456789// 一个key/valyedoc.set(path, value)//很多key/valuedoc.set({ path : value, path2 : { path : value }}) model的query model的查找主要提供了以下的API,给我们进行操作. find, findById, findOne, or where 在mongodb中, query返回的数据格式一般都是为JSON的. 这点需要注意. 事实上,在mongoose中,query数据 提供了两种方式. callback: 使用回调函数, 即, query会立即执行,然后返回到回调函数中. 1234Person.findOne({ 'name.last': 'Ghost' }, 'name occupation', function (err, person) { if (err) return handleError(err); // get data}) query: 使用查询方法,返回的对象. 该对象是一个Promise, 所以可以使用 chain 进行调用.最后必须使用exec(cb)传入回调进行处理. cb 是一个套路, 第一个参数永远是err. 第二个就是返回的数据。 1234567891011121314Person. find({ occupation: /host/, 'name.last': 'Ghost', age: { $gt: 17, $lt: 66 }, likes: { $in: ['vaporizing', 'talking'] } }). limit(10). sort({ occupation: -1 }). select({ name: 1, occupation: 1 }). exec(callback);//如果没有查询到,则返回[] (空数组)// 如果你使用findOne, 没有的话则会返回 null 童鞋, 你觉得我会推荐哪种呢？ 上面4个API, 3个使用方式都是一样的, 另外一个不同的是where. 他一样是用来进行query. 只是,写法和find系列略有不同 where简介 where的API为: Model.where(path, [val]) path实际上就是字段, 第二个参数.val表示可以用来指定,path = val的数据内容, 你也可以不写, 交给后面进行筛选. 看一下对比demo吧: 123User.find({age: {$gte: 21, $lte: 65}}, callback);//等价于:User.where('age').gte(21).lte(65).exec(callback); 从上面的query中,我们可以看到有许多fn, 比如gte,lte,\\(gte,\\)lte. 这些是db提供给我们用来查询的快捷函数. 我们可以参考, mongoose给的参考: query Helper fn 这里,我们简要的了解下,基本的快捷函数. name effect select 添加需要显示的字段,需要的字段在字段后加上:1,不需要的加上0;query.select({ a: 1, b: 0 }); //显示a字段, 隐藏b字段不能和distinct方法一起使用 distinct 用来筛选不重复的值或者字段distinct(field). //筛选指定不重复字段的数据 \\(lt,\\)lte,\\(gt,\\)gte 分别对应: &lt;,&lt;=,&gt;,&gt;=. 该字段是用在condition中的.如果,你想要链式调用,则需要使用lt,lte,ge,gte.eg: model.find({num:{\\(gt:12}},cb)&lt;br/&gt;model.where(‘num’).gt(12).exec(cb)| |\\)in ok~ 这上面就是比较常用的快捷函数. 另外还有一些游标集合的处理方法: 常用的就3个, limit,skip,sort. limit: 用来获取限定长度的内容. 1query.limit(20); //只返回前20个内容 skip: 返回，跳过指定doc后的值. 1query.skip(2); sort: 用来设置根据指定字段排序. 可以设置为1:升序, -1:降序. 1query.sort({name:1,age:-1}); 实际上, 关于query,我们需要了解的也就差不多了. 我们接下来,来看一下remove. mongoose remove 操作 123Model.find().remove({ name: 'Anne Murray' }).remove(fn);//或者直接添加回调Model.find().remove({ name: 'Anne Murray' },cb) 另外,我们可以直接在Model上调用. 因为remove也是Schema定义的statics方法. 而且, remove返回一个Promise对象 12345678product.remove().then(function (product) { ...});//或者直接传入回调Tank.remove({ size: 'large' }, function (err) { if (err) return handleError(err); // removed!}); 最后,我们再看一下 update. 然后mongoose就基本结束了 update操作: 这里,我只说一下API就好. 因为update 比起上面来说,还是比较简单的. Model.update(conditions, doc, [options], [callback]) conditions: 就是query. 通过query获取到指定doc doc: 就是用来替换doc内容的值. options: safe (boolean) 是否开启安全模式 (default for true) upsert (boolean) 如果没有匹配到内容,是否自动创建 ( default for false) multi (boolean) 如果有多个doc,匹配到,是否一起更改 ( default for false) strict (boolean) 使用严格模式(default for false) overwrite (boolean) 匹配到指定doc,是否覆盖 (default for false) unValidators (boolean): 表示是否用来启用验证. 实际上,你首先需要写一个验证. 关于如果书写,验证大家可以参考下文, validate篇(default for false) 12345Model.update({age:18}, { $set: { name: 'jason borne' }}, {multi:true}, function (err, raw) { if (err) return handleError(err); console.log('raw 就是mongodb返回的更改状态的falg ', raw); //比如: { ok: 1, nModified: 2, n: 2 }}); 其中的$set是,用来指明更新的字段.另外,mongoose还提供了一个:findByIdAndUpdate(id,doc[,options][,callback]); 方法. 关于mongoose的更新helper 函数. 童鞋们可以参考一下.mongoose官方文档. validation 说完了,mongoose的body之后. 我们接着来看一下,官方给mongoose穿上的漂亮的衣服. 其中一件,比较吸引人的是–validation. 在你save数据之前, 你可以对数据进行一些列的validation. 来防止某天你傻不拉几的把数据完整性给破坏了. mongoose贴心的提供了几个built-in的验证函数. * required: 表示必填字段. 123456new Schema({ name: { type:String, required:[true,\"name 是必须的\"] //第二个参数是错误提示信息 }}) min,max: 用来给Number类型的数据设置限制. 1234567 var breakfastSchema = new Schema({ eggs: { type: Number, min: [6, 'Too few eggs'], max: 12 }}); enum,match,maxlength,minlength: 这些验证是给string类型的. enum 就是枚举,表示该属性值,只能出席那那些. match是用来匹配正则表达式的. maxlength&amp;minlength 显示字符串的长度. 123456789101112new Schema({ drink: { type: String, enum: ['Coffee', 'Tea'] }, food:{ type: String, match:/^a/, maxlength:12, minlength:6 }}) mongoose提供的helper fn就是这几种, 如果你想定制化验证. 可以使用custom validation. 123456789101112new Schema({ phone: { type: String, validate: { validator: function(data) { return /\\d{3}-\\d{3}-\\d{4}/.test(data); }, message: '{VALUE} is not a valid phone number!' //VALUE代表phone存放的值 }, required: [true, 'User phone number required'] }}) 另外,还可以额外添加验证. 12345678910var toySchema = new Schema({ color: String, name: String }); var validator = function (value) { return /blue|green|white|red|orange|periwinkle/i.test(value); }; toySchema.path('color').validate(validator, 'Color `{VALUE}` not valid', 'Invalid color'); 现在,我们已经设置了validation. 但是你不启用,一样没有什么卵用. 实际上, 我们也可以把validation当做一个中间件使用. mongoose 提供了两种调用方式. 一种是内置调用, 当你使用.save方法时,他会首先执行一次存储方法. 123cat.save(function(error) {//自动执行,validation}); 另外一种是,手动验证–指定validate方法. 1234567//上面已经设置好user的字段内容. user.validate(function(error) { //error 就是验证不通过返回的错误信息 assert.equal(error.errors['phone'].message, '555.0123 is not a valid phone number!'); });}); 事实上, 在validate时, 错误的返回信息有以下4个字段: kind, path, value, and message; kind: 用来表示验证设置的第二个参数. 一般不用 path: 就是字段名 value: 你设置的错误内容 message: 提示错误信息 看一个整体demo吧: 123456789101112131415161718var validator = function (value) { return /blue|green|white|red|orange|periwinkle/i.test(value); }; Toy.schema.path('color').validate(validator, 'Color `{VALUE}` not valid', 'Invalid color'); //设置了message &amp;&amp; kind var toy = new Toy({ color: 'grease'}); toy.save(function (err) { // err is our ValidationError object // err.errors.color is a ValidatorError object assert.equal(err.errors.color.message, 'Color `grease` not valid'); //返回message assert.equal(err.errors.color.kind, 'Invalid color'); assert.equal(err.errors.color.path, 'color'); assert.equal(err.errors.color.value, 'grease'); assert.equal(err.name, 'ValidationError'); //访问color 也可以直接上 errors[\"color\"]进行访问. }); 在Model.update那一节有个参数–runValidators. 还没有详细说. 这里, 展开一下. 实际上, validate一般只会应用在save上, 如果你想在update使用的话, 需要额外的trick，而runValidators就是这个trick. 1234var opts = { runValidators: true }; Test.update({}, update, opts, function(error) { //额外开启runValidators的验证 // There will never be a validation error here }); 我们来看一下基本总结吧: population originally, mongodb 本来就是一门非关系型数据库。 但有时候,我们又需要联合其他的table进行数据查找。 这时候, 一般的做法就是实现两次查询，效率我就呵呵了. 此时, mongoose 说了一句: 麻麻, 我已经都把脏活帮你做好了. 感动~ 有木有~ 这就是mongoose提供的 population. 用来连接多表数据查询. 一般而言, 我们只要提供某一个collection的_id , 就可以实现完美的联合查询. population 用到的关键字是: ref 用来指明外联的数据库的名字. 一般,我们需要在schema中就定义好. 1234567891011121314var mongoose = require('mongoose') , Schema = mongoose.Schemavar personSchema = Schema({ _id : Number, name : String, age : Number, stories : [{ type: Schema.Types.ObjectId, ref: 'Story' }]});var storySchema = Schema({ _creator : { type: Schema.Types.ObjectId, ref: 'Person' }, title : String}); 这里就指明了, 外联数据表的应用关系 personSchema By _id =&gt; Story storySchema &lt;_creator&gt; By _id =&gt; Person 实际上, 就是通过_id的相互索引即可. 这里需要说明的是, _id 应该是某个具体model的id. 我们来看一下, 接下来应该如何利用population实现外联查询. 12345678910111213141516171819const sam = new Person({ name: 'sam', _id: 1, age: 18, stories: []});sam.save((err,sam)=&gt;{ if(err) return err; let story = new Story({ _creator:sam._id, title:\"喜剧之王\" })})Story.findOne({title:\"喜剧之王\"}).populate('_creator').exec((err,story)=&gt;{ if(err)console.log(err); console.log(story._creator.name);})//使用populate来指定,外联查询的字段, 而且该值必须是_id才行 现在es6时代的来临, generator , async/await 盛行. 也带来另外一种书写方式–middleware. 在mongoose也有这个hook, 给我们使用. (说实话, 有点像AOP) mongoose &amp;&amp; middleware mongoose里的中间件,有两个, 一个是pre, 一个是post. * pre: 在指定方法执行之前绑定。 中间件的状态分为 parallel和series. * post: 相当于事件监听的绑定 这里需要说明一下, 中间件一般仅仅只能限于在几个方法中使用. (但感觉就已经是全部了) * doc 方法上: init,validate,save,remove; * model方法上: count,find,findOne,findOneAndRemove,findOneAndUpdate,update pre 我们来看一下,pre中间件是如何绑定的. 1234567// series执行, 串行var schema = new Schema(..);schema.pre('save', function(next) { // exe some operations this.model. next(); // 这里的next()相当于间执行权给下一个pre}); 在你调用 model.save方法时, 他会自动执行pre. 如果你想并行执行中间件, 可以设置为: 1234schema.pre('save', true, function(next, done) { // 并行执行下一个中间件 next();}); post 相当于绑定啦~ post会在指定事件后触发 1234schema.post('save', function(doc) { //在save完成后 触发. console.log('%s has been saved', doc._id);}); 当save方法调用时, 便会触发post绑定的save事件. 如果你绑定了多个post。 则需要指定一下中间件顺序. 1234567891011schema.post('save', function(doc, next) { setTimeout(function() { console.log('post1'); next(); }, 10);});schema.post('save', function(doc, next) { console.log('post2'); next();}); 实际上,post触发的时间为: 1234567891011var schema = new Schema(..);schema.post('save', function (doc) { console.log('this fired after a document was saved');});var Model = mongoose.model('Model', schema);var m = new Model(..);m.save(function (err) { console.log('this fires after the `post` hook');}); 另外,在post和find中, 是不能直接修改doc上的属性的. 即,像下面一样的,没有效果 1234articleSchema.post('find',function(docs){ docs[1].date = 1})docs[1].date 的值还是不变 不过可以使用虚拟属性,进行操作.","link":"/2017/11/02/mongoose%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95/"},{"title":"socket.io简易用法","text":"介绍Socket.io Socket.IO 是一个面向实时 web 应用的 JavaScript 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在浏览器中运行的客户端库，和一个面向Node.js的服务端库。两者有着几乎一样的API。像Node.js一样，它也是事件驱动的. Socket.IO主要使用WebSocket协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如Adobe Flash Sockets，JSONP拉取，或是传统的AJAX拉取，[2]并且在同时提供完全相同的接口。尽管它可以被用作WebSocket的包装库，它还是提供了许多其它功能，比如广播至多个套接字，存储与不同客户有关的数据，和异步IO操作。 可以使用npm（node 软件包）工具来安装。 优势 Socket.IO会自动选择合适双向通信协议，仅仅需要程序员对套接字的概念有所了解。 劣势 Socket.io并不是一个基本的、独立的、能够回退到其它实时协议的WebSocket库，它实际上是一个依赖于其它实时传输协议的自定义实时传输协议的实现。该协议的协商部分使得支持标准WebSocket的客户端不能直接连接到Socket.io服务器，并且支持Socket.io的客户端也不能与非Socket.io框架的WebSocket或Comet服务器通信。因而，Socket.io要求客户端与服务器端均须使用该框架。 使用Socket.io 安装 1npm install socket.io 直接node服务中使用 Server(app.js) 12345678910111213141516171819202122232425var app = require('http').createServer(handler)var io = require('socket.io')(app);var fs = require('fs');app.listen(80);function handler (req, res) { fs.readFile(__dirname + '/index.html', function (err, data) { if (err) { res.writeHead(500); return res.end('Error loading index.html'); } res.writeHead(200); res.end(data); });}io.on('connection', function (socket) { socket.emit('news', { hello: 'world' }); // 派发事件“news” socket.on('my other event', function (data) { console.log(data); }); // 接受Client派发的事件}); Client (index.html) 12345678&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://localhost'); socket.on('news', function (data) { console.log(data); socket.emit('my other event', { my: 'data' }); // 接受完“new” 事件之后 派发事件\"my other event\" });&lt;/script&gt; 使用Express 3/4 和 Express 2.x Server (app.js) 使用Express 3/4 12345678910111213141516var app = require('express')();var server = require('http').Server(app);var io = require('socket.io')(server);server.listen(80);app.get('/', function (req, res) { res.sendfile(__dirname + '/index.html');});io.on('connection', function (socket) { socket.emit('news', { hello: 'world' }); socket.on('my other event', function (data) { console.log(data); });}); Server (app.js) 使用Express 2.x 123456789101112131415var app = require('express').createServer();var io = require('socket.io')(app);app.listen(80);app.get('/', function (req, res) { res.sendFile(__dirname + '/index.html');});io.on('connection', function (socket) { socket.emit('news', { hello: 'world' }); socket.on('my other event', function (data) { console.log(data); });}); Client 都是一样的 12345678&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var socket = io.connect('http://localhost'); socket.on('news', function (data) { console.log(data); socket.emit('my other event', { my: 'data' }); });&lt;/script&gt; 发送和接受事件 Socket.io允许我们派发和接受自定义事件。除此之外，connect,message和disconnect， 你可一发送自定义事件 Server 1234567891011121314// 注意io(&lt;port&gt;) 会为你创建一个http服务var io = require('socket.io')(80);io.on('connection', function (socket) { io.emit('this', { will: 'be received by everyone'}); socket.on('private message', function (from, msg) { console.log('I received a private message by ', from, ' saying ', msg); }); socket.on('disconnect', function () { io.emit('user disconnected'); });}); 限制你自己的命名空间 如果您需要控制特定应用程序所以发出的消息和事件，可以使用默认或者命名空间来工作。如果你想用第三方代码或者产生代码来分享给他人使用，socket.io提供了命名一个socket的方法。 单个连接使用multiplexing是有好处的。一个socket连接来代替使用两个WebSocket连接。 Server (app.js) 12345678910111213141516171819var io = require('socket.io')(80);var chat = io .of('/chat') .on('connection', function (socket) { socket.emit('a message', { that: 'only' , '/chat': 'will get' }); chat.emit('a message', { everyone: 'in' , '/chat': 'will get' }); }); // 空间１var news = io .of('/news') .on('connection', function (socket) { socket.emit('item', { news: 'item' }); }); // 空间２ Client (index.html) 123456789101112&lt;script&gt; var chat = io.connect('http://localhost/chat') , news = io.connect('http://localhost/news'); // 分别链接两个命名空间 chat.on('connect', function () { chat.emit('hi!'); }); news.on('news', function () { news.emit('woot'); });&lt;/script&gt; 发送不稳定的消息 有时，有些消息会被丢失。比如说，你有一个应用程序，显示实时连接的关键字bieber 如果某个客户端没有准备好接收消息（可能是网络缓慢或其他问题， 或者他们处于长轮询连接并且处于请求阶段）。如果他没有收到所有消息，你的程序如何不受影响呢？ 在这种情况下，你也许需要发送一些不稳定信息 Server 1234567891011121314var io = require('socket.io')(80);io.on('connection', function (socket) { var tweets = setInterval(function () { getBieberTweet(function (tweet) { socket.volatile.emit('bieber tweet', tweet); }); }, 100); socket.on('disconnect', function () { clearInterval(tweets); });});// 就是一个定时器。。。加上volatila 客户端接收到了的话，肯定会有一个回调like: clearInterval(tweets) 发送和获取数据（确认） 有时，你也许想要客户端接收到消息发送一个回调来确认小安溪接收到了。OK，可以做到这一点 只需在.send， .emit后面添加一个回调函数fn Server (app.js) 1234567var io = require('socket.io')(80);io.on('connection', function (socket) { socket.on('ferret', function (name, fn) { fn('woot'); });}); Client (index.html) 12345678&lt;script&gt; var socket = io(); // TIP: io() with no args does auto-discovery socket.on('connect', function () { // TIP: you can avoid listening on `connect` and listen on events directly too! socket.emit('ferret', 'tobi', function (data) { console.log(data); // data will be 'woot' }); });&lt;/script&gt; 广播消息 要广播，直接在emit和send前面添加broadcast就可以了。广播意味着除了消息发送者，所有人都将获得这个消息 Server 12345var io = require('socket.io')(80);io.on('connection', function (socket) { socket.broadcast.emit('user connected');});","link":"/2017/11/06/socket.io%E7%AE%80%E6%98%93%E7%94%A8%E6%B3%95/"},{"title":"svg简介及svg与canvas对比","text":"SVG(scalable、vector、graphics)是XML语言的一种形式，有点类似XHTML，它可以用来绘制矢量图形。 SVG的基本应用 首先需要记住的是，svg在HTML中的写法是用的XML的语法，所以： 1. SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同） 2. SVG里的属性值必须用引号引起来，就算是数值也必须这样做。 svg文件的基本属性 svg渲染及压缩 元素的渲染顺序，SVG文件全局有效的规则是“后来居上”，越后面的元素越可见。 web上的svg文件可以直接展示，或者通过以下几种方法嵌入到HTML文件： HTML是XHTML，并且声明类型为application/xhtml+xml HTML是HTML5，并且浏览器支持HTML5，可以直接嵌入SVG 通过object引入SVG文件。&lt;object data=\"image.svg\" type=\"image/svg+xml\" /&gt; 通过iframe引入SVG文件。&lt;iframe src=\"image.svg\"&gt;&lt;/iframe&gt; 可以使用img元素，但是在低于4.0版本的Firefox中不起作用 最后SVG可以通过JavaScript动态创建并注入到HTML DOM中 svg有两种文件类型，一个是\".svg\"，一个是压缩的\".svgz\"。\".svgz\"在Firefox不能通过本地的机器加载，微软的IIS服务器对于gzip压缩的SVG文件，在用户代理上也不是很可靠。\".svgz\"多用于地图应用等需要大型SVG文件的应用。 SVG的坐标定位及窗口 svg的网格布局和canvas是一样的，都是以一个左上角为原点，向下和向右延申的。 正常情况下，svg的一个像素对应显示屏的一个像素，不过这种情况是可以改变的，我们需要定义viewBox。 1&lt;svg width=\"200\" height=\"200\" viewBox=\"0 0 100 100\"&gt; 上面的画板尺寸是200px*200px，画板展示区域是100px*100px，所以100*100的区域会在200*200的画布上展示。 svg基本形状 矩形 rect x 矩形左上角的x位置 y 矩形左上角的y位置 width 矩形的宽度 height 矩形的高度 rx 圆角的x方位的半径 ry 圆角的y方位的半径 圆形 circle r 圆的半径 cx 圆心的x位置 cy 圆心的y位置 椭圆 ellipse rx 椭圆的x半径 ry 椭圆的y半径 cx 椭圆中心的x位置 cy 椭圆中心的y位置 线条 line x1 起点的x位置 y1 起点的y位置 x2 终点的x位置 y2 终点的y位置 折线 polyline Polyline是一组连接在一起的直线。因为它可以有很多的点，折线的的所有点位置都放在一个points属性中： points 点集数列。每个数字用空白、逗号、终止命令符或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。 多边形 polygon polygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。 points 点集数列。每个数字用空白符、逗号、终止命令或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。 路径 &lt;path&gt;元素是SVG基本形状中最强大的一个，path只需要少量的点就能创建和规划流畅的曲线 path的形状通过属性'd'定义，属性d的值是一个“命令+参数”的序列。 每一个命令都用一个关键字母来表示，每一个命令有两种形式。一种是大写字母，表示采用绝对定位。另一种是小写字母，表示采用相对定位。 属性d采用的是用户坐标系统，所以不需标明单位。 直线命令 命令 功能 M x y (or m dx dy) 移动画笔坐标 L x y (or l dx dy) L命令将会在当前位置和新位置（L前面画笔所在的点）之间画一条线段 H x (or h dx) 标明在x轴移动到的位置 V y (or v dy) 标明在y轴移动到的位置 Z (or z) 从当前点画一条直线到路径的起点 曲线命令 有三个命令： * 三次贝塞尔曲线 * 二次贝塞尔曲线 * 圆的一部分 三次贝塞尔曲线 三次贝塞尔曲线需要定义一个点和两个控制点，所以用C命令创建三次贝塞尔曲线，需要设置三组坐标参数： C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy) 最后一个坐标(x, y)表示的是曲线的终点，另外两个坐标是控制点，(x1, y1)是起点的控制点，(x2, y2)是终点的控制点。 如何创建平滑的曲线呢？通常情况下，一个点是另一个点的控制点的堆成。这样，你就可以使用一个简写的贝塞尔曲线S: S x2 y2, x y (or s dx2 dy2, dx dy) ### 二次贝塞尔曲线 二次贝塞尔曲线只需要一个控制点。 Q x1 y1, x y (or q dx1 dy1, dx dy) 二次贝塞尔曲线简写T x y (or t dx dy)。 弧形 A rx ry x-axis-rotation large-arc-flag sweep-flag x y a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy x轴旋转角度（x轴旋转角度）, large-arc-flag（角度大小） 和sweep-flag（弧线方向） Fill和Stroke属性 这两个属性，可以用直接的css颜色，还有一个就是直接添加颜色的透明度。属性fill-opacity控制填充色的不透明度，属性stroke-opacity控制描边的不透明度。 描边 stroke-dasharray 是一组用逗号分割的数字组成的数列 1. 第一个用来表示填色区域的长度 2. 第二个用来表示非填色区域的长度 3. 继续定义增加长度 使用css 除了定义对象的属性外，你也可以通过CSS来样式化填充和描边。语法和在html里使用CSS一样，只不过你要把background-color、border改成fill和stroke。注意，不是所有的属性都能用CSS来设置。上色和填充的部分一般是可以用CSS来设置的，比如fill，stroke，stroke-dasharray等，但是不包括下面会提到的渐变和图案等功能。另外，width、height，以及路径的命令等等，都不能用css设置。判断它们能不能用CSS设置还是比较容易的。 可以利用:hover伪类完成触发效果。 渐变 线性渐变沿着直线改变颜色，要插入一个线性渐变，你需要在SVG文件的defs元素内部，创建一个&lt;linearGradient&gt; 节点。 还有径向渐变也类似，创建径向渐变需要在文档的defs中添加一个&lt;radialGradient&gt;元素。 图案 patterns（图案）是SVG中用到最让人混淆的填充类型。 剪切和遮罩 Clipping用来移除在别处定义的元素的部分内容。在这里，任何半透明效果都是不行的。它只能要么显示要么不显示。 Masking允许使用透明度和灰度值遮罩计算得的软边缘。 Web开发工具箱中有一个很有用的工具是display:none。它虽然几无悬念，但是依然可以在SVG上使用该CSS属性，连同CSS2定义的visibility和clip属性。为了恢复以前设置的display:none，知道这一点很重要：所有的SVG元素的初始display值都是inline。 其它SVG内容 嵌入光栅图像 很像在HTML中的img元素，SVG有一个image元素，用于同样的目的。你可以利用它嵌入任意光栅（以及矢量）图像。它的规格要求应用至少支持PNG、JPG和SVG格式文件。 嵌入的图像变成一个普通的SVG元素。这意味着，你可以在其内容上用剪切、遮罩、滤镜、旋转以及其它SVG工具： 嵌入任意XML 因为SVG是一个XML应用，所以你总是可以在SVG文档的任何位置嵌入任意XML。但是你没有必要定义周围的SVG需要怎样反作用于这个内容。 滤镜效果 有一种情况，基本形状不能提供你想要达到的效果的灵活性。投阴影、提供一个十分流行的示例，利用一个小变组合无法合理地创建它。滤镜是SVG的机制，允许创建精密的效果。 字体 字体中需要了解的就是text-path,即tref样式化。 svg和canvas对比 这部分参考W3school Canvas 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 参考 * MDN的svg教程 * W3school的svg教程","link":"/2018/07/30/svg%E7%AE%80%E4%BB%8B%E5%8F%8Asvg%E4%B8%8Ecanvas%E5%AF%B9%E6%AF%94/"},{"title":"touch事件&&mouse事件&&PC端&&移动端总结","text":"最近几天看的东西比较杂，抽空做下小总结。本来想研究下PC端的mousedown，mousemove，mouseup在移动端的浏览器的表现，如何用touch来替代，结果不知不觉，重新看了下JS高程的事件处理章节，关于各种浏览器的clinetX,pageX也看了不少，接下来就做下总结了。 # touches对象的各种参数 ## 触摸事件 * touchstart: 手指放在屏幕上的时候出发：即使已经有一个手指放在屏幕上也会触发。 * touchmove：当手指在屏幕上连续地出发。期间调用preventDefault()会阻止默认滚动。 * touchend：当手指从屏幕上移开时出发。 * touchcancel：当系统停止跟踪触摸时出发。 这几个事件都会冒泡，也都能取消。 下面放一下移动端跟踪触摸的时候三个event事件属性。 * touches：表示当前跟踪的触摸操作的Touch对象的数组。 * targetTouches：特定于事件目标的Touch对象的数组。 * changedTouches：表示自上次触摸以来发生改变的Touch对象的数组。 touches 下面是touches属性介绍： 属性 属性含义 clientX, Y 触摸目标在视口中的x, y坐标，不包括任何滚动偏移 force 触摸手指挤压触摸平面的压力大小0.0-1.0之间 identifier 表示触摸的唯一ID pageX, Y 触摸目标在页面中的x, y坐标 radiusX, Y 能够包围用户和触摸平面的接触面的最小椭圆的水平轴(X轴),垂直轴(Y轴)半径 rotationAngle 上述椭圆的能精准覆盖用户与触摸平面的接触面的角度，取值0-90之间 screenX, Y 返回触点相对于屏幕左边沿的的X, y坐标. 不包含页面滚动的偏移量 target 触摸touchstart触摸在屏幕上返回的element mouse事件的各种参数 DOM3级事件中有九个鼠标事件，顺便放一下事件速查表. 事件名 触发条件 click 用户点击主鼠标按钮或者按下回车键触发 dbclick 用户双击主鼠标按钮触发 mousemove 鼠标指针在元素内部移动时重复触发 mouseup 用户释放鼠标shi mousedown 用户按下任意鼠标按钮触发，不能通过键盘触发这个事件 mouseenter 指针移到有事件监听的元素内（不冒泡） mouseleave 指针移出元素范围外（不冒泡） mouseover 指针移到有事件监听的元素或者它的子元素内 mouseout 指针移出元素，或者移到它的子元素上 这里了解一下click的顺序，mousedown -&gt; mouseup -&gt; click。这里click是依赖先行事件mousedown，mouseup运行的。也就是说，假如我们的拖动的div上绑定有一个click事件，拖动的过程中，就会在mouseup后面触发click事件。所以我们可以将click事件绑定到mouseup上面，判断是否有mousemove来考虑触发click上绑定的事件的时机。 事件处理，事件监听，事件委托 DOM事件流规定中，事件流包含三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。在DOM事件流中，实际的元素在捕获阶段不会接收到事件。这意味着事件处理会被当做冒泡阶段的一部分。 事件处理的几种常见方法 1. HTML事件处理程序 直接在html上绑定一个事件，事件处理程序一般以'on'开头。 123456789&lt;!-- 绑定执行语句 --&gt;&lt;input type=\"button\" value=\"click me\" onclick=\"alert('clicked')\"/&gt;&lt;!-- 绑定函数 --&gt;&lt;input type=\"button\" value=\"click me\" onclick=\"showMessage()\" /&gt;&lt;script&gt; function showMessage() { alert('clickclickclicked!') }&lt;/script&gt; 上述事件处理程序会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象。 通过event变量，可以直接访问到事件对象，你不用从函数的参数列表读取。在函数内部，this等于事件的目标元素。那么这里需要注意了，事件处理函数中的this指向的问题。所以在需要添加到this的函数中，我们有时会用词法作用域context来保存需要调用的上下文。像上一篇文章中函数节流，就用到了相关保存运行时this的方法。 2. DOM 0级事件处理 使用传统的JavaScript指定事件处理方式，先获取到相关的需要操作对象的引用。 每个元素都有自己的事件处理程序属性，这些属性通常全部小写。 12345678var btn = document.getElementById('myBtn');btn.onclick = function() { alert('this.id'); // 'myBtn'}// 清空事件绑定btn.onclick = null; 这种形式添加的事件处理程序会在事件流的冒泡阶段被处理。 3. DOM 2级事件处理程序 所有的DOM节点都包含两个方法，addEventListener()和removeEventListener()，并接受三个参数：事件名，作为事件处理程序的函数和一个布尔值。 123456789101112131415161718var btn = document.getElementById('myBtn');btn.addEventListener('click', function() { console.log('hello hdd');}, false);btn.removeEventListener('click', function() { // 没有用 console.log('hello hdd');}, false);// 上述代码无法删除相关的事件处理函数，因为两个匿名函数不是同一个函数了。var btn = document.getElementById('myBtn');var handler = function() { console.log('hello hdd');};btn.addEventListener('click', handler, false);btn.removeEventListener('click', handler, false); 事件对象 event对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过所有事件都会有下表列出的成员。下表的属性都是只读的。 属性/方法 类型 说明 bubbles Boolean 表明事件是否冒泡 cancelable Boolean 表明是否可以取消事件的默认行为 currentTarget Element 其事件处理程序当前正在处理的那个元素 defaultPrevented Boolean 是否调用preventDefault() detail Integer 与事件相关的细节信息 eventPhase Interger 调用事件处理程序的阶段：1.捕获阶段2.处于目标3.冒泡阶段 preventDefault() Function 取消事件的默认行为。如果cancelable是true，则可以使用这个方法 stopImmediatePropagation() Function 取消事件的进一步捕获或冒泡，同时阻止任何使劲按处理程序被调用 stopPropagation Function 取消使劲按的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法 target Element 事件的目标 trusted Boolean true表示浏览器生成的，false表示开发者通过JavaScript创建的 type String 被触发的事件类型 view AbstractView 与事件关联的抽象试图。等同于发生对象的window对象 在事件处理程序的内部，this始终等于currentTarget的值，而target则只包含事件的实际目标。下面点击子元素： 1. 子元素绑定事件处理程序，父元素绑定事件处理函数。currentTarget等于父元素，target等于子元素 2. 子元素不绑定事件处理程序，父元素绑定事件处理函数。currentTarget等于父元素，target等于子元素 3. 子元素绑定事件处理程序，父元素不绑定事件处理函数。currentTarget等于子元素，target等于子元素 下面看几种常见的事件处理的冒泡次序： 12345678910111213var btn = document.getElementById('myBtn');btn.onclick = function(event) { alert(event.eventPhase); // 2};document.body.addEventListener('click', function(event) { alert(event.eventPhase); // 1}, true);document.body.onclick = function(event) { alert(event.eventPhase); // 3}; 最后，事件处理程序执行期间，event对象一直存在，一旦事件处理程序执行完成，event对象就会销毁。 事件委托 想页面添加大量的事件处理程序会占用大量的内存，内存中的对象越多，性能也就越差。而且，必须事先指定所有事件处理程序而导致的DOM访问次数会延迟整个页面的交互就绪时间。 要理解事件委托，事件冒泡和捕获必须梳理一下。 当一个事件发生在具有父元素的元素导航，现代浏览器运行两个不同的阶段-捕获阶段和冒泡阶段。 在现代浏览器中，默认情况下，多有时间处理程序都在冒泡阶段注册，因此当我们点击子元素的时候。会沿着这个事件冒泡线路： * 发现了子元素的事件处理程序，并运行了它。 * 往外冒泡发现父元素的事件处理程序，并运行它。 避免这个问题的方法就是使用stopPropagation()修复问题。 利用了事件冒泡会发现父元素的事件处理程序。我们就可以利用事件委托。 如果我们有大量子元素，想要点击任何一个都可以运行一段代码，可以将事件监听器设置在父节点元素，而且对于新添加的元素，事件委托很好的能为动态添加的元素动态的绑定事件处理函数。下面是例子 12345&lt;ul id=\"lists\"&gt; &lt;li id=\"list1\"&gt;列表第一项&lt;/li&gt; &lt;li id=\"list2\"&gt;列表第二项&lt;/li&gt; &lt;li id=\"list3\"&gt;列表第三项&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617var list = document.getElementById('lists');document.addEventListener('click',function(event) { // 也可以绑定lists元素 var target = event.target; switch(target.id) { case 'list1': console.log(target.innerHTML); break; case 'list2': console.log('我是第二项'); break; case 'list3': alert('hello world'); break; }}) 浏览器中事件相关的常见几种位置坐标 clientX/Y 获取到的是触发点相对浏览器可视区域左上角距离，不随页面滚动而改变。 pageX/Y pageX/Y获取到的是触发点相对文档区域左上角距离，会随着页面滚动而改变。 offsetX/Y offsetX/Y获取到是触发点相对被触发dom的左上角距离，不过左上角基准点在不同浏览器中有区别，其中在IE中以内容区左上角为基准点不包括边框，如果触发点在边框上会返回负值，而chrome中以边框左上角为基准点。 layerX/Y layerX/Y获取到的是触发点相对被触发dom左上角的距离，数值与offsetX/Y相同，这个变量就是firefox用来替代offsetX/Y的，基准点为边框左上角，但是有个条件就是，被触发的dom需要设置为position:relative或者position:absolute，否则会返回相对html文档区域左上角的距离。 screenX/Y screenX/Y获取到的是触发点相对显示器屏幕左上角的距离，不随页面滚动而改变。 一个图解释： 简单的移动端/PC端拖动代码 上面的代码中，我将事件的type做了一下判断，进而绑定相关的。 关于拖拽事件的常见bug及处理方式 介绍下常见的，拖拽小问题。 1. 鼠标移动过快，离开拖拽物体 由于拖拽的div太小了，拖拽物体不在随着鼠标移动，前面介绍事件的时候也提到了，鼠标移动元素，mousemove事件不再触发，这时我们可以将拖拽物体上的mousemve事件放到document上面，同时将mouseup也改为document上面的事件 2. 会出现将div脱出浏览器窗口 限制div的拖动距离 还有一些常见bug，一般阻止默认事件都可以解决。 部分参考 http://www.cnblogs.com/moqiutao/p/5050225.html http://www.cnblogs.com/yufann/p/JS-Summary9.html","link":"/2018/07/12/touch%E4%BA%8B%E4%BB%B6-mouse%E4%BA%8B%E4%BB%B6-PC%E7%AB%AF-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/"},{"title":"webpack基础(二):认识Webpack","text":"Webpack 基础第二部分，认识 Webpack 。从最简单的一个 index.js 文件认识 Webpack。 在开始了解 Webpack 核心概念之前，让我们先看看 Webpack 的生成文件。 我们先讨论的最简单的 js 文件，不包含 html 及 Webpack jsonp 等加载知识。 index.js 入口文件 我定义了一个最简单的 index.js 作为入口文件。 1234567891011121314151617/* index.js */import nav from './nav';import { top, bottom } from './footer';console.log(nav(), top, bottom);/*********************************************//* footer.js */const top = 'top';const bottom = 'bottom';module.exports = { top, bottom };/*********************************************//* nav.js */export default () =&gt; 'nav';/*********************************************/ 这里我们就能够跑一下 Webpack 生成对应的 runtime 文件（要先安装 webpack-cli 哦）： 12$ yarn add webpack-cli webpack$ npm run webpack -- --mode development 生成 WebpackBootstrap 代码 下面来对应的分析下dist目录下的生成代码（代码经过精简）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135(function(modules) { // Webpack引导 // 1. 模块缓存 var installedModules = {}; // 2. The require function function __webpack_require__(moduleId) { // 检查请求模块是否在缓存中，如果在，直接返回缓存中模块 if (installedModules[moduleId]) { return installedModules[moduleId].exports; } // 创建一个新的模块（并将新创建的模块放入缓存中） var module = (installedModules[moduleId] = { i: moduleId, l: false, exports: {} }); // 执行模块 modules[moduleId].call( module.exports, module, module.exports, __webpack_require__ ); // 标记模块为已加载完成 module.l = true; // 返回模块的 exports return module.exports; } // 3. 公开模块对象 (__webpack_modules__) __webpack_require__.m = modules; // 4. 公开模块缓存 __webpack_require__.c = installedModules; // 5. 为 harmony exports(ES module exports) 定义 getter 函数 __webpack_require__.d = function(exports, name, getter) { if (!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { configurable: false, enumerable: true, get: getter }); } }; // 6. 为 exports 定义 __esModule 属性 __webpack_require__.r = function(exports) { Object.defineProperty(exports, '__esModule', { value: true }); }; // 7. 定义 getDefaultExport function 用来兼容 non-harmony modules __webpack_require__.n = function(module) { var getter = module &amp;&amp; module.__esModule ? function getDefault() { return module['default']; } : function getModuleExports() { return module; }; __webpack_require__.d(getter, 'a', getter); return getter; }; // 8. Object.prototype.hasOwnProperty.call __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; // 9. __webpack_public_path__ __webpack_require__.p = ''; // 10. 加载入口模块并返回 exports return __webpack_require__((__webpack_require__.s = './src/index.js'));})( /************************************************************************/ /******/ { /***/ './src/footer.js': /*!***********************!*\\ !*** ./src/footer.js ***! \\***********************/ /*! no static exports found */ /***/ function(module, exports) { eval( `const top = 'top'; const bottom = 'bottom'; module.exports = { top, bottom }; //# sourceURL=webpack:///./src/footer.js?` ); /***/ }, /***/ './src/index.js': /*!**********************!*\\ !*** ./src/index.js ***! \\**********************/ /*! no exports provided */ /***/ function(module, __webpack_exports__, __webpack_require__) { 'use strict'; eval( `__webpack_require__.r(__webpack_exports__); /* harmony import */ var _nav__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nav */ \"./src/nav.js\"); const { top, bottom } = __webpack_require__(/*! ./footer */ \"./src/footer.js\"); console.log(Object(_nav__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(), top, bottom); //# sourceURL=webpack:///./src/index.js?` ); /***/ }, /***/ './src/nav.js': /*!********************!*\\ !*** ./src/nav.js ***! \\********************/ /*! exports provided: default */ /***/ function(module, __webpack_exports__, __webpack_require__) { 'use strict'; eval( `__webpack_require__.r(__webpack_exports__); /* harmony default export */ __webpack_exports__[\"default\"] = (() =&gt; \"nav\"); //# sourceURL=webpack:///./src/nav.js?` ); /***/ } /******/ }); 分析 WebpackBootstrap 上面的生成的代码主要生成了一个大的 IIFE （立即执行函数）。观察可以发现，三个 js 文件被封装成了三个函数传给这个 IIFE 立即执行函数。Webpack 通过 IIFE 函数作用域来实现模块化。 执行过程是： 定义模块缓存 定义 __webpack_require__ 函数 检查请求模块是否在缓存中，如果在，直接返回缓存中模块 创建一个新的模块（并将新创建的模块放入缓存中） 执行模块 标记模块为已加载完成 返回模块的 exports 定义公开模块对象 (__webpack_require__.m) 公开模块缓存 (__webpack_require__.c) 为 harmony exports (ES module exports) 定义 getter 函数 为 exports 定义 __esModule 属性 定义 getDefaultExport function 用来兼容 non-harmony modules Object.prototype.hasOwnProperty.call 定义__webpack_public_path__ 加载入口模块并返回 exports 其中，第 10 步调用入口模块之后，可以看到，传入的参数的函数中，模块的请求，继续调用__webpack_require__,实现了一个递归调用和解析模块，递归完成之后，Webpack 也就能生成对应的模块依赖图，相关的调用关系也就很清晰了。 因为有了模块缓存机制，所以请求过的模块执行过一次之后，就会加入installedModules中，下次调用所需模块就会直接从缓存对象中提取。 Webpack 模块加载对 ESM 和 CommonJs 的实现对比 12345678910111213141516171819202122232425262728293031// index.jsfunction(module, __webpack_exports__, __webpack_require__) { 'use strict'; eval( `__webpack_require__.r(__webpack_exports__); /* harmony import */ var _nav__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nav */ \"./src/nav.js\"); const { top, bottom } = __webpack_require__(/*! ./footer */ \"./src/footer.js\"); console.log(Object(_nav__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(), top, bottom); //# sourceURL=webpack:///./src/index.js?` );},// nav.jsfunction(module, __webpack_exports__, __webpack_require__) { 'use strict'; eval( `__webpack_require__.r(__webpack_exports__); /* harmony default export */ __webpack_exports__[\"default\"] = (() =&gt; \"nav\"); //# sourceURL=webpack:///./src/nav.js?` );}// footer.jsfunction(module, exports) { eval( `const top = 'top'; const bottom = 'bottom'; module.exports = { top, bottom }; //# sourceURL=webpack:///./src/footer.js?` );}, 上面代码__webpack_require__.r(__webpack_exports__)标记了这个模块使用了 ESM ，关于 ESM 的使用方法，定义的__webpack_require__中，去调用nav.js, __webpack_exports__[\"default\"] = (() =&gt; \"nav\"); 通过定义在'default'上的函数来封装了返回的值，只有在需要调用的时候，再进一步去执行获取值，而 footer.js 则是直接执行获取了module.exports = { top, bottom };。 关于 ESM 和 CommonJS 的互相引用则是利用了__webpack_require__.n来进行包装获取对应的 modules 对象的值。可以看对应的代码。 =&gt; 7. 定义 getDefaultExport function 用来兼容 non-harmony module 最后，上面的生成的 WebpackBootstrap 代码 强烈建议放在浏览器的 devtools 的 snippet 中打上断点运行一遍来细细的感受一下。","link":"/2019/04/03/webpack%E5%9F%BA%E7%A1%802/"},{"title":"webpack基础(一)：为什么选择Webpack","text":"这是半个月前在 FrontendMasters 看的 Webpack 视频，过了半个月，做一下总结以及回顾。这篇时第一部分，Webpack 基础。 script 标签加载问题 难题 回到没有前端工具的最原始的时代，如果我们有一段 Javascript 代码，我们有两种方式加载它： 直接在 html 书写这段 script。 使用&lt;script src=\"*.js\"&gt;&lt;/script&gt; 随之带来的问题有： 无法被压缩。 过多的script标签。 在 HTTP1.1 情况下，浏览器的同时最大连接数为: version Maximun connections Internet Explorer® 7.0 2 Internet Explorer 8.0 and 9.0 6 Internet Explorer 10.0 8 Internet Explorer 11.0 13 Firefox® 6 Chrome™ 6 Safari® 6 Opera® 6 iOS® 6 Android™ 6 脚本难以维护。 作用域 脚本尺寸 可读性 及其脆弱 整体文件过大 解决方法？ 这时 IIFE（Immediately Invoked Function Expression）立即执行函数出现在人们眼前。 一个最简单的 IIFE 函数： 1234567891011121314var outerScope = 1;const whatever = function(dataNowUsedInside) { outerScope = 4; return { someAttribute: 'youwant' };};console.log(outerScope);// &gt; 1// 内部赋值没有影响外部作用域// whatever.someAttribute// &gt; 'youwant' 那么现在我们需要做的就是，把每一个文件都当作一个 IIFE（揭示模块）调用。 现在我们可以利用 Make, Grunt, Gulp, Broccoli, Brunch, StealJS 等 “安全” 的组合文件，而不用担心作用域冲突。但是，这样就完美了吗？ 这样大量的使用 IIFE，也带来了很多 问题 ： 每一次文件改变都需要所有 IIFE 全部执行一遍。 DEAD CODE: 连接文件并没有助于我们跨文件使用代码。利用使用 lodash.js 等库，需全部加载。 大量使用 IIFE，调用会非常慢。 只能同步加载，没有异步加载，无法实现 lazy code。 模块的历史 伴随着 Node.js 诞生的 CommonJs ( Module 1.0 )。采用静态语法分析，使用 NPM + Node + Modules 的生态。 Node.js 的 CommonJs 存在的问题: 不支持浏览器 没有活动绑定，存在循环引用的问题。 模块同步解析加载，会很慢。 不支持浏览器的解决方法 使用类似 Browserify (static) 工具。 使用 RequireJS (loader)。 使用 SystemJS (loader)。 模块同步解析加载的难题 CommonJS 模块方式不支持静态异步/延迟加载，所有模块都绑定在文件顶部。 在浏览器中，我们则需要动态的 CommonJS 。 浏览器中，可以使用 AMD 模块， 或者还有 AMD + CommonJS 方式。不过这些方式对于需要延迟加载的模块来讲还是太同步了。而且，这么多种上传方式，没有一种标准的语法，没有一个真正的模块系统。 ESM（EcmaScriptModule）模块 ESM 的出现解决了 CommonJS 的不支持静态异步和延迟加载功能。 1234import { uniq, forOf, bar } from 'lodash-es';import * as utils from 'utils';export const uniqConst = uniq([1, 2, 3, 4]); 现在我们直接看下 ESM 的优点： 可重复使用。 良好的封装性。 易于组织。 便于使用。 当然 ESM 也有缺点： ESM 在 Node 的模块中，使用的很少。 ESM 可以直接在浏览器中使用，但非常非常非常慢。（因为经常容易出一些错，使代码崩溃）。 除此之外，还有一些问题，每一个库的作者都有自己喜欢的模块加载方式，代码也是不同的。目前为止我们讨论的都是 JavaScript 。到目前为止，每种文件类型都必须有处理它的特定方法。所以接下来就要介绍 Webpack 了。 介绍 Webpack Webpack 是模块打包器，可以让你编写任意的模块格式，甚至混合的格式，通过 Webpack 打包，使浏览器能够读取他们。 Webpack 支持 静态异步打包 ，而且它具有丰富的生态系统，可以说是今天发布 JavaScript 的最佳方式了。 Webpack 诞生于 modules-webmake, 为了给 modules-webmake 添加 Code splitting ，诞生了 Webpack。 配置 Webpack 所以如何配置 Webpack 呢？ 使用 config ，如 webpack.config.js ，配置文件本身就是一个模块。 12345678910module.exports = { entry: { vendor: './src/vendors.ts', main: './src/main.browser.ts' }, output: { path: 'dist/', filename: '[name].bundle.js' }}; 使用 Webpack-Cli 。 123$ webpack &lt;entry.js&gt; &lt;result.js&gt; --colors --progress$ webpack-dev-server --port=9000 Node Api。 12345678910111213var webpack = require('webpack');// returns a Compiler instancewebpack( { // configuration object here! }, function(err, stats) { // … // compilerCallback console.error(err); }); 引用 slides Webpack 4 Fundamentals video webpack-workshop-2018","link":"/2019/03/30/webpack%E5%9F%BA%E7%A1%80-1/"},{"title":"wepy开发微信小程序总结","text":"项目源代码 https://github.com/hddhyq/One-per-day 项目截图 认识wepy和微信小程序 wepy 相对于小程序原生开发框架相比有很多优点，缺点也许也有，这里我们先看看优点，毕竟可以wepy和微信自带的框架混合开发。 * 开发风格 接近于 Vue.js，支持组件 Props 传值，自定义事件、组件分布式复用Mixin、计算属性函数computed、模板内容分发slot等等 组件化、第三方npm资源自动处理依赖关系、支持ES2015(Promise/Class/Async)等 对小程序本身的优化、支持样式编译器: Less/Sass/Stylus, 模板编译器：wx-ml/Pug，代码编译器：Babel/Typescript。支持插件如：文件压缩和图片压缩 至于细节还是去访问官网比较好。 * wepy文档 * 微信小程序文档 scroll-view 必须指定高度 开发电影下拉加载的时候，scroll-view 没给高度，拉到页面底部没有触发新的数据请求，解决方法： 123456.scroll-container position: absolute top: 0 right: 0 bottom: 0 left: 0 小程序页面hidden不能用于flex布局 解决方法：将flex布局的view 重新包裹上一层view wepy孙子组件的传值 wepy的传值给孙子组件，孙子组件没有及时跟新，最后放弃了孙子组件，将本来的孙子组件一起写到了父组件。 wepy的组件style不能添加scoped 给组件添加了scoped，不能正确显示相关的style，解决方法是把子组件的scoped去掉了。应该是scoped重复了两次，引用组件的时候应该不让组件scoped生成，或者父组件不对子组件引用添加scoped前缀，个人猜测。 wepy props的传值 在评星组件中，传入数值的时候 1&lt;rating :score.sync=&quot;score&quot;&gt;&lt;/rating&gt; score是数值，结果传递了一个对象的属性，传值失败，结果最后将分数单独设置为一个data中的Number类型的数据，传值成功。 swiper的高度及跳转 图文的详情本来是想用swiper来作为项目容器，结果swiper组件的高度，必须固定，而我的图文详情页的高度没有固定，第二点，并没有查阅到swiper的跳转功能，那我在首页点击的图片进入的图片还是第一张，最后放弃了swiper这个想法，不过总的来说，swiper主要还是用来放几张图片在首页轮播的。 关于图文详情页的跳转 oneDetail 最后实现的只是数据改变，重新绘制页面，想的是实现swiper图片的切换效果，这里没有实现。不过有一个想法，把页面的宽度设置为300%的宽度，也就是三张图片的宽度，然后进行切换页面的transformＸ轴的计算和页面滑动用js相关联进行计算，上下两张图片再用懒加载，这样就实现了页面的切换。","link":"/2017/12/27/wepy%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%BB%E7%BB%93/"},{"title":"webpack 基础(四)： 简单配置","text":"webpack 基础最后一篇，总结了一些loader和plugin的使用。 分割开发环境配置文件 开发环境中需要更具对应的开发环境选择相应的配置文件，这里总结了下简单的根据环境的配置文件。 12345678910111213141516171819/* webpack.config.js */const path = require(\"path\");const webpack = require(\"webpack\");const webpackMerge = require(\"webpack-merge\");const loadPresets = require(\"./build-utils/loadPresets\");const modeConfig = env =&gt; require(`./build-utils/webpack.${env}`)(env);const HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = ({ mode, presets } = { mode: \"production\", presets: []}) =&gt; { webpackMerge( { mode, plugins: [new HtmlWebpackPlugin(), new webpack.ProgressPlugin()] }, modeConfig(mode), loadPresets({ mode, presets }) )} 配置了上面的环境，可以通过命令行传值给 env 的时候，对应的调用相应的 webpack.&lt;config&gt;.js。 当让也可以设置一个通用 webpack.base.js 配置。再配置 webpack.prod.js 和 webpack.dev.js，对应的配置文件中，合并 webpack.base.js。 两种方式都可以使用，如何配置看个人啦。 使用Webpack处理CSS 首先需要在我们的webpack配置文件中，添加对应rules。 12345678910// ...module: { rules: [ { test: /\\.css$/, use: [ \"css-loader\" ] } ] },// ... 下面我们写一个最简单的css文件，并在一个文件中引用，并打印下来，可以看到 1234567import css from './style.css';console.log(css);/* 转换css文件 */0: (3) [\"./src/footer.css\", \"header {↵ background: #fff;↵}↵↵footer {↵ background: #000;↵}↵\", \"\"]i: ƒ (modules, mediaQuery)toString: ƒ toString() 紧接着我们在之前的 rules 添加 style-loader。 1234{ test: /\\.css$/, use: [ \"style-loader\", \"css-loader\" ]} 在浏览器打开我们的页面，可以看到，&lt;head&gt;&lt;/head&gt; 之间添加了之前定义的css内容。 123456789&lt;style type=\"text/css\"&gt;header { background: #fff;}footer { background: #000;}&lt;/style&gt; 多个css文件的引入，最终打包成的一个css文件，并且引入标签引入。 FileLoader&amp;UrlLoader 现在假如我们想在页面中引入一个 那么在配置文件中添加 12345678910/* webpack.config.js =&gt; rules */{ test: /\\.jpe?g$/, use: [\"url-loader\"]}/* index.js */import image from './webpack-logo.jpg';console.log(image); 我们可以打印出来 base64 格式的图片数据： 1data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBMRXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAADaqADAAQAAAABAAAD3QAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/... 现在，如果我们想加载一个图片的话，把引用的 image 赋值给对应的 src 属性就可以了。不过这里我们可以看到一些问题，那就是，直接的图片引用转换成 base64 太大了。我引用的图片的大小是100kb，转换后还会大约增加1/3的体积，所以下面需要限制直接装换成 base64 图片的大小。回到 webpack.config.js: 123456{ loader: \"url-loader\", options: { limit: 5000 }} 应用预设presets 我们的打包过程经常需要，根据不同的流程添加不同的插件，所以我们可以设置一个 loadPresets.js 来动态加载我们所需的 plugins 或 loader 等。 123456789101112131415/* build-utils/loadPresets.js */const webpackMerge = require(\"webpack-merge\");const applyPresets = (env = {presets: []}) =&gt; { const presets = env.presets || []; /** @type {string[]} */ const mergedPresets = [].concat(...[presets]); const mergedConfigs = mergedPresets.map(presetName =&gt; require(`./presets/webpack.${presetName}`)(env) // call the preset and pass env ); return webpackMerge({}, ...mergedConfigs);};module.exports = applyPresets; 有了这个插件加载，配上我们的 npm scripts 就能很好的加载插件了: 1234{ \"prod\": \"npm run webpack -- --env.mode production\", \"prod:typescript\": \"npm run prod -- --env.presets typescript\",} 如上所示，我们需要，prod 的时候打包对应的 typescript 文件，这样的命令就能加载对应的组件。有了这个，我们可以根据需求，动态的加载所需的多种预设了。 添加打包分析插件 1yarn add -D webpack-bundle-analyzer 1234{ \"prod\": \"npm run webpack -- --env.mode production\", \"prod:analyze\": \"npm run prod -- --env.presets analyze\",} 添加文件: 12345const WebpackBundleAnalyzer = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;module.exports = () =&gt; ({ plugins: [ new WebpackBundleAnalyzer() ]}) SourceMaps SourceMaps 可以根据不同的环境，添加不同的 SourceMaps 到 presets ，这样，根据不同的开发目的（调试，正常开发，生产环境等），可以使用不同的 SouceMaps。 总结 webpack基础篇总结结束，后面会加上 webpack进阶篇。 可以到 https://github.com/webpack-contrib 找优秀的loader和plugins哦。","link":"/2019/04/18/webpack%E5%9F%BA%E7%A1%804/"},{"title":"vue-music目录及样式初始化","text":"目录初始化 常用目录 api base common fonts image js stylus components router store actions getters index mutation-types mutations state api 放置后端获取数据的js文件，常用方式有jsonp/axios。 * jsonp的github * axios的github ### base 存放常用的可复用的基础component ### common 存放网页所需字体，图片，复用的js文件，和css样式文件。 其中需要注意stylus文件引用顺序 123@import &quot;./reset.styl&quot;@import &quot;./base.styl&quot;@import &quot;./icon.styl&quot; ### components 存放网页所需component ### router 存放网页路由文件 ### store 存放网页vuex的共享数据 eslint常用配置 eslint规则 可以在官网查询配置相关规则 12345678910'rules': { // allow paren-less arrow functions 'arrow-parens': 0, // allow async-await 'generator-star-spacing': 0, // allow debugger during development 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, 'eol-last': 0, 'space-before-function-paren': 0 } eslint规则的等级有三种: * \"off\" 或者 0：关闭规则。 * \"warn\" 或者 1：打开规则，并且作为一个警告（不影响exit code）。 * \"error\" 或者 2：打开规则，并且作为一个错误（exit code将会是1）。 我们所配置的rules: * arrow-parens: 要求箭头函数的参数使用圆括号 * generator-star-spacing: 强制 generator 函数中 * 号周围使用一致的空格 * no-debugger: 禁用debugger * eol-last: 要求或禁止文件末尾存在空行 * space-before-function-paren: 强制在 function的左括号之前使用一致的空格 webpack.base.conf 配置引用别名 配置别名，项目中引用不用添加src了。 12345678910resolve: { extensions: ['.js', '.vue', '.json'], alias: { '@': resolve('src'), 'common': resolve('src/common'), 'components': resolve('src/components'), 'base': resolve('src/base'), 'api': resolve('src/api') } },","link":"/2017/10/12/vue-music%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%A0%B7%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"《Web性能权威指南》读书总结","text":"总结了针对 HTTP 1.x 和 HTTP 2.0 的优化，以及 HTTP 2.0 的一些历史。 Web性能优化要点 宏观的 Web 性能优化 延迟和带宽对 Web 性能的影响； 传输协议（TCP）对 HTTP 的限制； HTTP 协议自身的功能和缺陷； Web 应用的发展趋势及性能需求； 浏览器局限性和优化思路。 页面加载时间，是来衡量 Web 性能的事实标准。页面加载时间常简写为PLT（Page Load Time）。 PLT 的简单定义就是：“浏览器中的加载旋转图标停止旋转的时间。”更技术的定义则是浏览器中的 onload 事件，这个事件由浏览器在文档及其所有依赖资源（JavaScript、图片，等等）下载完毕时触发。 除了测量每个资源及整个页面的加载时间（PLT），还要关注有关应用的如下几 个问题： 应用加载过程中的里程碑是什么？ 用户第一次交互的时机何在？ 什么交互应该吸引用户参与？ 每个用户的参与及转化率如何？ 接下来我们了解一下 脚本、样式表和标记文档之间复杂依赖 : 浏览器在解析 HTML 文档的基础上构建 DOM（Document Object Model，文档对象模型） 。与此同时，还有一个常常被忽略的模型—— CSSOM（CSS ObjectModel，CSS 对象模型） ，也会基于特定的样式表规则和资源构建而成。这两个模型共同创建“渲染树”，之后浏览器就有了足够的信息去进行布局，并在屏幕上绘制图形。到目前为止，一切都很好理解。 然而，此时不得不提到我们最大的朋友和祸害： JavaScript 。脚本执行过程中可能遇到一个同步 document.write ，从而阻塞 DOM 的解析和构建。类似地，脚本也可能查询任何对象的计算样式，从而阻塞 CSS 处理。结果，DOM 及 CSSOM的构建频繁地交织在一起：DOM 构建在 JavaScript 执行完毕前无法进行，而 JavaScript 在 CSSOM 构建完成前也无法进行 。 应用的性能，特别是首次加载时的 “渲染前时间” ，直接取决于标记、样式表和JavaScript 这三者之间的依赖关系。顺便说一句，还记得流行的“样式在上，脚本在下”的最佳实践吗？现在你该知道为什么了。渲染和脚本执行都会受样式表的阻塞，因此必须让 CSS 以最快的速度下载完。 剩下就是要知道，延迟是性能瓶颈 。减少延迟是Web性能优化的关键。分析资源瀑布图，对资源进行合理的分配。 HTTP 1.x 放在前面的Steve Souder 的《高性能网站建设指南》中概括了 14 条规则，有一半针对网络优化： * 减少DNS查询 每次域名解析都需要一次网络往返，增加请求的延迟，在查询期间会阻塞请求。 减少HTTP请求 任何请求都不如没有请求更快，因此要去掉页面上没有必要的资源。 使用CDN 从地理上把数据放到接近客户端的地方，可以显著减少每次 TCP 连接的网络延迟，增加吞吐量。 添加Expires首部并配置ETag标签 相关资源应该缓存，以避免重复请求每个页面中相同的资源。Expires 首部可用于指定缓存时间，在这个时间内可以直接从缓存取得资源，完全避免 HTTP 请求。ETag 及 Last-Modified 首部提供了一个与缓存相关的机制，相当于最后一次更新的指纹或时间戳。 Gzip资源 所有文本资源都应该使用 Gzip 压缩，然后再在客户端与服务器间传输。一般来说，Gzip 可以减少 60%~80% 的文件大小，也是一个相对简单（只要在服务器上配置一个选项），但优化效果较好的举措。 避免HTTP重定向 HTTP 重定向极其耗时，特别是把客户端定向到一个完全不同的域名的情况下，还会导致额外的 DNS 查询、TCP 连接延迟，等等。 现实当中，我们应该对这些技术有正确的认识：它们都是些针对当前HTTP 1.1 协议的局限性而采用的权宜之计。我们本来不应该操心去连接文件、拼合图标、分割域名或嵌入资源。但遗憾的是，“不应该”并不是务实的态度：这些优化手段之所以存在，都是有原因的，在背后的问题被 HTTP 的下一个版本解决之前，必须得依靠它们。 持久连接的优点 每个 TCP 连接开始都有三次握手，要经历一次客户端与服务器间完整的往返。此后，会因为 HTTP 请求和响应的两次通信而至少引发另一次往返。最后，还要加上服务器处理时间，才能得到每次请求的总时间。HTTP 持久连接，可以避免再次请求的延迟。 HTTP 1.1， 默认启用持久连接。用 HTTP 1.0，则可以明确使用 Connection: Keep-Alive 首部声明使用持久连接。 HTTP管道 服务器处理完第一次请求后，会发生了一次完整的往返：先是响应回传，接着是第二次请求。在此期间服务器空闲。如果服务器能在处理完第一次请求后，立即开始处理第二次请求呢？ 这就是HTTP管道的作用，通过尽早分派请求，不被每次响应阻塞，可以再次消除额外的网络往返。这样，就从非持久连接状态下的每个请求两次往返，变成了整个请求队列只需要两次网络往返！ HTTP 1.1 管道的好处，主要就是消除了发送请求和响应的等待时间。这种并行处理请求的能力对提升应用性能的帮助非常之大。 讨论下HTTP 1.x 协议的一些局限性对，HTTP管道优化的不支持。HTTP 1.x 只能严格串行地返回响应。特别是，HTTP 1.x 不允许一个连接上的多个响应数据交错到达（多路复用），因而一个响应必须完全返回后，下一个响应才会开始传输。 演示了如下几个方面： * HTML 和 CSS 请求同时到达，但先处理的是 HTML 请求 * 服务器并行处理两个请求，其中处理 HTML 用时 40 ms，处理 CSS 用时 20 ms； * CSS 请求先处理完成，但被缓冲起来以等候发送 HTML 响应； * 发送完 HTML 响应后，再发送服务器缓冲中的 CSS 响应。 实际中，由于不可能实现多路复用，HTTP 管道会导致 HTTP 服务器、代理和客户端出现很多微妙的，不见文档记载的问题： * 一个慢响应就会阻塞所有后续请求； * 并行处理请求时，服务器必须缓冲管道中的响应，从而占用服务器资源，如果有个响应非常大，则很容易形成服务器的受攻击面； * 响应失败可能终止 TCP 连接，从页强迫客户端重新发送对所有后续资源的请求，导致重复处理； * 由于可能存在中间代理，因此检测管道兼容性，确保可靠性很重要； * 如果中间代理不支持管道，那它可能会中断连接，也可能会把所有请求串联起来。 HTTP 管道技术的应用非常有限，虽然其优点毋庸置疑。今天，一些支持管道的浏览器，通常都将其作为一个高级配置选项，但大多数浏览器都会禁用它。 实践中部署 HTTP 管道的最佳途径，就是在客户端和服务器间使用安全通道（HTTPS）。这样，就能可靠地避免那些不理解或不支持管道的中间代理的干扰。 使用多个TCP连接 由于 HTTP 1.x 不支持多路复用，浏览器可以不假思索地在客户端排队所有 HTTP请求，然后通过一个持久连接，一个接一个地发送这些请求。浏览器开发商没有别的办法，只能允许我们并行打开多个 TCP会话。多少个？现实中，大多数现代浏览器，包括桌面和移动浏览器，都支持每个主机打开 6 个连接。 同时打开多个 TCP 连接意味着什么: * 客户端可以并行分派最多 6 个请求； * 服务器可以并行处理最多 6 个请求； * 第一次往返可以发送的累计分组数量（TCP cwnd）增长为原来的 6 倍。 这样做的代价： * 更多的套接字会占用客户端、服务器以及代理的资源，包括内存缓冲区和 CPU时钟周期； * 并行 TCP 流之间竞争共享的带宽； * 由于处理多个套接字，实现复杂性更高； * 即使并行 TCP 流，应用的并行能力也受限制 实践中，CPU 和内存占用并非微不足道，由此会导致客户端和服务器端的资源占用量上升，运维成本提高。 cwnd 值最近又提高到了 10 个分组，而所有最新的平台都能可靠地支持 TCP 窗口缩放。 消耗客户端和服务器资源 限制每个主机最多 6 个连接，可以让浏览器检测出无意（或有意）的 DoS（Denialof Service）攻击。如果没有这个限制，客户端有可能消耗掉服务器的所有资源。 讽刺的是，同样的安全检测在某些浏览器上却会招致反向攻击：如果客户端超过了最大连接数，那么所有后来的客户端请求都将被阻塞。大家可以做个试验，在一个主机上同时打开 6 个并行下载，然后再打开第 7 个下载请求，这个请求会挂起，直到前面的请求完成才会执行。 用足客户端连接的限制似乎是一个可以接受的安全问题，但对于需要实时交付数据的应用而言，这样做越来越容易造成部署上的问题。比如 WebSocket、ServerSent Event 和挂起 XHR，这些会话都会占用整整一个 TCP 流，而不管有无数据传输——记住，没有多路复用一说！实际上，如果你不注意，那很可能自己对自己的应用施加 DoS 攻击。 域名分区 HTTP 1.x 协议的一项空白强迫浏览器开发商引入并维护着连接池，每个主机最多 6个 TCP 流。好的一方面是对这些连接的管理工作都由浏览器来处理。作为应用开发者，你根本不必修改自己的应用。不好的一方面呢，就是 6 个并行的连接对你的应用来说可能仍然不够用。 根据 HTTP Archive 的统计，目前平均每个页面都包含 90 多个独立的资源，如果这些资源都来自同一个主机，那么仍然会导致明显的排队等待（图 11-5）。实际上，何必把自己只限制在一个主机上呢？我们不必只通过一个主机（例如 www.example.com）提供所有资源，而是可以手工将所有资源分散到多个子域名：{shard1,shardn}.example.com。由于主机名称不一样了，就可以突破浏览器的连接限制，实现更高的并行能力。域名分区使用得越多，并行能力就越强！ 天下没有免费的午餐，域名分区也不例外：每个新主机名都要求有一次额外的 DNS 查询，每多一个套接字都会多消耗两端的一些资源，而更糟糕的是，站点作者必须手工分离这些资源，并分别把它们托管到多个主机上。 实践中，把多个域名（如 shard1.example.com、shard2.example.com）解析到同一个 IP 地址是很常见的做法。所有分区都通过 CNAME DNS 记录指向同一个服务器，而浏览器连接限制针对的是主机名，不是 IP 地址。另外，每个分区也可以指向一个 CDN 或其他可以访问到的服务器。 怎么计算最优的分区数目呢？这个问题不好回答，因为没有简单的方程式。答案取决于页面中资源的数量（每个页面都可能不一样），以及客户端连接的可用带宽和延迟（因客户端而异）。实际上，我们能做的，就是在调查的基础上做出预测，然后使用固定数量的分区。幸运的话，多这么一点复杂性，还是能给大多数用户带来好处的。 注意: * 首先，把 TCP 利用好 * 浏览器会自动为你打开 6 个连接； * 资源的数量、大小和响应时间都会影响最优的分区数目； * 客户端延迟和带宽会影响最优的分区数目； * 域名分区会因为额外的 DNS 查询和 TCP 慢启动而影响性能。 域名分区是一种合理但又不完美的优化手段。请大家一定先从最小分区数目（不分区）开始，然后逐个增加分区并度量分区后对应用的影响。现实当中，真正因同时打开十几个连接而提升性能的站点并不多，如果你最终使用了很多分区，那么你会发现减少资源数量或者将它们合并为更少的请求，反而能带来更大的好处。 度量和控制协议开销 有时，寥寥 15 个字符的 JSON 消息被 352 字节的 HTTP 首部包裹着，全部以纯文本形式发送——协议字节开销占 96%，而且这还是没有 cookie 的最好情况。减少要传输的首部数据（高度重复且未压缩），可以节省相当于一次往返的延迟时间，显著提升很多 Web 应用的性能。 主要就是度量下，内容和协议大小，为下节连接和拼合做准备。 注： * Cookie 在很多应用中都是常见的性能瓶颈，很多开发者都会忽略它给每次请求增加的额外负担。 连接与拼合 最快的请求是不用请求。不管使用什么协议，也不管是什么类型的应用，减少请求次数总是最好的性能优化手段。可是，如果你无论如何也无法减少请求，那么对HTTP 1.x 而言，可以考虑把多个资源捆绑打包到一块，通过一次网络请求获取： * 连接 把多个 JavaScript 或 CSS 文件组合为一个文件。 拼合 把多张图片组合为一个更大的复合的图片。 对 JavaScript 和 CSS 来说，只要保持一定的顺序，就可以做到把多个文件连接起来而不影响代码的行为和执行。类似地，多张图片可以组合为一个“图片精灵”，然后使用 CSS 选择这张大图中的适当部分，显示在浏览器中。这两种技术都具备两方面的优点。 减少协议开销 通过把文件组合成一个资源，可以消除与文件相关的协议开销。如前所述，每个文件很容易招致 KB 级未压缩数据的开销。 应用层管道 说到传输的字节，这两种技术的效果都好像是启用了 HTTP 管道：来自多个响应的数据前后相继地连接在一起，消除了额外的网络延迟。实际上，就是把管道提高了一层，置入了应用中。 连接和拼合技术都属于以内容为中心的应用层优化，它们通过减少网络往返开销，可以获得明显的性能提升。可是，实现这些技术也要求额外的处理、部署和编码（比如选择图片精灵中子图的 CSS 代码），因而也会给应用带来额外的复杂性。此外，把多个资源打包到一块，也可能给缓存带来负担，影响页面的执行速度。 要理解为什么这些技术会伤害性能，可以考虑一种并不少见的情况：一个包含十来个 JavaScript 和 CSS 文件的应用，在产品状态下把所有文件合并为一个 CSS 文件和一个 JavaScript 文件。 相同类型的资源都位于一个 URL（缓存键）下面。 资源包中可能包含当前页面不需要的内容。 对资源包中任何文件的更新，都要求重新下载整个资源包，导致较高的字节开销。 JavaScript 和 CSS 只有在传输完成后才能被解析和执行，因而会拖慢应用的执行速度。 所以将资源合理的打包很重要。这也需要度量。 内存占用也会成为问题。对图片精灵来说，浏览器必须分析整个图片，即便实际上只显示了其中的一小块，也要始终把整个图片都保存在内存中。浏览器是不会把不显示的部分从内存中剔除掉的！ 为什么执行速度还会受影响呢？我们知道，浏览器是以递增方式处理HTML 的，而对于 JavaScript 和 CSS 的解析及执行，则要等到整个文件下载完毕。JavaScript 和 CSS 处理器都不允许递增式执行。 CSS 和 JavaScript 文件大小与执行性能 CSS 文件越大，浏览器在构建 CSSOM 前经历的阻塞时间就越长，从而推迟首次绘制页面的时间。类似地，JavaScript 文件越大，对执行速度的影响同样越大；小文件倒是能实现“递增式”执行。 打包文件到底多大合适呢？可惜的是，没有理想的大小。然而，谷歌 PageSpeed团队的测试表明，30~50 KB（压缩后）是每个 JavaScript 文件大小的合适范围：既大到了能够减少小文件带来的网络延迟，还能确保递增及分层式的执行。具体的结果可能会由于应用类型和脚本数量而有所不同。 总之，连接和拼合是在 HTTP 1.x 协议限制（管道没有得到普遍支持，多请求开销大）的现实之下可行的应用层优化。使用得当的话，这两种技术可以带来明显的性能提升，代价则是增加应用的复杂度，以及导致缓存、更新、执行速度，甚至渲染页面的问题。应用这两种优化时，要注意度量结果，根据实际情况考虑如下问题。 你的应用在下载很多小型的资源时是否会被阻塞？ 有选择地组合一些请求对你的应用有没有好处？ 放弃缓存粒度对用户有没有负面影响？ 组合图片是否会占用过多内存？ 首次渲染时是否会遭遇延迟执行？ 举例：优化 Gmail 性能 Gmail 使用了大量 JavaScript，而且也不断拓展了现代浏览器的性能边界。要提升首次加载性能，Gmail 团队尝试了各种技术，目前包括如下这些： * 把首次绘制所需的 CSS 单独拿出来，优先于其他 CSS 文件发送； * 递增地交付较小的 JavaScript 块，以实现递增式执行； * 使用定制的外部更新机制，即客户端在后台下载新的 JavaScript 文件，然后在页面刷新时更新。 鉴于 Gmail 如此庞大的用户数量，如果所有打开的浏览器都要更新脚本，那哪怕一次简单的 JavaScript 更新，都可能演变为一次自残式的 DoS 攻击。为此，Gmail会在用户使用旧版本页面时，在后台预先加载更新文件，这样既可以分散负荷，又能提升下一次刷新时的速度。这个过程每天都重复不止一次。 在此基础上，为了让用户感觉第一次加载的速度很快，Gmail 团队还在 HTML 文档中嵌入了关键性 CSS 和 JavaScript，然后以块的形式递增加载其余 JavaScript 文件，以加快脚本执行——第一次打开 Gmail 时显示的进度条，反映的就是这个过程！ 嵌入资源 嵌入资源是另一种非常流行的优化方法，把资源嵌入文档可以减少请求的次数。比如，JavaScript 和 CSS 代码，通过适当的 script 和 style 块可以直接放在页面中，而图片甚至音频或 PDF 文件，都可以通过数据 URI（data:[mediatype][;base64],data）的方式嵌入到页面中： 123&lt;img src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAA AAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw==\" alt=\"1x1 transparent (GIF) pixel\" /&gt; 前面的例子是在文档中嵌入了一个 1×1 的透明 GIF 像素。而任何 MIME类型，只要浏览器能理解，都可以通过类似方式嵌入到页面中，包括PDF、音频、视频。不过，有些浏览器会限制数据 URI 的大小，比如 IE8最大只允许 32 KB。 建议： * 如果文件很小，而且只有个别页面使用，可以考虑嵌入； * 如果文件很小，但需要在多个页面中重用，应该考虑集中打包； * 如果小文件经常需要更新，就不要嵌入了； * 通过减少 HTTP cookie 的大小将协议开销最小化。 数据 URI 适合特别小的，理想情况下，最好是只用一次的资源。以嵌入方式放到页面中的资源，应该算是页面的一部分，不能被浏览器、CDN 或其他缓存代理作为单独的资源缓存。换句话说，如果在多个页面中都嵌入同样的资源，那么这个资源将会随着每个页面的加载而被加载，从而增大每个页面的总体大小。另外，如果嵌入资源被更新，那么所有以前出现过它的页面都将被宣告无效，而由客户端重新从服务器获取。 最后，虽然 CSS 和 JavaScript 等基于文本的资源很容易直接嵌入页面，也不会带来多余的开销，但非文本性资源则必须通过 base64 编码，而这会导致开销明显增大：编码后的资源大小比原大小增大 33% ！ HTTP 2.0 HTTP 2.0 可以让我们的应用更快、更简单、更健壮——这几词凑到一块是很罕见的！ HTTP 2.0 把很多以前我们针对 HTTP 1.1 想出来的“歪招儿”一笔勾销，把解决那些问题的方案内置在了传输层中。不仅如此，HTTP 2.0 还为我们进一步优化应用、改进性能，提供了全新的机会！ HTTP 2.0 的目的就是通过支持请求与响应的多路复用来减少延迟，通过压缩 HTTP首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持。为达成这些目标，HTTP 2.0 还会给我们带来大量其他协议层面的辅助实现，比如新的流量控制、错误处理和更新机制。上述几种机制虽然不是全部，但却是最重要的，所有 Web 开发者都应该理解并在自己的应用中利用它们。 HTTP 2.0 不会改动 HTTP 的语义。HTTP 方法、状态码、URI 及首部字段，等等这些核心概念一如往常。但是，HTTP 2.0 修改了格式化数据（分帧）的方式，以及客户端与服务器间传输这些数据的方式。这两点统帅全局，通过新的组帧机制向我们的应用隐藏了所有复杂性。换句话说，所有原来的应用都可以不必修改而在新协议运行。这当然是好事。 可是，我们关心的不止是交付能用的应用，我们目标是交付最佳性能！ HTTP 2.0为我们的应用提供了很多新的优化机制，这些机制是前所未有的，而我们的工作就是把它们都利用好。 历史及其与SPDY的渊源 SPDY 是谷歌开发的一个实验性协议，于 2009 年年中发布，其主要目标是通过解决HTTP 1.1 中广为人知的一些性能限制，来减少网页的加载延迟。大致上，这个项目设定的目标如下： * 页面加载时间（PLT，Page Load Time）降低 50%； * 无需网站作者修改任何内容； * 把部署复杂性降至最低，无需变更网络基础设施； * 与开源社区合作开发这个新协议； * 收集真实性能数据，验证这个实验性协议是否有效。 为了达到降低 50% 页面加载时间的目标，SPDY 引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层 TCP 连接。 走向HTTP 2.0 SPDY 是 HTTP 2.0 的催化剂，但 SPDY 并非 HTTP 2.0。2012 年初，W3C 向社会征集 HTTP 2.0 的建议，HTTP-WG 经过内部讨论，决定将 SPDY 规范作为制定标准的基础。从那时起，SPDY 已经经过了很多变化和改进，而且在 HTTP 2.0 官方标准公布之前，还将有很多变化和改进。 HTTP 2.0 致力于突破上一代标准众所周知的性能限制，但它也是对之前1.x 标准的扩展，而非替代。HTTP 的语义不变，提供的功能不变，HTTP 方法、状态码、URI 和首部字段，等等这些核心概念也不变；这些方面的变化都不在考虑之列。既然如此，那“2.0”还名副其实吗？之所以要递增一个大版本到 2.0，主要是因为它改变了客户端与服务器之间交换数据的方式。为实现宏伟的性能改进目标，HTTP 2.0 增加了新的二进制分帧数据层，而这一层并不兼容之前的 HTTP 1.x 服务器及客户端——是谓 2.0。 除非你在实现 Web 服务器或者定制客户端，需要使用原始的 TCP 套接字，否则你很可能注意不到 HTTP 2.0 技术面的实际变化：所有新的、低级分帧机制都是浏览器和服务器为你处理的。或许唯一的区别就是可选的 API多了一些，比如服务器推送！ 设计和技术目标 二进制分帧层 流、消息和帧 流 已建立的连接上的双向字节流。 消息 与逻辑消息对应的完整的一系列数据帧。 帧 HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流。 所有 HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。 要理解 HTTP 2.0，就必须理解流、消息和帧这几个基本概念。 * 所有通信都在一个 TCP 连接上完成。 * 流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数 标识符（1、2…N）。 * 消息是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。 * 帧是最小的通信单位，承载着特定类型的数据，如 HTTP 首部、负荷，等等。 简言之，HTTP 2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。相应地，很多流可以并行地在同一个 TCP 连接上交换消息 多向请求与响应 在 HTTP 1.x 中，如果客户端想发送多个并行的请求以及改进性能，那么必须使用多个 TCP 连接。这是 HTTP 1.x 交付模型的直接结果，该模型会保证每个连接每次只交付一个响应（多个响应必须排队）。更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下。 HTTP 2.0 中新的二进制分帧层突破了这些限制，实现了多向请求和响应：客户端和服务器可以把 HTTP 消息分解为互不依赖的帧（图 12-3），然后乱序发送，最后再在另一端把它们重新组合起来。 优点： * 可以并行交错地发送请求，请求之间互不影响； * 可以并行交错地发送响应，响应之间互不干扰； * 只使用一个连接即可并行发送多个请求和响应； * 消除不必要的延迟，从而减少页面加载的时间； * 不必再为绕过 HTTP 1.x 限制而多做很多工作； * 更多优势。 总之，HTTP 2.0 的二进制分帧机制解决了 HTTP 1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。结果，就是应用速度更快、开发更简单、部署成本更低。 支持多向请求与响应，可以省掉针对 HTTP 1.x 限制所费的那些脑筋和工作，比如拼接文件、图片精灵、域名分区。类似地，通过减少 TCP 连接的数量，HTTP 2.0 也会减少客户端和服务器的 CPU 及内存占用。 请求优先级 把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，进一步提升性能。为了做到这一点，每个流都可以带有一个 31 比特的优先值： * 0 表示最高优先级； * 2^31-1 表示最低优先级。 浏览器请求优先级与 HTTP 2.0 浏览器在渲染页面时，并非所有资源都具有相同的优先级：HTML 文档本身对构建 DOM 不可或缺，CSS 对构建 CSSOM 不可或缺，而 DOM 和 CSSOM 的构建都可能受到 JavaScript 资源的阻塞，其他资源（如图片）的优先级都可以降低。 为加快页面加载速度，所有现代浏览器都会基于资源的类型以及它在页面中的位置排定请求的优先次序，甚至通过之前的访问来学习优先级模式——比如，之前的渲染如果被某些资源阻塞了，那么同样的资源在下一次访问时可能就会被赋予更高的优先级。 在 HTTP 1.x 中，浏览器极少能利用上述优先级信息，因为协议本身并不支持多路复用，也没有办法向服务器通告请求的优先级。此时，浏览器只能依赖并行连接，且最多只能同时向一个域名发送 6 个请求。于是，在等连接可用期间，请求只能在客户端排队，从而增加了不必要的网络延迟。理论上，HTTP 管道可以解决这个问题，只是由于缺乏支持而无法付诸实践。 HTTP 2.0 一举解决了所有这些低效的问题：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。 我们也要合理度量，因为： 如果服务器不理睬所有优先值，那么可能会导致应用响应变慢：浏览器明明在等关键的 CSS 和 JavaScript，服务器却在发送图片，从而造成渲染阻塞。不过，规定严格的优先级次序也可能带来次优的结果，因为这可能又会引入队首阻塞问题，即某个高优先级的慢请求会不必要地阻塞其他资源的交付。 服务器可以而且应该交错发送不同优先级别的帧。只要可能，高优先级流都应该优先，包括分配处理资源和客户端与服务器间的带宽。不过，为了最高效地利用底层连接，不同优先级的混合也是必需的。 每个来源一个连接 有了新的分帧机制后，HTTP 2.0 不再依赖多个 TCP 连接去实现多流并行了。现在，每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别优先级。于是，所有HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。 所以我们可以停止域名分区了。 流量控制 在同一个 TCP 连接上传输多个数据流，就意味着要共享带宽。标定数据流的优先级有助于按序交付，但只有优先级还不足以确定多个数据流或多个连接间的资源分配。为解决这个问题，HTTP 2.0 为数据流和连接的流量控制提供了一个简单的机制： * 流量控制基于每一跳进行，而非端到端的控制； * 流量控制基于窗口更新帧进行，即接收方广播自己准备接收某个数据流的多少字节，以及对整个连接要接收多少字节； * 流量控制窗口大小通过 WINDOW_UPDATE 帧更新，这个字段指定了流 ID 和窗口大小递增值； * 流量控制有方向性，即接收方可能根据自己的情况为每个流乃至整个连接设置任意窗口大小； * 流量控制可以由接收方禁用，包括针对个别的流和针对整个连接。 HTTP 2.0 连接建立之后，客户端与服务器交换 SETTINGS 帧，目的是设置双向的流量控制窗口大小。除此之外，任何一端都可以选择禁用个别流或整个连接的流量控制。 服务器推送 HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。 为什么需要这样一个机制呢？通常的 Web 应用都由几十个资源组成，客户端需要分析服务器提供的文档才能逐个找到它们。那为什么不让服务器提前就把这些资源推送给客户端，从而减少额外的时间延迟呢？服务器已经知道客户端下一步要请求什么资源了，这时候服务器推送即可派上用场。事实上，如果你在网页里嵌入过 CSS、JavaScript，或者通过数据 URI 嵌入过其他资源，那你就已经亲身体验过服务器推送了。 把资源直接插入到文档中，就是把资源直接推送给客户端，而无需客户端请求。在HTTP 2.0 中，唯一的不同就是可以把这个过程从应用中拿出来，放到 HTTP 协议本身来实现，而且还带来了如下好处： * 客户端可以缓存推送过来的资源； * 客户端可以拒绝推送过来的资源； * 推送资源可以由不同的页面共享； * 服务器可以按照优先级推送资源。 所有推送的资源都遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。 首部压缩 HTTP 的每一次通信都会携带一组首部，用于描述传输的资源及其属性。在 HTTP 1.x 中，这些元数据都是以纯文本形式发送的，通常会给每个请求增加 500~800 字节的负荷。如果算上 HTTP cookie，增加的负荷通常会达到上千字节。为减少这些开销并提升性能，HTTP 2.0 会压缩首部元数据。","link":"/2018/01/08/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"},{"title":"了解下Express","text":"路由 虽说第一项是路由。不过首先，还是应该安装一下express。 1npm install express --save ## 什么是路由 路由是定义应用请求的URLs以及响应客户端的请求。结构如下：app.METHOD(path, [callback...], callback) 其中app是express的一个实例, METHOD是一个HTTP请求方法, callback是当路径匹配时要执行的函数。 示例 12345678910const express = require('express')const app = express()app.get('/', (req, res) =&gt; { res.send('hello world')})app.listen(3000, () =&gt; { console.log('服务开始在3000端口')}) 路由方法 路由方法源自HTTP请求方法。 Express定义了以下与HTTP对应的方法：get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search和connect。 其中JS不合法的需要使用括号记法，比如：app['m-search'].('/', callback...) app.all 也是method,它匹配的任何HTTP请求，句柄都会执行。 1234app.all('/secret', (req, res, next) =&gt; { console.log('handle the secret!') next() // 处理写一个句柄，相当于promise中的promise.resolve()}) 路由路径 路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。根据精确度排序匹配率排序 字符串&gt;字符串模式&gt;正则表达式 12345678910111213141516// 字符串app.get('/about', (req, res) =&gt; { res.send('about')})// 字符串模式app.get('/ab*ut', (req. res) =&gt; { res.send('ab*ut')})// 字符?,+,*和()是正则表达式的子集、在基于字符串的路径按照字面值解释。// 正则表达式app.get(/ab/, (req, res) =&gt; { res.send('/ab/') // 匹配任何含有ab的路径}) 路由句柄 可以为请求处理提供多个回调函数，行为类似中间件。唯一的区别，这些回调函数可能通过next('route')方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径继续执行没有意义，则可将控制权交给剩下的路径。 路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合，如下所示. 使用多个回调函数处理路由（记得指定 next 对象）： 123456app.get('/example/b', function (req, res, next) { console.log('response will be sent by the next function ...'); next();}, function (req, res) { res.send('Hello from B!');}); 使用回调函数数组处理路由： 123456789101112131415var cb0 = function (req, res, next) { console.log('CB0'); next();}var cb1 = function (req, res, next) { console.log('CB1'); next();}var cb2 = function (req, res) { res.send('Hello from C!');}app.get('/example/c', [cb0, cb1, cb2]); 响应方法 下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。 方法 描述 res.download() 提示下载文件。 res.end() 终结响应处理流程。 res.json() 发送一个 JSON 格式的响应。 res.jsonp() 发送一个支持 JSONP 的 JSON 格式的响应。 res.redirect() 重定向请求。 res.render() 渲染视图模板。 res.send() 发送各种类型的响应。 res.sendFile 以八位字节流的形式发送文件。 res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。 app.route() 可使用 app.route() 创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。 对于同一个路径不同method的链式路由句柄 12345678910app.route('/book') .get(function(req, res) { res.send('Get a random book'); }) .post(function(req, res) { res.send('Add a book'); }) .put(function(req, res) { res.send('Update the book'); }); express.Router 可使用 express.Router 类创建模块化、可挂载的路由句柄。Router 实例是一个完整的中间件和路由系统，因此常称其为一个 “mini-app”。 在 app 目录下创建名为 birds.js 的文件，内容如下： 123456789101112131415161718var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function timeLog(req, res, next) { console.log('Time: ', Date.now()); next();});// 定义网站主页的路由router.get('/', function(req, res) { res.send('Birds home page');});// 定义 about 页面的路由router.get('/about', function(req, res) { res.send('About birds');});module.exports = router; 然后在应用中加载路由模块： 123var birds = require('./birds');...app.use('/birds', birds); 应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。 中间件 Express框架实现功能就相当于在调用相关的中间件（Middleware），它可访问request和response 它的功能包括： * 执行任何代码。 * 修改请求和响应对象。 * 终结请求-响应循环。 * 调用堆栈中的下一个中间件。 如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。 Express 应用可使用如下几种中间件： * 应用级中间件 * 路由级中间件 * 错误处理中间件 * 内置中间件 * 第三方中间件 应用级中间件 应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD() 1234// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) { res.send('USER');}); // :id 由req.params.id 来获取 调用next('route')时，会跳过剩余中间件 如果需要在中间件栈中跳过剩余中间件，调用 next('route') 方法将控制权交给下一个路由。 注意： next('route') 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效。 123456789101112131415// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) { // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next('route'); // 否则将控制权交给栈中下一个中间件 else next(); //}, function (req, res, next) { // 渲染常规页面 res.render('regular');});// 处理 /user/:id， 渲染一个特殊页面app.get('/user/:id', function (req, res, next) { res.render('special');}); 路由级中间件 路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。 错误处理中间件 错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 错误处理中间件和其他中间件定义类似，只是要使用 4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。 1234app.use(function(err, req, res, next) { console.error(err.stack); res.status(500).send('Something broke!');}); 内置中间件 内置中间件只有一个express.static 。负责Express应用中托管静态资源。用法： express.static(root, [options]) 可选options： |属性|描述|类型|缺省值| |----|---|---|-----| |dotfiles|是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore”|String|“ignore”| |etag|是否启用 etag 生成|Boolean|true| |extensions|设置文件扩展名备份选项|Array|[]| |index|发送目录索引文件，设置为 false 禁用目录索引。|Mixed|“index.html”| |lastModified|设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false。|Boolean|true| |maxAge|以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性。|Number|0| |redirect|当路径为目录时，重定向至 “/”。|Boolean|true| |setHeaders|设置 HTTP 头以提供文件的函数。|Function|| 下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。 12345678910111213var options = { dotfiles: 'ignore', etag: false, extensions: ['htm', 'html'], index: false, maxAge: '1d', redirect: false, setHeaders: function (res, path, stat) { res.set('x-timestamp', Date.now()); }}app.use(express.static('public', options)); 每个应用可有多个静态目录。当然也可以分别设置options。 123app.use(express.static('public'));app.use(express.static('uploads'));app.use(express.static('files')); 更多关于 serve-static 和其参数的信息，请参考 serve-static 文档。 ## 第三方中间件 通过使用第三方中间件从而为 Express 应用增加更多功能。 安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。 下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser 1$ npm install cookie-parser 123456var express = require('express');var app = express();var cookieParser = require('cookie-parser');// 加载用于解析 cookie 的中间件app.use(cookieParser()); 请参考 第三方中间件 获取 Express 中经常用到的第三方中间件列表。","link":"/2017/11/11/%E4%BA%86%E8%A7%A3%E4%B8%8BExpress/"},{"title":"了解MV*模式","text":"找了和看了许多关于MVC、MVP、MVVM的资料，趁着周末同样是做一下总结。 # MV*需要解决的问题 在传统的GUI程序中，图形界面展示数据和信息，用户的输入行为会触发一些应用逻辑（application logic）可能会触发一些业务逻辑（business logic），业务逻辑会对数据进行相关的变更操作。 所以这里需要解决的问题有：View如何同步Model的变更，View和Model之间如何粘合在一起。 MVC MVC把应用程序分为了view、model层以及controller层， controller 的主要职责是 进行Model和View 之间的协作（路由、输入预处理等）应用逻辑； model 进行处理业务逻辑。它们的如下： MVC的调用关系 一般来说网页上用户的的调用关系如下图所示： 用户对View操作后，View捕获到这个操作，会把处理权给Controller；Controller会对来自View的数据进行预处理，决定调用哪一个Model的接口；然后由Model执行相关的业务逻辑；当Model变更之后，会通过 观察者模式（Observer Pattern）通知View ； View通过观察者模式 收到Model变更的消息后，会向Model请求最新的数据，然后重新更新界面。 需要注意的点： View把控制权交给Controller，Controller执行应用程序相关的应用逻辑（对来自View数据进行预处理、决定调用哪个Model的接口等等）。 Controller操作Model，Model执行业务逻辑对数据进行处理。Controller不会直接操作View，它并不用了解View。 View和Model的同步消息是通过观察者模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。 MVC的优缺点 优点： 1. 把业务逻辑和展示逻辑分离，模块化程度高。且当应用逻辑需要变更的时候，不需要变更业务逻辑和展示逻辑，只需要Controller换成另外一个Controller就行了（Swappable Controller）。 2. 观察者模式可以做到多视图同时更新。 缺点： 1. Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，应用逻辑正确性是无法验证的：Model更新的时候，无法对View的更新操作进行断言。 2. View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的。 MVC在服务端调用 服务端接收到来自客户端的请求，服务端通过路由规则把这个请求交由给特定的Controller进行处理，Controller执行相应的应用逻辑，对Model进行操作，Model执行业务逻辑以后；然后用数据去渲染特定的模版，返回给客户端。 相对于MVC中的输入就是Controller： MVP MVP模式将Controller改名为 Presenter，同时改变了通信方向： 和MVC模式一样，用户对View的操作都会从View交移给Presenter。Presenter会执行相应的应用程序逻辑，并且对Model进行相应的操作；而这时候Model执行完业务逻辑以后，也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，通过View提供的接口更新界面。 关键点： 1. View不再负责同步的逻辑，而是由Presenter负责。Presenter中既有应用程序逻辑也有同步逻辑。 2. View需要提供操作界面的接口给Presenter进行调用。（关键） 对比在MVC中，Controller是不能操作View的，View也没有提供相应的接口；而在MVP当中，Presenter可以操作View，View需要提供一组对界面操作的接口给Presenter进行调用；Model仍然通过事件广播自己的变更，但由Presenter监听而不是View。 这里 View 非常薄，不部署任何业务逻辑，称为\"被动视图\"（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里 MVP优缺点 优点： 1. 便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。 2. View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。 缺点： 1. Presenter中除了应用逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。 MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。ViewModel的含义就是 \"Model of View\"，视图的模型。它的含义包含了领域模型（Domain Model）和视图的状态（State）。 在图形界面应用程序当中，界面所提供的信息可能不仅仅包含应用程序的领域模型。还可能包含一些领域模型不包含的视图状态，例如电子表格程序上需要显示当前排序的状态是顺序的还是逆序的，而这是Domain Model所不包含的，但也是需要显示的信息。 可以简单把ViewModel理解为页面上所显示内容的数据抽象，和Domain Model不一样，ViewModel更适合用来描述View。 MVVM的调用关系 MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。 也就是说，MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交由框架所提供的Binder进行负责。只需要告诉Binder，View显示的数据对应的是Model哪一部分即可。 MVVM的优缺点 优点： 提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。 简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。 缺点： 1. 对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。 2. 数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。 引用 https://github.com/livoras/blog/issues/11 https://stackoverflow.com/questions/4415904/business-logic-in-mvc https://addyosmani.com/resources/essentialjsdesignpatterns/book/#detailmvcmvp http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html","link":"/2018/12/23/%E4%BA%86%E8%A7%A3MV-%E6%A8%A1%E5%BC%8F/"},{"title":"你不知道的JS-this和原型对象","text":"这里我总结了下，《你不知道的javaScript上卷》第二部分的内容，总结的可能比较简短，相关的知识点，与设计模式中间有重合，设计模式中的相关设计模式，后期也会补上。 # 关于this 为什么要用this呢？ 如果没有this，我们需要调用变量名，才能在函数或者方法中调用相关它自己，如果有了this，我们就能用一种更优雅的方式“传递”一个对象的引用。因此可以将API设计的更加简洁并且易于复用。 随着你使用的模式越来越复杂，显示传递上下文对象会使代码变得越来越混乱，使用this则不会这样。 误解 关于两种常见的对于this的解释，但是他们都是错误的。 指向自身 很多人很容易吧this联想到它的英文意思，指向函数本身，但是this的绑定是动态的！ 看一个例子吧 12345678910111213141516171819function foo(num) { console.log( \"foo: \" + num ); // 记录 foo 被调用的次数 this.count++;}foo.count = 0;var i;for (i=0; i&lt;10; i++) { if (i &gt; 5) { foo( i ); }}// foo: 6// foo: 7// foo: 8// foo: 9// foo 被调用了多少次？console.log( foo.count ); // 0 -- WTF? 上面的this绑定到哪里了呢？答案是全局。 它的作用域 第二种常见的误解是，this指向函数的作用域。 再看一个例子。 12345678910function foo() { var a = 2; this.bar();}function bar() { console.log( this.a );}foo(); // ReferenceError: a is not defined 这里我们既想用词法作用域，又想调用this来引入我们想用的函数体的变量。 这里稍微解析一下， this.bar() 引用的是外部的全局的 bar() 函数，这样里面的语句， console.log(this.a) 查找的也是全局的 a 变量。我们知道函数定义的 a 变量是影响不了全局的 a 变量的。所以这里我们会抛出一个引用错误。 this到底是什么 排除了错误的理解后，我们看看this到底是什么样的机制。 之前我们说过this是在运行时进行绑定的，并不是在编写时绑定，他的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置灭有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等消息。this就是记录的其中一个属性，会在函数执行的过程中用到。 下一章我们会学习如何寻找函数的滴啊用位置，从而判断函数在执行的过程中会如何绑定this。 this全面解析 调用位置 就像前面说的，调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个this到底引用的是什么？ 通常来说，寻找滴啊用位置就是寻找“函数被调用的位置”，但是做起来没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。 最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。 12345678910111213141516171819function baz() { // 当前调用栈是：baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // &lt;-- bar 的调用位置}function bar() { // 当前调用栈是 baz -&gt; bar // 因此，当前调用位置在 baz 中 console.log( \"bar\" ); foo(); // &lt;-- foo 的调用位置}function foo() { // 当前调用栈是 baz -&gt; bar -&gt; foo // 因此，当前调用位置在 bar 中 // 这里放一个断点可以查看当前调用栈，倒数第二个就是真正的调用位置。 console.log( \"foo\" );}baz(); // &lt;-- baz 的调用位置 绑定规则 这里也简要的解释四种规则： 1. 默认绑定 最常用的函数调用类型：独立函数调用。可以把这条规则看做是无法应用其他规则时的默认规则。 123456function foo() { console.log( this.a );}var a = 2;foo(); // 2 怎么知道应用了默认绑定呢？可以通过调用位置来看看 foo() 是如何调用的。在代码中，foo()是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。如果使用严格模式，将默认无法使用默认绑定的，因为this会绑定为undefined。 2. 隐式绑定 另一种需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。 常见的对象的方法，就是隐式绑定。对象属性引用链只有最顶层或者说最后一层会影响调用位置。 12345678910111213function foo() { console.log( this.a );}var obj2 = { a: 42, foo: foo};var obj1 = { a: 2, obj2: obj2};obj1.obj2.foo(); // 42 隐式丢失 因为this的绑定会根据runtime，所以，思考下面的代码： 1234567891011121314function foo() { console.log(this.a);}var obj = { a: 2, foo: foo};var bar = obj.foo;var a = \"全局对象a\";bar(); // 全局对象a 还有一种是常见的回调函数中的this隐式丢失，看下面代码： 123456789101112131415161718function foo() { console.log( this.a );}var obj = { a: 2, foo: foo};var a = \"oops, global\"; // a 是全局对象的属性setTimeout( obj.foo, 100 ); // \"oops, global\"// JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：function setTimeout(fn,delay) { // 等待 delay 毫秒 fn(); // &lt;-- 调用位置！} 接下来，我们会介绍相关的通过固定this来fix,this所指向的对象或者说上下文context。 3. 显示绑定 分析隐式绑定时，我们必须在一个对象的内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上。 我们可以通过call(..)和apply(..)方法，来在某个函数中强制指定到this的上下文。 12345678function foo() { console.log( this.a );}var obj = { a:2};foo.call( obj ); // 2 可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。 1. 硬绑定 思考下面代码： 1234567891011function foo() { console.log(this.a);}var obj = function() { foo.call(obj);};var bar = function() { foo.call(obj);}; 这里，我们在 bar 内部实现了一个 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj 。无论之后如何调用函数 bar ，它总会在 obj 上调用 foo 。这种绑定是一种显式的强制绑定，因此我们称之为 硬绑定。 ES5中提供了内置的方法，Function.prototype.bind 2. API调用的“上下文” 第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一 个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调 函数使用指定的 this。 举个栗子： 12345678910function foo(el) { console.log( el, this.id );}var obj = { id: \"awesome\"};// 调用 foo(..) 时把 this 绑定到 obj[1, 2, 3].forEach( foo, obj );// 1 awesome 2 awesome 3 awesome 这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些 代码。 4. new绑定 在JavaScript中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行[[原型]]连接。 这个新对象会绑定到函数调用的 this 。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 优先级 函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。 函数是否通过call、apply（显示绑定）或者硬绑定调用？如果是的话，this绑定的是制定的对象。 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。 绑定例外 在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用 的可能是默认绑定规则。 1. 被忽略的this 如果你把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用的时候会被忽略，实际应用的是默认绑定规则。 如果函数并不关心this的话，你仍然需要传入一个占位符，常见的就是用null，可是这里用null来忽略this绑定可能会产生一些副作用。如果这个函数中确实使用了this，那默认绑定规则会把this绑定到全局对象，在浏览器这个对象是window，这将产生不可预计的后果。 更安全的this 一种“更安全”的做法是，闯入一个特殊的对象，常见方法，Object.create(null)。如果引入的是这个空对象，这样就比较安全了，这样很明确的表示this是空，即使函数中调用了this，也不会更改全局对象。 12345678910111213function foo() { this.a = 200 console.log(this.a);}var a = 2;var ø = Object.create(null)foo.call(ø)console.log(a)// 200 2 2. 间接引用 另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这 种情况下，调用这个函数会应用默认绑定规则。 常见的就是赋值的时候发生。 注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则this 会被绑定到全局对象。 3. 软绑定 123456789101112131415161718if (!Function.prototype.softBind) { Function.prototype.softBind = function(obj) { var fn = this; // 捕获所有 curried 参数 var curried = [].slice.call( arguments, 1 ); var bound = function() { return fn.apply( (!this || this === (window || global)) ? obj : this curried.concat.apply( curried, arguments ) ); }; bound.prototype = Object.create( fn.prototype ); return bound; };} softBind(..)的其他原理和ES5内置的bind(..)类似。它会对制定函数进行封装，首先会检查调用时的this，如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this，否则不会修改this。 1234567891011121314151617181920function foo() { console.log(\"name: \" + this.name);}var obj = { name: \"obj\" }, obj2 = { name: \"obj2\" }, obj3 = { name: \"obj3\" };var fooOBJ = foo.softBind( obj );fooOBJ(); // name: objobj2.foo = foo.softBind(obj);obj2.foo(); // name: obj2 &lt;---- 看！！！fooOBJ.call( obj3 ); // name: obj3 &lt;---- 看！setTimeout( obj2.foo, 10 );// name: obj &lt;---- 应用了软绑定 this词法 这里介绍一下箭头函数: () =&gt; {} 12345678910111213141516function foo() { return (a) =&gt; { console.log(this.a); };}var obj1 = { a: 2};var obj2 = { a: 3};var bar = foo.call(obj1);bar.call(obj2); foo() 内部创建的箭头函数会捕获调用时foo()的this。由于 foo() 的this绑定到obj1，bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。（new也不行！） 对象 两种形式的定义：声明（文字）形式和构造形式。 ## 类型 了解一下，简单基本类型：string、number、boolean、null和undefined。null有时会被当做一种对象类型，但是这其实只是语言本身的一个bug。 JS中有很多复杂基本类型。这些是一些特殊的对象子类型。函数就是对象的一个子类型（从技术角度来说就是“可调用的对象”） Javascript中的函数是“一等公民”，因为它们本质上和普通的对象一样（只是可以调用），所以可以像操作其他对象一样操作函数（比如当做另一个函数的参数）。 内置对象 内置对象有：String、Number、Boolean、Object、Function、Array、Date、RegExp和Error。 关于字面量的基本类型调用 Object.prototype.toString() 都会转化成对应的包装类型。 内容 内容听名字似乎存储在对象内部，其实在语言中，这些值的储存方式是多种多样的，一般不会存在对象容器的内部。存储在对象容器的内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置。 .a通常指的是属性访问，[\"a\"] 语法通常被称为“键访问”。在 [\"..\"] 语法使用字符串来访问属性，所以可以在程序中构造这个字符串。 可计算属性名 12345678var prefix = \"foo\";var myObject = { [prefix + \"bar\"]: \"hello\", [prefix + \"baz\"]: \"world\"};myObject[\"foobar\"]; // hellomyObject[\"foobaz\"]; // world 属性与方法 如果访问的对象是一个函数，在JS中，我们喜欢称之为 “方法”，实际上呢，这个所谓的“方法”也仅仅是对方法的引用。 数组 数组支持[]访问形式，不过数组期待的是数字下标。所以你添加的属性值并不会使数组的length变长。你完全可以把数组当做一个普通的键/值对来使用。 而且要注意了：如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成 一个数值下标（因此会修改数组的内容而不是添加一个属性） 1234567var myArray = [ \"foo\", 42, \"bar\" ];myArray[\"3\"] = \"baz\";myArray.length; // 4myArray[3]; // \"baz\" 复制对象 复制不可避免需要讨论到的就是深拷贝和浅拷贝。 对于JSON安全的对象，这有一种方法可以用：var newObj = JSON.parse( JSON.stringify( someObj ) ); ES6中定义的 Object.assign(..) 可以用在浅拷贝上，Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或者多个源对象。它会遍历一个或多个源对象的多有自由键并把它们复制（使用 = 操作符赋值）到目标对象，最后返回目标对象。 属性描述符 在ES5之前，JavaScript语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。 1234567891011var myObject = {a:2};Object.getOwnPropertyDescriptor( myObject, \"a\" );// {// value: 2,// writable: true,// enumerable: true,// configurable: true// } Object.getOwnPropertyDescriptor(..)和Object.defineProperty(..)了解一下。 常见配置： 1. Writable 是否可以修改属性的值 2. Configurable 只要属性是可配置的，就可以使用 defineProperty(..) 方法来修改属性描述符。关于Configurable配置为false，writable可以由true变为false，并且不能再变回来啦！操作不可逆哈。 3. Enumerable 最后一个属性描述符（还有两个，我们会在介绍 getter 和 setter 时提到） 是 enumerable。 放一下总结好了，这本书就总结到这里了： 小结 JavaScript 中的对象有字面形式（比如 var a = { .. }）和构造形式（比如 var a = newArray(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。 许多人都以为“JavaScript 中万物都是对象”，这是错误的。对象是 6 个（或者是 7 个，取决于你的观点）基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。 对象就是键 / 值对的集合。可以通过 .propName 或者 [\"propName\"] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作（在设置属性值时是 [[Put]]），[[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]]链（参见第 5 章）。 属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象（及其属性）的不可变性级别。 属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。 你可以使用 ES6 的 for..of 语法来遍历数据结构（数组、对象，等等）中的值，for..of会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。","link":"/2018/05/14/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-this%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"},{"title":"你不知道的JS总结-作用域和闭包(二)","text":"关于你不知道的JS总结-作用域和闭包的第二部分。 # 第 4 章 提升 ## 先有鸡还是先有蛋 关于JS的代码执行顺序，直觉上是由上到下一行一行执行的。实际上并不完全正确，考虑下下面的代码 123a = 2;var a;console.log( a ); 你认为console.log( a );声明会输出什么呢？很多人会认为是undefined，其实真实的输出结果是2。而 12console.log( a );var a = 2; 这段代码输出结果又是ReferenceError异常。 按照第一章的编译器顺序，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。 所以看到的var a = 2;其实是var a; 和 a = 2;两个声明。代码的编译过程是如下： 12345678var a;a = 2;console.log(a);// 加上顺序，流程如下：var a;console.log(a);a = 2; 从上面的例子可以看出，是现有声明，再有赋值。这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。 关于函数的声明 首先看一段代码： 12345foo();function foo() { console.log( a ); // undefined var a = 2;} foo 函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可以正常执行。 正确的执行顺序： 123456function foo() { var a; console.log( a ); // undefined a = 2;}foo(); 函数声明会被提升，但是函数表达式却不会被提升。 下面看一段函数表达式的代码片段： 1234567891011121314foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() {// ...};// 经过提升var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() { var bar = ...self... // ...} 函数优先 函数声明和变量声明都会被提升，那么哪一个的优先权大呢？答案就在标题。 看这一段代码： 12345678foo(); // 1var foo;function foo() { console.log( 1 );}foo = function() { console.log( 2 );}; 这个代码片段会被引擎理解为如下形式： 1234567function foo() { console.log( 1 );}foo(); // 1foo = function() { console.log( 2 );}; 尽管 var foo 出现在function foo()...，但它是一个重复的声明，会被忽略掉。因为函数声明会被提升到普通变量之前。 而且，后面的函数声明会覆盖前面的声明。 12345678910foo(); // 3function foo() { console.log( 1 );}var foo = function() { console.log( 2 );};function foo() { console.log( 3 );} 一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程 不会像下面的代码暗示的那样可以被条件判断所控制： 12345678foo(); // \"b\"var a = true;if (a) { function foo() { console.log(\"a\"); }}else { function foo() { console.log(\"b\"); }} 总结 我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！ # 第 5 章 作用域闭包 ## 启示 闭包无处不在，你所需要的只是理解它 实质问题 闭包的定义： &gt; 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 下面这段代码的定义： 12345678function foo() { var a = 2; function bar() { console.log( a ); // 2 } bar();}foo(); 上面的代码中，基于词法作用域，函数bar()可以访问外部作用域中的变量a（利用RHS引用调用）。这里的词法作用域的利用，是闭包的一部分，也是最重要的一部分。 从纯学术的角度说，函数 bar() 具有一个涵盖 foo() 作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域））。也可以认为 bar() 被封闭在了 foo() 的作用域中。为什么呢？原因简单明了，因为 bar() 嵌套在 foo() 内部。 123456789function foo() { var a = 2; function bar() { console.log( a ); } return bar;}var baz = foo();baz(); // 2 —— 朋友，这就是闭包的效果。 函数bar()的词法作用域能够访问foo()的内部作用域。然后我们将bar()函数本身当做一个值类型进行传递。上面这个例子中，我们就是将bar所应用的函数对象本身当做返回值。 在foo()执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数bar()。 bar()显然可以被正常执行，但是在这个例子中，它在自己定义的词法作用域以外的地方执行。 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。 而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。 拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。 bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 因此，在几微秒之后变量 baz 被实际调用（调用内部函数 bar），不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。 当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。 1234567891011function foo() { var a = 2; function baz() { console.log( a ); // 2 } bar( baz );}function bar(fn) { fn(); // 妈妈快看呀，这就是闭包！} 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 现在我懂了 来看这段代码。 123456function wait(message) { setTimeout( function timer() { console.log( message ); }, 1000 );}wait( \"Hello, closure!\" ); 将一个内部函数（名为 timer）传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。 wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..)作用域的闭包。 深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 timer 函数，而词法作用域在这个过程中保持完整。 这就是闭包。 本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ IIFE模式，因为函数（示例代码中的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行。这是是创建了一个闭包但是并不能调用。 循环和闭包 要说明闭包，for循环是最常见的例子 12345for (var i=1; i&lt;=5; i++) { setTimeout( function timer() { console.log( i ); }, i*1000 );} 我们预期的效果是:分别输出数字 1~5，每秒一次，每次一个。 得到的结果是，每秒一次的频率输出五次 6。 首先我们看一下6是怎么来的。这个例子中的终止条件是i&lt;=5。所以首次成立时的i的值是6，因此，输出显示的是循环结束时 i 的最终值。 仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。 我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。 首先试下IIFE 12345678910111213141516for (var i=1; i&lt;=5; i++) { (function() { setTimeout( function timer() { console.log( i ); }, i*1000 ); })();} // 这样的写法不行，为什么呢？因为每个IIFE中i的值并没有定义，也就是说这个作用于是空的// 改进for (var i=1; i&lt;=5; i++) { (function(j) { setTimeout( function timer() { console.log( j ); }, j*1000 ); })( i );} 重返块作用域 我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。第 3 章介绍了 let 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。 本质上这是将一个块转换成一个可以被关闭的作用域。因此，下面这些看起来很酷的代码就可以正常运行了： 123456789101112for (var i=1; i&lt;=5; i++) { let j = i; // 是的，闭包的块作用域！ setTimeout( function timer() { console.log( j ); }, j*1000 );}// for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。for (let i=1; i&lt;=5; i++) { setTimeout( function timer() { console.log( i ); }, i*1000 );} 模块 还有其他的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一起来研究其中最强大的一个：模块。 模块模式需要具备两个必要条件。 1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 小结 闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够到达那里。但实际上它只是一个标准，显然就是关于如何在函数作为值按需传递的词法环境中书写代码的。 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。 如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。 模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。 现在我们会发现代码中到处都有闭包存在，并且我们能够识别闭包然后用它来做一些有用的事！ 附录 A 动态作用域 JS中作用域就是词法作用域，（事实上大部分语言都是基于词法作用域的）。 而JS中，this的机制，类似于动态作用域。 词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用eval() 或 with）。而动态作用域，是一个运行时被被动确定状态的形式。 例子: 123456789function foo() { console.log( a ); // 2}function bar() { var a = 3; foo();}var a = 2;bar(); 词法作用域让 foo() 中的 a 通过 RHS 引用到了全局作用域中的 a，因此会输出 2。 而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。 因此，如果 JavaScript 具有动态作用域，理论上，上面代码中的 foo() 在执行时将会输出 3。 为什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。 附录 B 块作用域的替代方案 第 3 章深入研究了块作用域。至少从 ES3 发布以来，JavaScript 中就有了块作用域，而with 和 catch 分句就是块作用域的两个小例子。 但随着 ES6 中引入了 let，我们的代码终于有了创建完整、不受约束的块作用域的能力。块作用域在功能上和代码风格上都拥有很多激动人心的新特性。 但如果我们想在 ES6 之前的环境中使用块作用域呢？ 12345{ let a = 2; console.log( a ); // 2}console.log( a ); // ReferenceError 这段代码在 ES6 环境中可以正常工作。但是在 ES6 之前的环境中如何才能实现这个效果？答案是使用 catch。 1234try{throw 2;}catch(a){ console.log( a ); // 2}console.log( a ); // ReferenceError 了解原理剩下就交给ES6转换器吧。 附录 C this 词法 ES6 中有一个主题用非常重要的方式将 this同词法作用域联系起来了，我们会简单地讨论一下。 ES6 添加了一个特殊的语法形式用于函数声明，叫作箭头函数。 1234var foo = a =&gt; { console.log( a );};foo( 2 ); // 2 这里称作“胖箭头”的写法通常被当作单调乏味且冗长（挖苦）的 function 关键字的简写。 看这段代码： 123456789var obj = { id: \"awesome\", cool: function coolFn() { console.log( this.id ); }};var id = \"not awesome\"obj.cool(); // 酷setTimeout( obj.cool, 100 ); // 不酷 问题在于 cool() 函数丢失了同 this 之间的绑定。解决这个问题有好几种办法，但最长用的就是 var self = this;。 12345678910111213var obj = { count: 0, cool: function coolFn() { var self = this; if (self.count &lt; 1) { setTimeout( function timer(){ self.count++; console.log( \"awesome?\" ); }, 100 ); } }};obj.cool(); // 酷吧？ var self = this 这种解决方案圆满解决了理解和正确使用 this 绑定的问题，并且没有把问题过于复杂化，它使用的是我们非常熟悉的工具：词法作用域。 ES6 中的箭头函数引入了一个叫作 this 词法的行为： 123456789101112var obj = { count: 0, cool: function coolFn() { if (this.count &lt; 1) { setTimeout( () =&gt; { // 箭头函数是什么鬼东西？ this.count++; console.log( \"awesome?\" ); }, 100 ); } }};obj.cool(); // 很酷吧 ? 简单来说，箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。 因此，这个代码片段中的箭头函数并非是以某种不可预测的方式同所属的 this 进行了解绑定，而只是“继承”了 cool() 函数的 this 绑定（因此调用它并不会出错）。 箭头函数将程序员们经常犯的一个错误给标准化了，也就是混淆了 this 绑定规则和词法作用域规则。 换句话说：为什么要自找麻烦使用 this 风格的代码模式呢？把它和词法作用域结合在一起非常让人头疼。在代码中使用两种风格其中的一种是非常自然的事情，但是不要将两种风格混在一起使用。 另一个导致箭头函数不够理想的原因是它们是匿名而非具名的。具名函数比 匿名函数更可取的原因参见第 3 章。 在我看来，解决这个“问题”的另一个更合适的办法是正确使用和包含 this 机制。 12345678910111213var obj = { count: 0, cool: function coolFn() { if (this.count &lt; 1) { setTimeout( function timer(){ this.count++; // this 是安全的 // 因为 bind(..) console.log( \"more awesome\" ); }.bind( this ), 100 ); // look, bind()! } }};obj.cool(); // 更酷了。 无论你是喜欢箭头函数中 this 词法的新行为模式，还是喜欢更靠得住的 bind()，都需要注意箭头函数不仅仅意味着可以少写代码。 它们之间有意为之的不同行为需要我们理解和掌握，才能正确地使用它们。 现在我们已经完全理解了词法作用域（还有闭包），理解 this 词法是小菜一碟！","link":"/2018/02/05/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E6%80%BB%E7%BB%93-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85-%E4%BA%8C/"},{"title":"你不知道的JS总结-作用域和闭包(一)","text":"这几天读了下《你不知道的JavaScript（上卷）》,对于书中作用域和闭包的知识点做一下总结 # 第 1 章 作用域是什么 要了解作用域的规则，首先需要了解简单的编译原理。 ## 编译原理 尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。 在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。 * 分词/词法分析（Tokenizing/Lexing） 这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。 如：var a = 2; =&gt; var、a、=、2 、; * 解析/语法分析（Parsing） 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。 代码生成 将 AST 转换为可执行代码的过程称被称为代码生成。 理解作用域 需要理解三个处理过程中的参与者： * 引擎 从头到尾负责整个 JavaScript 程序的编译及执行过程。 * 编译器 引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。 * 作用域 引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 例子: var a = 2; 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。 在赋值中，对于引擎来讲，引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫作 RHS。 RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。 你可以将 RHS 理解成 retrieve his source value（取到它的源值）。 作用域嵌套 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 不管是LHS 和 RHS都需要对作用域按照上图进行查找。一旦抵达全局作用域，无论你有没有找到所需变量，查找过程都会终止。 异常 LHS和RHS,在最终没有找到变量的时候处理方式会有差异: * RHS 抛出异常ReferenceError * LHS 在严格模式，抛出异常ReferenceError,正常模式，会创建一个具有该名称的变量，并将其返还给引擎。 RHS 中，如果找到一个变量对这个变量进行不合理的操作。会抛出TypeError ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了。 小结 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。 JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤： 1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 2. 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。 LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。 第 2 章 词法作用域 作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的 词法作用域 ，我们会对这种作用域进行深入讨论。另外一种叫作 动态作用域，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。 词法阶段 第 1 章介绍过，大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。回忆一下，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。 简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。 12345678function foo(a) { var b = a * 2; function bar(c) { console.log( a, b, c ); } bar( b * 3 );}foo( 2 ); // 2, 4, 12 这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们想象成几个逐级包含 的气泡。 包含着整个全局作用域，其中只有一个标识符：foo。 包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。 包含着 bar 所创建的作用域，其中只有一个标识符：c 没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“ 遮蔽效应 ”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 欺骗词法 如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？ JavaScript 中有两种机制来实现这个目的 1. eval JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。 2. with JavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是with 关键字。 性能 这是我们抛弃上述两个方法的主要原因， JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。 但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。 如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。 小结 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。 JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。 # 第 3 章 函数作用域和块作用域 ## 函数中的作用域 123456789function foo(a) { var b = 2; // 一些代码 function bar() { // ... } // 更多的代码 var c = 3;} 无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡。 在下一章提升中会着重介绍。 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript 变量可以根据需要改变值类型的“动态”特性。 隐藏内部实现 对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。 有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。 123456789function doSomething(a) { b = a + doSomethingElse( a * 2 ); console.log( b * 3 );}function doSomethingElse(a) { return a - 1;}var b;doSomething( 2 ); // 15 上述的例子中，就是一个反例，将应该私有的变量b和函数doSomethingElse(..)暴露给了外部作用域。 123456789function doSomething(a) { function doSomethingElse(a) { return a - 1; } var b; b = a + doSomethingElse( a * 2 ); console.log( b * 3 );}doSomething( 2 ); // 15 修改后的代码，b和 doSomethingElse(..)都无法从外部被访问。 规避冲突 12345678910function foo() { function bar(a) { i = 3; // 修改 for 循环所属作用域中的 i console.log( a + i ); } for (var i=0; i&lt;10; i++) { bar( i * 2 ); // 糟糕，无限循环了！ }}foo(); bar(..) 内部的赋值表达式 i = 3 意外地覆盖了声明在 foo(..) 内部 for 循环中的 i。在这个例子中将会导致无限循环，因为 i 被固定设置为 3，永远满足小于 10 这个条件。 这里我们能选用两种方法，一种新声明一个本地变量，var i = 3;。另一种，新添加一个标识符名称，比如 var j = 3。 软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，所以通过作用域来“隐藏”内部声明是唯一的最佳选择。 全局命名空间 变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。 这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。 123456789var MyReallyCoolLibrary = { awesome: \"stuff\", doSomething: function() { // ... }, doAnotherThing: function() { // ... }}; 模块管理 这种避免冲突的方法和现代的木块机制很接近，从众多的模块管理器挑选一个使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。 显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。 函数作用域 在前面我们知道了，在任意代码片段外部添加包装函数，可以讲变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。 这个方法也有不理想之处。我们必须声明一个具名函数，这也就意味着，这个具名函数的名称已经“污染”了所在作用域。其次，必须显示的调用这个具名函数，才能运行其中的代码。 如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。 JS中的同时解决两种问题的方案： 1234567var a = 2;(function foo(){ // &lt;-- 添加这一行 var a = 3; console.log( a ); // 3})(); // &lt;-- 以及这一行console.log( a ); // 2 包装函数的声明以 (function... 而不仅是以 function... 开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理。其实就是立即执行了。 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 函数声明 和 函数表达式 之间最重要的区别是它们的名称标识符将会绑定在何处。 (function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。 匿名和具名 123setTimeout( function() {console.log(\"I waited 1 second!\");}, 1000 ); 上述的定时的代码片段，我们很熟悉，这就是 匿名函数表达式 , 因为function().. 没有名称标识符。 匿名函数书写起来简单便捷，不过有几个缺点需要考虑。 1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。 立即执行函数表达式 IIFE, 代表立即执行函数表达式（Immediately Invoked Function Expression）； 函数名对于IIFE不是必需的，IIFE 最常见的用法是使用一个匿名函数表达式。 * IIFE 的一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。 * IIFE 另一个场景，解决undefined 标识符的默认值被错误覆盖导致的异常（虽然不常见）。 * IIFE 是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。 块作用域 123for (var i=0; i&lt;10; i++) { console.log( i );} 我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 i 会被绑定在外部作用域（函数或全局）中的事实。 123456var foo = true;if (foo) { var bar = foo * 2; bar = something( bar ); console.log( bar );} 使用 var 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。这段代码是为了风格更易读而伪装出的形式上的块作用域，如果使用这种形式，要确保没在作用域其他地方意外地使用 bar 只能依靠自觉性。 块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。实现方法： 1. with 2. try/catch catch分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。 3. let let 这里我们着重介绍下，let的实现原理。 let关键字可以将变量绑定到所在的任意作用域中，通常是{ .. } 内部.换句话说，let为其声明的变量隐式地了所在的块作用域。 1234567var foo = true;if (foo) { let bar = foo * 2; bar = something( bar ); console.log( bar );}console.log( bar ); // ReferenceError 用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。 在开发和修改代码的过程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将其包含在其他的块中，就会导致代码变得混乱。 显示的块作用域，可以解决上述问题。 123456789var foo = true;if (foo) { { // &lt;-- 显式的快 let bar = foo * 2; bar = something( bar ); console.log( bar ); }}console.log( bar ); // ReferenceError 例子中，我们在 if 声明内部显式地创建了一个块，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响 垃圾收集 另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。通过块作用域，能够让引擎知道我们执行后的代码片段不需要继续保存。 let循环 1234for (let i=0; i&lt;10; i++) { console.log( i );}console.log( i ); // ReferenceError for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。 下面通过另一种方式来说明每次迭代时进行重新绑定的行为： 1234567{ let j; for (j=0; j&lt;10; j++) { let i = j; // 每个迭代重新绑定！ console.log( i ); }} const 同样可以用来创建块作用域变量，但其值是固定的（常量）。 小结 函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。 从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。 在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。","link":"/2018/02/05/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E6%80%BB%E7%BB%93-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85(%E4%B8%80)/"},{"title":"你所需要了解的CSS变量知识点","text":"大多数的编程语言都支持变量，CSS则从一开始就缺乏对原生变量的支持。好在有 Sass 之类的预处理器，使其在编译时期引入变量。好在 CSS 现在已经支持变量了。尽管预处理增加了对变量的支持，但使用原生的CSS变量也是一个很好的选择，这样可以使我们的页面更加接近未来。 下面会介绍 CSS 的用法和一些案例。 CSS变量优点 1. 使代码更具可读性。 很容易就能分辨出使用了可读性和可维护性强的变量代码库。 2. 轻松更改大型文档 如果将所有变量保存在单独的文件中，更改变量的时候，不需要在多个文件之间跳来跳去，只需在单独的文件中更改变量的值就可以了。 3. 可以更快的发现拼写类型错误 搜索可能有错误的代码是一件十分痛苦的事，如果错误是由简单的拼写产生的就更加的难受了，使用变量可以很好的消除这些麻烦。 总的来说，可读性和可维护性是最大的好处。多亏了CSS变量，我们可以在原生的CSS中使用这些变量。 如何定义 CSS 变量 CSS变量通常以两个破折号开头--。CSS变量也成为自定义属性。 1234.black { color: #8cacea; --color: blue;} 在JavaScript中，变量是有作用域的，可能是全局作用域或者局部作用域。CSS变量中也有这样的说法。 123:root { --main-color: red} :root选择器是你可以定位DOM或文档树中的最高级别元素。所以以这种方式声明的变量可以被称作全局作用域的变量。当然，局部作用域的变量也是局单个选择器声明中可以取代全局作用域的变量。 Example 1 假设您想创建一个CSS变量来存储主题网站的原色。你该怎么做呢？ 您创建范围选择器。使用:root作为“全局”变量。 1:root { } 定义变量。 1:root { --primary-color: red} 使用 CSS 变量 一旦定义了变量并为其分配了值，就可以继续在属性值中使用它。 在预处理中，我们必须通过引用声明的变量名来使用它。 12345$font-size: 20px;.test { font-size: $font-size;} 在原生的CSS变量中，使用方法有所不同。我们通过使用var()函数来引用变量。上例中的写法如下： 1234567:root { --font-size: 20px;}.test { font-size: var(--font-size);} CSS变量有许多限制。如，你只能将属性值设置给变量；不能使用数学计算，如果要使用数学计算，需要使用calc()函数。 12345/*this is wrong */.margin {--space: 20px * 2;font-size: var(--space); //not 40px}/* right way */.margin {--space: calc(20px * 2);font-size: var(--space); /*equals 40px*/} 属性值的用法 1. 自定义属性是普通属性，因此可以在任何元素上声明它们。 2. CSS变量使用常规继承和级联规则进行解析 123div { --color: red; }div.test { color: var(--color); }div.ew { color: var(--color); } 3. CSS变量可以使用@media和其他条件规则作为条件 12:root { --gutter: 10px; }@media screen and (min-width: 768px) { --gutter: 30px; } 4. CSS变量可以在HTML的style属性中使用 您可以选择设置内联变量的值，它们仍将按预期运行。 123456&lt;!--HTML--&gt;&lt;html style=\"--color: red\"&gt;&lt;style&gt;body { color: var(--color)}&lt;/style&gt; 注意，变量声明分辨大小写。尽量使用小写来书写变量。 关于多个声明 与其他属性一样，使用标准级联可以解析多个声明。 让我们来看一个例子： 123456/*define the variables*/:root { --color: blue; }div { --color: green; }#alert { --color: red; }/*use the variable */* { color: var(--color); } 使用上面的变量声明，以下元素的颜色是什么？ 12345678910&lt;!-- blue --&gt;&lt;p&gt;What's my color?&lt;/p&gt;&lt;!-- green --&gt;&lt;div&gt;and me?&lt;/div&gt;&lt;!-- red --&gt;&lt;div id='alert'&gt; What's my color too? &lt;!-- red --&gt; &lt;p&gt;color?&lt;/p&gt;&lt;/div&gt; 上面的最后一个&lt;p&gt;color？&lt;/p&gt;你可能期望是blue,但和其他属性一样，CSS变量也是继承的。该值是从父级#alert继承的。 解决循环依赖 循环依赖的发生情况。 1. 何时变量取决于自身。也就是说，它使用引用自身的var（） 1:root { --m: var(--m)}body { margin: var(--m)} 2.当两个或多个变量相互引用时 1234:root { --one: calc(var(--two) + 10px); --two: calc(var(--one) - 10px);} 注意不要在代码中创建循环依赖关系。 无效变量会发生什么？ 语法错误不会报错，但是无效的var()将会替换默认为相关属性的初始值或继承值。 123:root { --color: 20px; }p { background-color: red; }p { background-color: var(--color); } 如预期的那样，--color被替换为var()，但替换后的属性值background-color：20px无效。由于background-color不是可继承的属性，因此该值将默认为其透明的初始值。 构建字段时要小心 如下所示设置属性的值时，20px被解释为单个标记。 一种简单的输入方法是，将值20px视为一个“实体”。 使用CSS变量构建单个标记时，请务必小心。 例如，考虑以下代码块： 12:root { --size: 20}div { font-size: var(--size)px /*WRONG*/} 您可能期望font-size的值产生20px，但这是错误的。 浏览器将其解释为20 px 注意20后的空格。 因此，如果您必须创建单个令牌，则用一个变量代表整个令牌。例如--size：20px，或使用calc函数，例如calc（var（-size）* 1px），其中--size等于20 使用技巧 1. 使用CSS变量创建组件变体 background: var(--color, black)，如var()函数的第二个属性，设置背景色的回退值。如果变量失效或者不存在，则采用black作为后备选项。 使用CSS变量能够省去很多重复的书写。 2. 具有CSS变量的主题网站 主体CSS，假设给一个按钮绑定事件监听器，一段JS。 1234body { background-color: var(--bg, white); color: var(--bg-text, black);} js代码： 123456789101112131415161718const root = document.documentElement;const themeBtns = document.querySelectorAll('.theme &gt; button');themeBtns.forEach((btn) =&gt; { btn.addEventListener('click', handleThemeUpdate)});function handleThemeUpdate(e) { switch(e.target.value) { case 'dark': root.style.setProperty('--bg', 'black'); root.style.setProperty('--bg-text', 'white'); break; case 'calm': root.style.setProperty('--bg', '#B3E5FC'); root.style.setProperty('--bg-text', '#37474F'); break; case 'light': root.style.setProperty('--bg', 'white'); root.style.setProperty('--bg-text', 'black'); break; }} 关于浏览器的支持 支持率可以说是非常的好了。 参考","link":"/2019/11/18/%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84CSS%E5%8F%98%E9%87%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"函数去抖debounce和函数节流throttle的应用","text":"开始以为只有节流函数，原来还有去抖函数啊。两个概念第一次听的话肯定比较容易混淆，接下来就来研究一下它们吧。 # 函数去抖debounce 在一段时间内执行该动作，在单位时间内重新调用该动作，会重新计算时间。 我的理解就是，只要触发的够快，函数就追不上我，哈哈哈。 当我停下来的时候，函数会触发最后一次。所以其中肯定有一个定时器哈，下面展示一下简单实现的代码。 123456789101112131415161718function debounce(fn, delay) { // 定义一个定时器 var timer = null; return function() { // 绑定函数调用时上下文及参数 var context = this; args = arguments; clearTimeout(timer); timer = setTimeout(function() { console.log('debounce被触发了'); fn.apply(context, args); }, delay); }}// 定义一个btn，然后去点它来测试$('.btn-click-debounce').on('click', debounce(function() { console.log('200ms一次')}, 200)) 函数节流throttle 将倾斜而出的水流，一点一点的流出，这就是节流。放在函数触发中，就是本来快速l连续触发的事件以单位时间为间隔来触发。简单实现的源码： 12345678910111213141516171819202122232425262728function throttle(fn, threshhold) { var last = null; var timer = null; threshhold || (threshhold = 200); return function () { var context = this; var args = arguments; var now = +new Date(); // Date.now(); if(last &amp;&amp; ((now &lt; last + threshhold)) { // 判断时间间隔，以及是否第一次触发 clearTimeout(timer); timer = setTimeout(function() { last = now; console.log('throttle被触发了'); fn.apply(context, args); }, threshhold) } else { last = now; console.log('throttle被触发了'); fn.apply(context, args); } }}$('.btn-click-throttle').on('click', throttle(function() { console.log('200ms一次')}, 200)) 使用的场景 throttle函数节流 Dom元素的拖拽实现（mousemove） 射击游戏的mousedown/keydown事件（单位时间只能发射一颗子弹） 计算鼠标移动的距离（mousemove） Canvas模拟画板功能 搜索联想（keyup） 监听滚动事件是否到底部自动加载更多（ 监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次） debounce应用场景 每次resize/scroll触发统计 文本输入的验证（连续输入文字后发送ajax进行验证，验证一次就好） 参考 http://www.cnblogs.com/zichi/p/5948936.html https://www.cnblogs.com/fsjohnhuang/p/4147810.html","link":"/2018/07/08/%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96debounce%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81throttle%E7%9A%84%E5%BA%94%E7%94%A8/"},{"title":"关于之前看看的一些css","text":"记一下上个月看的图解CSS的一些简单的知识点哈。 # 元素百分比的相对计算 相对的元素计算 属性 父元素宽度 width, left, right, text-indent, padding, margin等 父元素高度 height, top, bottom等 主轴长度 flex-basis 继承字号 flex-size 自身字号 line-height 自身宽高 vertical-align 自身设置 background-position; border-image-slice 特殊算法 position: absolute，相对于父元素最近的position不为static的祖先元素。如果没有这样的元素，则相对于视口。 结构伪类选择器 选择器 功能描述 E:first-child 作为父元素的第一个子元素E E:last-child 作为父元素的最后一个子元素的元素E E:root 选择匹配元素E所在文档的根元素 E F:nth-child(n) 选择父元素的第n个子元素F E F:nth-last-child(n) 选择元素E的倒数第n个子元素F E:nth-of-type(n) 选择父元素内具有指定类型的第n个E元素 E:nth-last-of-type(n) 选择父元素内具有指定类型的倒数第n个E元素 E:first-of-type 选择父元素内具有指定类型的的第一个E元素，与E:nth-of-type(1)相同 E:last-of-type 选择父元素内具有指定类型的的最后一个E元素，与E:nth-last-of-type(1)相同 E:only-child 选择父元素只包含一个字元素，且该子元素匹配E元素 E:only-of-type 选择父元素只包含一个同类型的子元素，且该子元素匹配E元素 E:empty 选择没有子类型的元素，而且该元素也不包含任何文本节点 关于，伪类元素选择器中n的用法，也就是n取0到+∞，在子元素的个数范围内，取相对应的子元素。 伪元素 伪类一般反映无法在CSS中轻松或可靠地检测到的某个元素的属性或状态；伪元素则表示DOM外部的某种元素。 伪元素 功能描述 ::first-letter 选择文本块的第一个字母，除非在同一行中包含一些其他元素 ::first-line 匹配元素的第一行文本 ::before和::after 生成的内容不会成为DOM的一部分，但是可以设置样式 ::selection 匹配突出显示的文本，可设置background和color border相关 border-shadow 属性 功能描述 none 默认值，元素没有任何阴影效果 inset 阴影类型，可选值。默认外投影 x-offset 阴影水平偏移量，其值可以是正负值。正值在元素右边 y-offset 阴影垂直偏移量，其值可以是正负值。正值在元素底部 blur-radius 阴影模糊半径，可选参数。取值为0，表示阴影不具有模糊效果，取值越大，阴影的边缘越模糊 spread-radius 阴影扩展半径，可选参数。正值整个阴影都延展扩大，负值，整个阴影缩小 color 阴影颜色，不取值则是默认色，各个浏览器的默认色不一样的。 css3背景 主要有 * background-color 背景颜色 * background-image 背景图片 * background-repeat 背景图片展示方式 * background-attachment 背景图片是固定还是滚动 * background-position 背景图片位置 CSS3新增属性 * background-origin 指定绘制背景图片的起点（padding-box||border-box||content-box） * background-clip 指定背景图片的显示范围（padding-box||border-box||content-box） * background-size 指定背景图片的尺寸大小（auto||percentage||cover||contain） * background-break 指定内联元素的背景图片进行平铺时的循环方式 css文本类型 属性 功能描述 取值 word-spacing 定义词与词之间的间距 normal，length（设置词与词之间间距，可以是负数） letter-spacing 定义字符之间的间距 normal，length（设置词与词之间间距，可以是负数） vertiacl-align 定义文本的垂直对齐方式 baseline、sub（上标对齐）、super（下标对齐）、bottom（行框底端对齐）、text-bottom（行内文本底端对齐）、top（顶端对齐）、middle（居中对齐）、百分比数字、长度 text-decoration 定义文本的修饰线 none、underline、overline、line-through、blink text-indent 定义文本首行缩进 length（长度单位）和百分比 text-align 定义文本水平对齐方式 left（左对齐）、center（水平对齐）、right（右对齐）、justify（两端对齐） line-height 定义文本行高 normal、长度值、百分比值、数字 text-transform 定义文本大小写 none、uppercase、lowercase、capitalize（首字母大写） text-shadow 定义文本阴影效果 white-space 定义文字之间和文本之间的空白符间距 normal、nowrap（空白符合并，换行符忽略）、pre（空白符，换行符保留）、pre-wrap（空白符，换行符保留）、pre-line（空白符合，换行符保留） direction 控制文本流入的方向 ltr、rtl（文本从右到左流入）、inhert（文本流入方向有继承获得） text-overflow：实现文本溢行处理，word-break: break-all来实现浏览器文本的换行 多行文本怎么实现文本溢出...,在webkit内核 123display: -webkit-box-webkit-line-clamp: 2-webkit-box-orient: vertical 指定过渡属性transition-property none： 没有指定任何样式。 all：默认值，表示指定元素所有支持transition-property属性的样式。 &lt;single-transition-property&gt;：指定样式，其等于all或者。 颜色属性 具有长度值 integer（离散步骤，整个数字，在真实的数字空间，以及使用floor()转换为整数时发生，如outline-offset，z-index） number 变形系列属性 rectangle（通过x，y，width，height（转为数值）变换，如crop属性） visibility（离散步骤，在0~1范围内。0表示隐藏，1表示完全显示） 阴影（shadow，如text-shadow） 渐变（gradient）：通过每次停止时的位置和颜色进行变化。 paint server(SVG) space-separated list of above 缩写属性","link":"/2018/06/12/%E5%85%B3%E4%BA%8E%E4%B9%8B%E5%89%8D%E7%9C%8B%E7%9C%8B%E7%9A%84%E4%B8%80%E4%BA%9Bcss/"},{"title":"常用meta标签","text":"meta常用属性 原地址 作用：提供HTML文档的元数据，常用于告知浏览器如何显示内容和搜索引擎优化。 # 网页相关 ## 声明编码 1&lt;meta charset='utf-8' /&gt; 优先使用IE最新版本和Chrome 12345&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;&lt;!-- 关于X-UA-Compatible --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=6&quot; &gt;&lt;!-- 使用IE6 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot; &gt;&lt;!-- 使用IE7 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot; &gt;&lt;!-- 使用IE8 --&gt; 浏览器内核控制 国内浏览器很多都是双内核(wekit和Trident)，wekit内核高速浏览，IE内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染。 1&lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt; 国内双核浏览器默认内核模式如下: 1. 搜狗高速浏览器、QQ浏览器: IE内核（兼容模式） 2. 360极速浏览器、遨游浏览器: Webkit内核（极速模式） 禁止浏览器从本地计算机的缓存中访问页面内容 这样设定,访问着者无法脱机浏览。 1&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; ## Windows 8 * Windows 8 磁贴颜色 1&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt; * Windows 8 磁贴图标 1&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt; 站点适配 主要用于PC-手机页的对应关系。 1&lt;meta name=&quot;mobile-agent&quot;content=&quot;format=[wml|xhtml|html5]; url=url&quot;&gt; * [wml | xhtml | html5] 根据手机页的协议语言，选择其中一种。 * url=\"url\" 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系 避免百度转码声明 用百度打开网页可能会对其进行转码(比如贴广告)，避免转码可添加如下meta 1&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt; 用于SEO优化 页面关键词 每个网页应具有面熟网页内容的一组唯一的关键字，不要太长也不要太短 1&lt;meta name=&quot;keywords&quot; content=&quot;your tags&quot; /&gt; 页面描述 每个网页都应该有一个不超过１５０字符的页面描述 1&lt;meta name=&quot;description&quot; content=&quot;150 words&quot; /&gt; ## 设置搜索引擎索引方式 123456789&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;&lt;!-- all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。--&gt; 移动设备 viewport viewport能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放 * 大部分4.7-5寸设备的viewport宽设为360px； * 5.5寸设备设为400px； * iphone6设为375px；ipone6 plus设为414px。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no&quot;/&gt; width=device-width会导致iPhone5添加到主屏后以WebApp全屏模式打开页面时出现黑边 * width宽度 数值或device-width，范围从200到10000，默认980像素 height高度 数值或device-height， 范围从223到10000 initial-scale 初始的缩放比例 范围从0到10 minimum-scale 允许用户缩放到的最小比例 maximum-scale 允许用户缩放到的最大比例 user-scalable 用户是否可以手动缩 注意，很多人使用initial-scale=1运用到非响应式网站上，这会让网站以100%宽度渲染，用户需要手动移动页面或者缩放。如果nitial-scale=1同时使用user-scalable=no或maximum-scale=1，则用户将不能放大/缩小网页来看到全部的内容。 WebApp全屏模式 启用全屏模式，伪装app，离线应用。 1&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; 隐藏状态栏/设置状态栏颜色 只有在开启WebApp全屏模式时才生效。 content的值为default | black | black-translucent 。 1&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt; 添加到主屏后的标题 1&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; 忽略数字自动识别为电话号码 1&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt; 忽略识别邮箱 1&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt; 添加智能 App 广告条 Smart App Banner 告诉浏览器这个网站对应的app，并在页面上显示下载banner 1&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID,affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; 针对不识别Viewport的手持设备进行优化 主要是针对一些老的不识别viewport的浏览器，比如黑莓 1&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt; 适配微软的老式浏览器 1&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt; 强制竖屏 1234&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt; 强制全屏 1234&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt; windows phone 点击无高光 1&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;","link":"/2017/10/14/%E5%B8%B8%E7%94%A8meta%E6%A0%87%E7%AD%BE/"},{"title":"抽象系统的多重表示","text":"主要是对SICP(Structure and Interpretation of Computer Programs)，第二章四节的读书笔记。 文中由复数的两种表达形式引出了，基于类型分派(Tagged Data)， 消息传递(Message Passing), 数据导向(Data Directed)。 复数的表示 复数存在两种表达方式：直角坐标形式（实部和虚部），极坐标形式（模和幅角）。如何使两种表达形式共存于同一个系统中。 复数的两种表达形式分别适用不同的运算。 复数的加法倾向于用直角坐标系： 实部(Z₁ + Z₂) = 实部(Z₁) + 实部(Z₂) 虚部(Z₁ + Z₂) = 虚部(Z₁) + 虚部(Z₂) 复数的乘法自然的考虑是复数的极坐标： 模(Z₁ * Z₂) = 模(Z₁) * 模(Z₂) 幅角(Z₁ * Z₂) = 幅角(Z₁) + 模(Z₂) 从编写程序角度来说，我们需要所有的复数操作都可以使用，不论所用的具体表示形式是什么。 复数的运算 假定所有复数运算的实现都基于如下四个选择函数：real-part, imag-part, magnitude和angle; 两个构造的过程：make-from-real-imag返回一个采用实部和虚部描述的复数，make-from-mag-ang返回一个采用模和幅角描述的复数。 12(make-from-real-imag (real-part z) (imag-part z))(make-from-mag-ang (magnitude z) (angle z)) 复数的加减法采用实部和虚部的方式描述，乘法和除法采用模和幅角的方式描述： 123456789101112(define (add-complex z1 z2) (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))(define (sub-complex z1 z2) (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))(define (mul-complex z1 z2) (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))(define (div-complex z1 z2) (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2)))) 在这里，实部、虚部、模和幅角有以下关系： \\(x = r cos A\\) \\(y = r sin A\\) \\(r = \\sqrt{x ^ 2 + y ^ 2}\\) \\(A = arctan(y, x)\\) 复数的直角坐标表示 采用直角坐标表示形式，选取复数与虚部是直截了当的。选取极坐标表示形式则可以利用上面的公式，提供新的选择函数和构造函数： 123456789(define (real-part z) (car z))(define (imag-part z) (cdr z))(define (magnitude z) (sqrt (+ (square (real-part z)) (square (imag-part z)))))(define (angle z) (atan (imag-part z) (real-part z)))(define (make-from-real-imag x y) (cons x y))(define (make-from-mag-ang r a) (cons (* r (cos a)) (* r (sin a)))) 复数的极坐标表示 在复数的极坐标表示中，选取模和幅角的操作直截了当，实部和虚部则需要通过三角关系去获取。 12345678910(define (real-part z) (* (magnitude z) (cos (angle z))))(define (imag-part z) (* (magnitude z) (sin (angle z))))(define (magnitude z) (car z))(define (angle z) (cdr z))(define (make-from-real-imag x y) (cons (sqrt (+ (square x) (square y))) (atan y x)))(define (make-from-mag-ang r a) (cons r a)) 带标志数据 如果要在同一个系统里包含复数的两种不同表示形式，需要一种方式，将极坐标形式的数据和直角坐标形式的数据分开。 假想一下，现在需要找到对偶(3,4)的magnitude，我们无法知道答案是5（将数据解释直角坐标表示形式）还是3（将数据解释为极坐标表示）。 为了完成这种区分，我们在每个复数包含一个类型标志部分，用符号rectangular或者polar。此后操作一个复数的时候，借助这个标志就可以确定应该使用的选择函数。 我们需要新定义几个过程，我们假定有过程type-tag和contents，他们分别从数据对象中提取出类型和实际内容（对于复数的情况，其中的极坐标或者直角坐标）。还要假定一个过程attach-tag，它以一个标志和实际内容为参数，生成一个带标志的数据对象。 12345678910111213141516(define (attach-tag type-tag contents) (cons type-tag contents))(define (type-tag datum) (if (pair? datum) (car datum) (error \"Bad tagged datum -- TYPE-TAG\" datum)))(define (contents datum) (if (pair? datum) (cdr datum) (error \"Bad tagged datum -- CONTENTS\" datum)));; 添加判断函数(define (rectangular? z) (eq? (type-tag z) 'rectangular))(define (polar? z) (eq? (type-tag z) 'polar)) 添加类型tag的直角坐标表示 123456789101112131415(define (real-part-rectangular z) (car z))(define (imag-part-rectangular z) (cdr z))(define (magnitude-rectangular z) (sqrt (+ (square (real-part-rectangular z)) (square (imag-part-rectangular z)))))(define (angle-rectangular z) (atan (imag-part-rectangular z) (real-part-rectangular z)));; 直角坐标表示构造函数(define (make-from-real-imag-rectangular x y) (attach-tag 'rectangular (cons x y)))(define (make-from-mag-ang-rectangular r a) (attach-tag 'rectangular (cons (* r (cos a)) (* r (sin a))))) 添加类型tag的极坐标表示 1234567891011121314(define (real-part-polar z) (* (magnitude-polar z) (cos (angle-polar z))))(define (imag-part-polar z) (* (magnitude-polar z) (sin (angle-polar z))))(define (magnitude-polar z) (car z))(define (angle-polar z) (cdr z))# 极坐标表示构造函数(define (make-from-real-imag-polar x y) (attach-tag 'polar (cons (sqrt (+ (square x) (square y))) (atan y x))))(define (make-from-mag-ang-polar r a) (attach-tag 'polar (cons r a))) 通用选择函数的实现 每个通用型选择函数都需要实现这样的过程，首先检查参数的标志，而后去调用处理该类型的适当过程。例如，为了得到一个复数的实部，real-part需要通过检查，设法确定是去使用real-part-rectangular还是real-part-polar。这两种情况下，我们都用contents提取出原始的无标志数据，送给它所需的直角坐标过程或者极坐标过程。 123456789101112131415161718192021222324(define (real-part z) (cond ((rectangular? z) (real-part-rectangular (contents z))) ((polar? z) (real-part-polar (contents z))) (else (error \"Unknown type -- REAL-PART\" z))))(define (imag-part z) (cond ((rectangular? z) (imag-part-rectangular (contents z))) ((polar? z) (imag-part-polar (contents z))) (else (error \"Unknown type -- IMAG-PART\" z))))(define (magnitude z) (cond ((rectangular? z) (magnitude-rectangular (contents z))) ((polar? z) (magnitude-polar (contents z))) (else (error \"Unknown type -- MAGNITUDE\" z))))(define (angle z) (cond ((rectangular? z) (angle-rectangular (contents z))) ((polar? z) (angle-polar (contents z))) (else (error \"Unknown type -- ANGLE\" z)))) 实现复数算术运算时，原有的add-complex过程保持不变，因为它们调用的选择函数现在都是通用型，对任何表示都能工作。 现在我们还需要选择合理的构造函数，合理的选择是手头有实部和虚部时采用直角坐标表示，有模和幅角就采用极坐标表示。 12345678910(define (add-complex z1 z2) (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))));; 调用合理的构造函数(define (make-from-real-imag x y) (make-from-real-imag-rectangular x y))(define (make-from-mag-ang r a) (make-from-mag-ang-polar r a)) 在给定的一种表示实现中，复数是一种无类型的对偶（模，幅角）。当一个通用型选择函数对一个polar类型的复数进行操作的时，它会剥去标志并将相应内容传递给处理极坐标的代码。与此对应，当极坐标表示构造一个供一般性使用的复数时，也需要为其加上类型标志，使这个对象可以为高层过程所识别。在将数据对象从一个层次传到另一个层次的过程中，这种剥去和加上标志的规范方式可以成为一种重要的组织策略。 类型分派，数据导向，消息传递 在需要处理针对不同类型的一集公共通用型操作时，事实上，我们所在处理的是一个二维表格，其中一维包含着所有的可能操作，另一维就是所有的可能类型。表格中的项目是一些过程，它们针对作为参数的每个类型实现每一个操作。在前一节中开发的复数系统里，操作名字、数据类型和实际过程之间的对应关系散布在各个通用界面过程的各个条件子句。 操作 Polar Rectangular real-part real-part-polar real-part-rectangular imag-part imag-part-polar imag-part-rectangular magnitude magnitude-polar magnitude--rectangular angle angle-polar angle-rectangular 基于类型的分派 检查一个数据项的类型，并据此去调用某个适当过程称为 基于类型的分派 类型分派有两个显著的弱点： 对于处理不同函数类型的通用型选择函数，必须知道所有类型的不同表示。 独立的类型标识形式需要避免命名冲突。 上述两个弱点之下的基础问题是，基于类型的分派实现的系统不具有可加性。每次新增一种表达形式时，实现通用选择函数的人，必须去修改他们的过程，做单独的类型函数的人也必须修改他们的代码，避免命名冲突。所有的修改直接对代码去做，极易产生错误。再假设，如果我们的系统有上百种不同的复数表示形式？将再难以维护。 数据导向的程序设计 数据导向的程序设计是一种使程序能直接利用上图表格工作的程序设计技术。 我们需要实现一个过程，由它用操作名和参数类型的组合到表格中查找，来找出应该调用的适当过程，并将这一过程应用与参数的内容。 添加新的表示包到系统中，就不需要修改任何现存的代码。 处理操作/类型表格需要两种方法：(op =&gt; 操作；type =&gt; 类型；item =&gt; 函数) 将函数放入表格中：(put &lt;op&gt; &lt;type&gt; &lt;item&gt;) 查找与操作和类型对应的项，获取函数： (get &lt;op&gt; &lt;type&gt;) 直角坐标表示的实现 我们需要定义一组过程或者说一个程序包，并通过向表格中加入一些项的方法，告诉系统如何去操作直角坐标形式表示的数。 1234567891011121314151617181920212223(define (install-rectangular-package) ;; internal procedures (define (real-part z) (car z)) (define (imag-part z) (cdr z)) (define (make-from-real-imag x y) (cons x y)) (define (magnitude z) (sqrt (+ (square (real-part z)) (square (imag-part z))))) (define (angle z) (atan (imag-part z) (real-part z))) (define (make-from-mag-ang r a) (cons (* r (cos a)) (* r (sin a)))) ;; interface to the rest of the system (define (tag x) (attach-tag 'rectangular x)) (put 'real-part '(rectangular) real-part) (put 'imag-part '(rectangular) imag-part) (put 'magnitude '(rectangular) magnitude) (put 'angle '(rectangular) angle) (put 'make-from-real-imag 'rectangular (lambda (x y) (tag (make-from-real-imag x y)))) (put 'make-from-mag-ang 'rectangular (lambda (r a) (tag (make-from-mag-ang r a)))) 'done) 这笔，直角坐标表示形式的real-part过程安装在操作名字real-part和类型(rectangular)表之下，其余选择函数与之类似。这个过程还提供给外部系统的构造函数。 极坐标表示的实现 1234567891011121314151617181920212223(define (install-polar-package) ;; internal procedures (define (magnitude z) (car z)) (define (angle z) (cdr z)) (define (make-from-mag-ang r a) (cons r a)) (define (real-part z) (* (magnitude z) (cos (angle z)))) (define (imag-part z) (* (magnitude z) (sin (angle z)))) (define (make-from-real-imag x y) (cons (sqrt (+ (square x) (square y))) (atan y x))) ;; interface to the rest of the system (define (tag x) (attach-tag 'polar x)) (put 'real-part '(polar) real-part) (put 'imag-part '(polar) imag-part) (put 'magnitude '(polar) magnitude) (put 'angle '(polar) angle) (put 'make-from-real-imag 'polar (lambda (x y) (tag (make-from-real-imag x y)))) (put 'make-from-mag-ang 'polar (lambda (r a) (tag (make-from-mag-ang r a)))) 'done) 复数运算 虽然极坐标和直角坐标有些过程有相同的名字（如real-part），但对其他部分而言，这是内部的，不会有名字冲突问题。 复数系统的选择函数需要通过一个中间函数来访问有关类型apply-generic，访问表格中操作名和参数剋行所适用的过程。 12345678(define (apply-generic op . args) (let ((type-tags (map type-tag args))) (let ((proc (get op type-tags))) (if proc (apply proc (map contents args)) (error \"No method for these types -- APPLY-GENERIC\" (list op type-tags)))))) 通用型选择函数定义 1234(define (real-part z) (apply-generic 'real-part z))(define (imag-part z) (apply-generic 'imag-part z))(define (magnitude z) (apply-generic 'magnitude z))(define (angle z) (apply-generic 'angle z)) 实际算数运算中，过程add-complex等保持不变，调用相同的选择函数。 1234(define (make-from-real-imag x y) ((get 'make-from-real-imag 'rectangular) x y))(define (make-from-mag-ang r a) (get 'make-from-mag-ang 'polar) r a) 消息传递 消息传递风格的程序设计来源于，将数据对象设想为一个实体，它以“消息”的方式接受所需操作的名字。 数据传递的程序设计中，最关键的想法就是显式处理操作-类型表格的方式，管理程序中的各种通用型操作。基于类型的分派的组织方式中，让每个操作管理自己的分派。从效果上来看，这种方式就是将操作-类型表格分解成一行一行，每个通用型过程表示为表格的一行。 消息传递的实现策略是：将表格按列进行分解，不是采用一批“智能操作”去基于数据类型分类，而是采用“智能数据对象”，基于操作名完成分派。我们将数据对象（如一个采用直角坐标表示的复数）表示为一个过程，以操作的名字作为输入，能够去执行指定的操作。 12345678910(define (make-from-real-imag x y) (define (dispatch op) (cond ((eq? op 'real-part) x) ((eq? op 'imag-part) y) ((eq? op 'imagnitude) (sqrt (+ (square x) (square y)))) ((eq? op 'angle) (atan x y)) (else (error \"Unkown op -- MAKE-FORM-REAL-IMAG\" op)))) dispatch) 调用make-from-real-imag返回的是一个过程---内部的dispatch过程。相当于一个整体数据对象。 对应的apply-generic过程对参数应用一个通用型操作，将操作名传递给数据对象，并让那个对象完成剩下工作。 消息传递不是一种数学技巧，而是一种有价值的技术，可以用于组织带有通用型操作的系统。 思考 一个带有通用型操作的大型系统可能不断演化，在演化过程中常需要添加新的数据类型或者新的操作。对于上面讨论的三种策略：带有显示分派的通用型操作，数据导向的风格，以及消息传递的风格。请描述在加入一个新类型或者新操作时，系统所必须做的修改。哪种组织方式最适合那些经常需要加入新类型的系统？哪种组织方式最适合那些需要加入新操作的系统。 显示分派：这种策略在增加新操作时需要使用者避免命名冲突，而且每当增加新类型时，所有通用操作都需要做相应的改动，这种策略不具有可加性，因此无论是增加新操作还是增加新类型，这种策略都不适合。 数据导向：数据导向可以很方便地通过包机制增加新类型和新的通用操作，因此无论是增加新类型还是增加新操作，这种策略都很适合。 消息传递：消息传递将数据对象和数据对象所需的操作整合在一起，因此它可以很方便地增加新类型，但是这种策略不适合增加新操作，因为每次为某个数据对象增加新操作之后，这个数据对象已有的实例全部都要重新实例化才能使用新操作。","link":"/2020/02/06/%E6%8A%BD%E8%B1%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA/"},{"title":"构建简易网页浏览器","text":"这篇文章是对观看Programming Languages -Building a Web Browser视频课程的总结。课程介绍了编程语言的基础知识。关键概念包括如何指定和处理有效的字符串，句子和程序结构。课程中使用python来演示相关概念的示例代码。 概述 1. 字符串模式 有效的Javascript程序的集合，只是一组非常大的字符串。我们需要使用一些工具来处理它。 2. 词法分析 将很大的字符串（例如网页）分解为令牌列表(tokens)，词法分析器使用有限状态机实现。词法分析所定义的type，定义了一连串的值或者相关的操作，像number，string, + - / *， length和list等。 Regular Expression 来指定一些字符集的简明表示法。(Regular Language)，用来做词法分析。 使用诸如r+, r*, r1|r2, [a-z], r?，来指定token。 Finite State Machines 绘制正则表达式，讨论了正则表达式如何转化成FSM，讨论了DSA(deterministic finite automaton)与NFA(nondeterministic finite automaton)的区别。没有具体讨论实现的算法和DFA和NFA状态机的基本定义。 3. 语法分析 Context Free Grammers 也是用来指定一些字符串集的简明表示法，预先定义一些加法，减法的定义，函数的定义等，用来做语法分析。 拥有记忆部分，也可以称之为动态规划。 例如 12345678910111213141516171819202122# 声明语句:stmt =&gt; identifier = expexp =&gt; exp + expexp =&gt; exp - expexp =&gt; number# 表达式语句：stmt =&gt; identifier = expstmt =&gt; return exp# 控制流stmt =&gt; if exp compoundstmtstmt =&gt; if exp compoundstmt else compoundstmtcompoundstmt =&gt; { stmts }# 递归stmts =&gt; stmt stmtsstmt =&gt; some expression# functions, JS 程序就是语句和函数定义列表element =&gt; function identifier (optparams) compoundstmtcompoundstmt =&gt; { stmts } 枚举所有的有效字符串是十分慢的，课程中介绍了记忆图表解析技术的方式，将上下文无关语法和可能记忆组合到一起。其他GLR(广义LR解析)，LALRCD，LLLRLALR等顺带提了一下。 4. 解析 如果词法分析获得的tokens列表在预先定义的上下文无关语法(CFG)中，则生成解析树。 解析树的时候，需要带入scope作用域。我们称之为environment变量。 环境变量主要有两个作用： 1. 将变量映射到值。 2. 指向父环境。 解释解析树的时候，需要带上environment去解释。 继而介绍了图灵机的停机问题，解释了为什么程序部分运行中产生的错误，无法优化，例如while死循环。 5. 解释 解释前需要做的工作 解析前需要做的操作有sematics(语义)和optimization(优化)。 语义: 程序可能有类型错误，例如你用字符串除以整数。或者有一些其他的情况，一般情况下会返回一个值，意味着我们已经计算了一下东西。 优化：将具有相同语义化但是需要更少资源的程序替换另一端程序。举例x + 1 =&gt; x，使用x替换x + 1计算后的值，优化的关键是不能更改程序的含义，x/x不能替换城1。这一部分，V8引擎会去做。 解释过程 在优化的分析树上进行递归遍历，程序的含义通过子表达式的含义计算而得。 图形展示： web浏览器 对HTML使用词法解析和语法解析，将JavaScript视为特殊的令牌，HTML解释器接收JS解释器返回的字符串，HTML解释器调用图形库来展示返回的字符串。 学习总结 课程也不是很长，不过在学习的过程中，学习到了很多之前学前端应用知识没有的知识点。涉及了自动机，上下文无关等编译方面的知识。对计算的浏览器的整体运行也有了一个概括，很多知识知识代入性的，它告诉我了有这么个知识点。后期的学习中，可以慢慢挖掘这些知识点，去深入拓展自己的知识深度。","link":"/2020/03/24/%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"title":"移动端虚拟键盘和滚动穿透小结","text":"记录一下最近遇到的两个小bug，也不算小bug，可能在不同的移动端浏览器表现不同吧。一个是虚拟键盘顶起，一个是滚动穿透问题。 # 虚拟键盘 首先需要明确的一点是，虚拟键盘的顶起在IOS端和Android端有很大的不同变现。 监听移动端软键盘弹起和收起 1. Android端 监听resize 1234567891011var winHeight = $(window).height();$(window).resize(function () { var thisHeight = $(this).height(); if( winHeight - thisHeight &gt; 140) { // 键盘弹起，140px是一个预估值，可更改 } else { // 键盘收起 }}) 2. IOS端 监听input失焦blur ios中的键盘或者第三方键盘并不会监听到window resize事件，所以不能用resize监听，所以需要通过输入框是否获取焦点来判断。 在Android中，有一些机型，键盘收起了，输入框仍处于焦点状态，并没有触发focusout事件。 因为focusin和focusout支持冒泡，对应focus和blur，所以根据需求，我们可以选择相应的事件。 1234567$(document).on('focusin', function () { //软键盘弹出的事件处理});$(document).on('focusout', function () { //软键盘收起的事件处理}); input textarea contenteditable=\"true\" 置底问题 这里也需要了解一下，IOS和Android关于fixed属性的支持是不一样的。 ### 1. IOS端 ios中，虚拟键盘顶起来之后，整个页面都会被键盘部分压缩。也就是说页面的高度会变小，并且所有的fixed都会变成absolute。 也就是说，之前在ios端fixed到底部的input框等可focus元素，会变成absolute定位，并且随着页面能够滑动。 2. Android端 android端中，虚拟键盘顶起来之后，fixed属性不会失效，唤起的键盘是覆盖在页面上的，不会压缩页面。 项目中的bug及一些思考 在最近的一个项目中，移动端页面布局，因为现在手机的高度不同，简单的背景图并不能放文字了，文字会拉伸，我需要设置一个footer放到底部，这里我最开始考虑的就是用fixed布局到最底部，结果当键盘顶起来的时候，文字也就跟着一起顶上去了，整个页面使用的是overflow: hidden。 这里就需要监听键盘顶起事件，并执行相应的给元素添加相关css的功能。 123456789var oHeight = $(document).height();// 监听键盘事件$(window).resize(function () { if ($(document).height() &lt; oHeight) { $('footer').addClass('hide'); } else { $('footer').removeClass('hide'); }}); 另外，关于底部的输入框顶起的问题，我看了一下手机版微博的解决方案，在Android端，虚拟键盘顶起，应该直接是fixed在底部，在IOS端则是整个添加了一个评论的浮层，总来来说也是一个不错的方案。 最后介绍一个神奇的东西Element.scrollIntoView()，这个东西能把底部的输入框提高到可视区域，不过经过测试，键盘顶起是需要时间的，我们需要确保，在键盘调起之后，确保元素调用scrollIntoView()。 下面是我写的一段代码: 12345$('#el').on('focus', function () { setTimeout(() =&gt; { document.querySelector('#el').scrollIntoView(); }, 300);}); 滚动穿透 在移动端中，滚动穿透问题很常见，处理起来也比较繁琐。下面我还是按照不同的方法进行分类： touchmove事件中调用preventDefault() 这个方法适用于，弹出框内容无需滚动。如果弹出层内部有滚动事件，将会导致，弹出层的滚动事件也无法滚动。 添加相关的类 给html上添加一个noscroll的类 12345.noscroll,.noscroll body overflow: hidden.noscroll body poition: relative 缺点： 1. html和body的滚动都禁止了，弹出层关闭后，会丢失原有的滚动位置，需要用JS来还原 2. 有些页面的北京还有能滚的动的效果 fixed加上js恢复记录位置 css 1234body.mask-open { position: fixed; width: 100%;} 12345678910111213141516171819var scrollTop = 0;open.onclick = function() { scrollTop = document.body.scrollTop || document.documentElement.scrollTop; document.body.classList.add('mask-open'); document.body.style.top = -scrollTop + 'px'; // 脱离文档流后回到当前位置 mask.style.display = 'block';}close.onclick = function() { mask.style.display = 'none'; document.body.classList.remove('mask-open'); document.body.scrollTop = document.documentElement.scrollTop = scrollTop // 滚动到相应位置，确保兼容性} 参考 * 虚拟键盘 * https://cloud.tencent.com/developer/article/1004930 * http://www.cnblogs.com/wangyihong/p/7514304.html * 滚动穿透 * https://segmentfault.com/q/1010000002942948 * https://github.com/pod4g/tool/wiki/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98","link":"/2018/07/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98%E5%92%8C%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E5%B0%8F%E7%BB%93/"},{"title":"通过爬虫看async/await","text":"爬虫 先放下小练习地址 小爬虫爬取图片，然后来研究下，爬虫需要注意些什么。爬虫始于种子（所需爬取url列表），通过requset从中爬取所需的页面的每一个帖子数，然后从中获取图片的url,然后下载。 Request&amp;&amp;Cheerio 12345678910111213// 单个分页获取包涵图片URLfunction getPages(url: string): Promise&lt;string[]&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { R(url, (err, res, body) =&gt; { const $ = cheerio.load(body) let liDom = $('body &gt; div.content.clr &gt; div.content_left &gt; div.post_list_block_div &gt; ul &gt; li') const Pages = getPagesFromDom(liDom) resolve(Pages) }) }, 1000) })} const $ = cheerio.load(body)就是Cheerio最基本的用法然后看一下getPagesFromDom(liDom) 1234567function getPagesFromDom(dom: Cheerio) { return Array.from(dom).map((v, k) =&gt; { let t = v.attribs['onclick'] let url = uri + t.substring(24, t.length - 2) return url })} 中间我们传入的是一个dom: Cheerio对象，便于下一步的解析，对页面的帖子数相关连接的url进行记录。 接下来就是对每个帖子的发帖的前面的图片进行下载。 延时控制 123456789101112131415161718192021222324252627async function getImgPages(pages: string[]) { const taskQ = pages.map(async (v, k) =&gt; { await sleep(1000 * k) // 第二个节流方法 return getPages(v) }) let pageArray = await Promise.all(taskQ) const pagesArray = pageArray.reduce((prev, current) =&gt; prev.concat(current), []) return pagesArray}function getPages(url: string): Promise&lt;string[]&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { R(url, (err, res, body) =&gt; { const $ = cheerio.load(body) let liDom = $('body &gt; div.content.clr &gt; div.content_left &gt; div.post_list_block_div &gt; ul &gt; li') const Pages = getPagesFromDom(liDom) resolve(Pages) }) }, 1000) })}function sleep(ms: number) { return new Promise(resolve =&gt; setTimeout(resolve, ms))} 这里我用了一个setTimeout定时和map定时来获取每个页面的时间进行限制。这样的方法并不是很好，也是不推荐的方法，具体推荐的方法看下面对于async/await的分析，最要是因为，后面用的Promiseall(taskQ)这样定时的效果其实很差，这里详细看一下后面async异步注意项第三点。 第二个我为了时间控制的函数是一个递归函数 12345678910111213async function getSingleImg(imgUrls: string[], i: number = 0) { if (i&lt; imgUrls.length) { await sleep(1000) i++ let urls = await getImgUrl(imgUrls[i]) await urls.forEach((item) =&gt; { saveImg(item) console.log('单页面打印成功') }) imageUrls = await imageUrls.concat(urls) await getSingleImg(imgUrls, i++) }} 依旧利用了async中的顺序调用，感觉实现的方法很怪，不过好在也是实现了。 async/await ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 async 函数是什么？一句话，它就是 Generator 函数的语法糖。 引用async 函数 async函数对 Generator 函数的改进，体现在以下四点。 1. 内置执行器。 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 1asyncReadFile(); 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。 更好的语义。 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 更广的适用性。 co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 返回值是 Promise。 async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 使用注意点 第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。 12345678910111213141516async function myFunction() { try { await somethingThatReturnsAPromise(); } catch (err) { console.log(err); }}// 另一种写法async function myFunction() { await somethingThatReturnsAPromise() .catch(function (err) { console.log(err); });} 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12let foo = await getFoo();let bar = await getBar(); 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。(也就是我们需要用到的点。) 12345678async function dbFuc(db) { let docs = [{}, {}, {}]; // 报错 docs.forEach(function (doc) { await db.post(doc); });} 上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数， 12345678function dbFuc(db) { //这里不需要 async let docs = [{}, {}, {}]; // 可能得到错误结果 docs.forEach(async function (doc) { await db.post(doc); });} 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。 1234567async function dbFuc(db) { let docs = [{}, {}, {}]; for (let doc of docs) { await db.post(doc); }} 如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。 1234567891011121314151617181920async function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results);}// 或者使用下面的写法async function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = []; for (let promise of promises) { results.push(await promise); } console.log(results);} 错误处理 如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。 所以防止出错的方法，也是将其放在try...catch代码块之中。 如果有多个await命令，可以统一放在try...catch结构中。 也可以使用try...catch结构，实现多次重复尝试。例如在遍历中。","link":"/2017/11/24/%E9%80%9A%E8%BF%87%E7%88%AC%E8%99%AB%E7%9C%8Basync-await/"},{"title":"简单聊下响应式布局","text":"简单的从响应式布局的viewport介绍到读hexo博客的next主题的源码，来介绍下响应式布局。 viewport 谈到响应式，就离不开viewport。 移动端浏览器在一个通常比屏幕更宽的虚拟“窗口”（视口）中渲染页面，用户从而无须将所有页面都压缩进一个小屏幕里（那样会把很多没有针对移动端进行优化的站点打乱）。用户可以通过平移和缩放来浏览页面的不同区域。 两种viewport 布局视口(layout viewport) 视觉视口(visual viewport) 想象一下布局视口是一个足够大的而且不会改变尺寸和形状的图片，现在想象你有一个很小的框，你通过这个框来看上面那个足够大的图片。小框周围布满了不透明的材料，通过小框看到的大图就是视觉视口。你可以将小框向后移来观看所有的大图，也可以将小框靠近大图来观看大图的一部分。你也可以改变小框的方向，不过你要知道大图（布局视口）的形状和大小是从来没有改变的。 视觉视口（visual viewport）是在当前页面中显示屏幕的一部分。用户可能会滚动来改变他所看到的页面的一部分，或者通过缩放来改变视觉视口的尺寸。 然而，CSS布局，尤其是百分比宽度，是相对于布局视口计算的。布局视口比视觉视口宽的多。 因此&lt;html&gt;元素最初获取布局视口的宽度，而且你的CSS被解释为宽度比手机宽的多，就相当于上面比喻中小框远离视觉视口的大图。这样可以确保你的页面布局的行为和桌面是一样的。 不同的浏览器用的默认layoutview的大小是多少呢? Safari iPhone 使用980px Opera 使用850px Android WebKit 使用800px IE 使用974px 在桌面端viewport 桌面端有一个有趣的现象，如果我们定义body中的子元素width:100%，那么这100%相对于谁呢？对，相对于html，html的宽度又取决于viewport，viewport的宽度又相当于浏览器窗口的宽度。 上面的情况在100%zoom的时候显示正常，当我们缩放窗口的时候，viewport小于页面的总宽度。页面本身没有关系，内容现在溢出超过&lt;html&gt;，但是元素属性设置了overflow: visible，这边是超出的内容也会展示出来。 下例中，蓝色的顶部栏由于设置了width: 100%，所以浏览器会遵循viewport所设置的宽度。这样蓝色的顶部栏并不管现在它太狭窄了。 缩放zooming 两种视口都是用来测量CSS像素，但是显然视觉视口的尺寸是根据缩放改变的（如果你放大，屏幕上的像素就会变少）。如果布局视口没有一直保持不变，那么百分比计算的宽度将会回流和重新计算。 了解布局视口 为了了解布局视口，我们需要关注一下页面完全缩小的情况。很多移动浏览器都是在完全缩放的情况下展示页面。这种情况下视觉视口等于布局视口。 因此布局视口的宽度和高度等于我们在完全缩放模式看到的。即使当用户放大窗口，布局视口也保持不变。 而且当你旋转手机到水平的时候，布局视口的内容也没有变，依旧是缩放到手机上面。这种情况有会导致一个问题，高度比横向少得多，不过网页开发者一般不关心页面的高度，只关心宽度。 下面罗列几个布局视口的宽度 属性 含义 document. documentElement. clientWidth / Height 布局视口尺寸 window.innerWidth/Height 视觉视口尺寸 screen.width and screen.height 屏幕尺寸 window.pageX/YOffset 滚动偏移，和视觉视口相对于布局视口的值相同 document. documentElement. offsetWidth / Height &lt;html&gt;标签的尺寸 Media queries 测量&lt;html&gt;的宽度（width）或者设备的宽度(device-width)。 viewport Meta属性 这里让我们看一下&lt;meta name=\"viewport\" content=\"width=320\"&gt;的意义，这表示调整布局视口的尺寸。为了了解为什么这个属性这么重要，我们需要退后一步讨论。 假设你正在写一个简单的页面而且你没有设定你的元素的宽度。那么他们就会伸缩到布局视口宽度的100%。大多数浏览器都会将整个页面缩放来显示整个布局视口。像下图所示和缩放效果。 现在设置html {width: 320px}的时候，&lt;html&gt;将会收缩，所有的元素都会取320px的100%，但是这种情况只有用户放大页的时候才能得到，并不是初始化的状态。当用户缩小页面的时候，将会有大片的空白区域。 当你设置为&lt;meta name=\"viewport\" content=\"width=320\"&gt;的时候，初始化也显示正常了。你也可以设置任何你想要的宽度，包括device-width。将会取得屏幕的宽度screen.width（在设备像素中），于是布局视口将会使用这个值。 不过这里有一个问题，有时真正的screen.width并没有起多大的作用，因为像素树太高了。例如， Nexus One 的屏幕像素是480px，不过谷歌工程师觉得给480px的宽度作为device-width来说太大了。所以他们决定使用缩放到 2/3 ，所以device-width所表达的宽度就是320px。 最后这里介绍下典型的针对移动端优化的viewport 123&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt;&lt;!-- 添加用户缩放禁止 --&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1,maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt; width控制视口的宽度。可以设置width=600这样的固定值，或者device-width这类的特殊值来指导比例为100%时屏幕宽度的CSS像素数值。 像素并非像素 许多手机都有物理像素都比页面的布局大得多，所以移动端将会以多个物理像素现已单个CSS像素。意味着initial-scale=1在安卓或者ios手机上，都能显示较为接近的物理尺寸。 在240dpi及以上的屏幕上，initial-scale=1的页面实际上会被Android WebKit浏览器放大至150%。其中的文字会保持平滑锐利，但是位图图像在全屏模式下就会不尽人意。为了使图片在这些屏幕上变得清晰，web开发者会将图片甚至整个布局设计成最终尺寸的150%（或者200%从而支持像配备retina屏的iPhone那样的像素密度高达320 dpi及以上的设备），然后通过CSS或视口属性缩小。 默认比例依赖于显示密度。在密度低于200dpi的显示设备上，比例为1.0。在密度介于200及300dpi之间的显示设备上，比例为1.5。对于具有300dpi以上密度的现实设备，比例为/150dpi向下取整。注意再有在视口比例为1时才会应用默认比例。否则，CSS像素与设备像素之间的关系依赖于当前的缩放等级。 next源码中响应式应用 hexo中的next主题是一个非常热门的blog主题，其中的相关源码是使用stylus书写的。 首先在文件夹外面定义了尺寸，这部分尺寸定义在需要修改样式的地方会进行修改。 1234567891011121314151617181920212223242526272829303132333435mobile-smallest() { @media (max-width: 413px) { {block} }}mobile-small() { @media (max-width: 567px) { {block} }}mobile() { @media (max-width: 767px) { {block} }}tablet() { @media (min-width: 768px) and (max-width: 991px) { {block} }}desktop() { @media (min-width: 992px) { {block} }}desktop-large() { @media (min-width: 1600px) { {block} }} 博客的左侧的页面导航在小于767的时候会隐藏，在大于767px的时候会在左上显示。这里展示部分代码： 12345678910111213141516171819202122232425262728.site-nav-toggle { display: none; position: absolute; top: 10px; left: 10px; +mobile() { display: block; } button { margin-top: 2px; padding: 9px 10px; background: transparent; border: none; }}.site-nav { +mobile() { display: none; margin: 0 -10px; padding: 0 10px; clear: both; border-top: 1px solid $gray-lighter; } +tablet() { display: block !important; } +desktop() { display: block !important; }} 最后放下layout的布局stylus： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129.header { position: relative; margin: 0 auto; width: $main-desktop; +tablet() { width: auto; } +mobile() { width: auto; }}.header-inner { position: absolute; top: 0; overflow: hidden; padding: 0; width: 240px; background: white; box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +desktop-large() { .container &amp; { width: 240px; } } +tablet() { position: relative; width: auto; border-radius: initial; } +mobile() { position: relative; width: auto; border-radius: initial; }}.main { clearfix(); +tablet() { padding-bottom: 100px; } +mobile() { padding-bottom: 100px; }}.container .main-inner { width: $main-desktop; +tablet() { width: auto; } +mobile() { width: auto; }}.content-wrap { float: right; box-sizing: border-box; padding: $content-desktop-padding; width: $content-desktop; background: white; min-height: 700px; box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +tablet() { width: 100%; padding: 20px; border-radius: initial; } +mobile() { width: 100%; padding: 20px; min-height: auto; border-radius: initial; }}.sidebar { position: static; float: left; margin-top: 300px; width: $sidebar-desktop; background: $body-bg-color; box-shadow: none; +tablet() { display: none; } +mobile() { display: none; }}.sidebar-toggle { display: none; }.footer-inner { width: $main-desktop; padding-left: 260px; +tablet() { width: auto; padding-left: 0 !important; padding-right: 0 !important; } +mobile() { width: auto; padding-left: 0 !important; padding-right: 0 !important; }}.sidebar-position-right { .header-inner { right: 0; } .content-wrap { float: left; } .sidebar { float: right; } .footer-inner { padding-left: 0; padding-right: 260px; }} 小结 因为blog的主要受众还是网页端，所以默认尺寸的填写时桌面端，再根据媒体查询开始往小尺寸开始。我看网上有说，页面优先从小尺寸开始写，这样比较适合响应式。不过我觉得应该根据页面的主要受众，来决定是优先移动端还是桌面端。太复杂的页面应该也不用写响应式，应该根据桌面端和移动端单独设计。 引用 A Tale of Two Viewports A Tale of Two Viewports 在移动浏览器中使用viewport元标签控制布局 [@media](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media)","link":"/2019/01/15/%E7%AE%80%E5%8D%95%E8%81%8A%E4%B8%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"}],"tags":[{"name":"自动化","slug":"自动化","link":"/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"CircleCI","slug":"CircleCI","link":"/tags/CircleCI/"},{"name":"HTTP安全","slug":"HTTP安全","link":"/tags/HTTP%E5%AE%89%E5%85%A8/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"vitrual-dom","slug":"vitrual-dom","link":"/tags/vitrual-dom/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"vue-cnode","slug":"vue-cnode","link":"/tags/vue-cnode/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"babel","slug":"babel","link":"/tags/babel/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"foundation","slug":"foundation","link":"/tags/foundation/"},{"name":"html5","slug":"html5","link":"/tags/html5/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"Puppeteer","slug":"Puppeteer","link":"/tags/Puppeteer/"},{"name":"mongoose","slug":"mongoose","link":"/tags/mongoose/"},{"name":"socket.io","slug":"socket-io","link":"/tags/socket-io/"},{"name":"svg","slug":"svg","link":"/tags/svg/"},{"name":"JS基础事件","slug":"JS基础事件","link":"/tags/JS%E5%9F%BA%E7%A1%80%E4%BA%8B%E4%BB%B6/"},{"name":"触摸","slug":"触摸","link":"/tags/%E8%A7%A6%E6%91%B8/"},{"name":"wepy","slug":"wepy","link":"/tags/wepy/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"vue-music","slug":"vue-music","link":"/tags/vue-music/"},{"name":"Web优化","slug":"Web优化","link":"/tags/Web%E4%BC%98%E5%8C%96/"},{"name":"Web性能","slug":"Web性能","link":"/tags/Web%E6%80%A7%E8%83%BD/"},{"name":"MVC","slug":"MVC","link":"/tags/MVC/"},{"name":"MVP","slug":"MVP","link":"/tags/MVP/"},{"name":"MVVM","slug":"MVVM","link":"/tags/MVVM/"},{"name":"你不知道的JS","slug":"你不知道的JS","link":"/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"},{"name":"优化","slug":"优化","link":"/tags/%E4%BC%98%E5%8C%96/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"meta标签","slug":"meta标签","link":"/tags/meta%E6%A0%87%E7%AD%BE/"},{"name":"sicp","slug":"sicp","link":"/tags/sicp/"},{"name":"计算机基础","slug":"计算机基础","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"课程总结","slug":"课程总结","link":"/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"name":"移动端","slug":"移动端","link":"/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"兼容性","slug":"兼容性","link":"/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"mediaQuery","slug":"mediaQuery","link":"/tags/mediaQuery/"},{"name":"viewport","slug":"viewport","link":"/tags/viewport/"}],"categories":[{"name":"CircleCI","slug":"CircleCI","link":"/categories/CircleCI/"},{"name":"HTTPS","slug":"HTTPS","link":"/categories/HTTPS/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"asynchronous","slug":"asynchronous","link":"/categories/asynchronous/"},{"name":"vue-items","slug":"vue-items","link":"/categories/vue-items/"},{"name":"babel","slug":"babel","link":"/categories/babel/"},{"name":"Webpack","slug":"Webpack","link":"/categories/Webpack/"},{"name":"canvas","slug":"canvas","link":"/categories/canvas/"},{"name":"css世界","slug":"css世界","link":"/categories/css%E4%B8%96%E7%95%8C/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"express","slug":"express","link":"/categories/express/"},{"name":"mongodb","slug":"mongodb","link":"/categories/mongodb/"},{"name":"Puppeteer","slug":"Puppeteer","link":"/categories/Puppeteer/"},{"name":"socket.io","slug":"socket-io","link":"/categories/socket-io/"},{"name":"svg","slug":"svg","link":"/categories/svg/"},{"name":"wepy","slug":"wepy","link":"/categories/wepy/"},{"name":"web优化","slug":"web优化","link":"/categories/web%E4%BC%98%E5%8C%96/"},{"name":"computer","slug":"computer","link":"/categories/computer/"},{"name":"JStricks","slug":"JStricks","link":"/categories/JStricks/"},{"name":"HTML基础","slug":"HTML基础","link":"/categories/HTML%E5%9F%BA%E7%A1%80/"},{"name":"sicp","slug":"sicp","link":"/categories/sicp/"},{"name":"Browser","slug":"Browser","link":"/categories/Browser/"},{"name":"移动端bug","slug":"移动端bug","link":"/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AFbug/"},{"name":"爬虫","slug":"爬虫","link":"/categories/%E7%88%AC%E8%99%AB/"},{"name":"css","slug":"css","link":"/categories/css/"}]}